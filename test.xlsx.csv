위험도,폴더,대분류,취약점,위험인자 진입 파일경로,위험인자 진입 파일명,위험인자 진입 라인넘버,위험인자 진입 소스조각,위험인자 진입 함수,취약점 탐지 파일경로,취약점 탐지 파일명,취약점 탐지 라인넘버,취약점 탐지 소스조각,취약점 탐지 함수,취약점 이슈 개요,취약점 개요,취약점 설명,취약점 조치 권고내용,취약점 조치 tip,취약점 이슈 고유키,취약점 rule 고유키,auditor 태그,auditor 아이디,auditor 의견,스캔시간,
High,High,Input Validation and Representation,Path Manipulation,"Downloads/WebGoat-2023.5/WebGoat-2023.5/.mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",48,"    private static final String PROPERTY_NAME_WRAPPER_URL = ""wrapperUrl"";

    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);",main(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/.mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",50,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());
","java.io.File.File()","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",BCC0CC7930F0C1517E78308FD4FF0933,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Input Validation and Representation,Cross-Site Scripting: DOM,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",lambda(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",18,"                var progressBar = $('#progressBar' + i);
                progressBar.width(Math.round(percent) * 2 + '%');
                $(""#nrOfVotes"" + i).html(votes[i]);

            }","~JS_Generic.html()","challenge8.js의 lambda() 메서드가 18 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","challenge8.js의 lambda() 메서드가 18 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. DOM-based XSS의 경우, URL 매개 변수 또는 브라우저 내 다른 값에서 데이터를 읽어들이며 클라이언트 쪽 코드를 사용하여 페이지에 다시 씁니다. Reflected XSS의 경우 신뢰할 수 없는 소스는 일반적으로 웹 요청이지만, Persisted(Stored 라고도 함) XSS의 경우에는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다. DOM-based XSS의 경우, 피해자의 브라우저가 HTML 페이지를 구문 분석할 때마다 악성 콘텐트가 DOM(Document Object Model) 생성의 일부로 실행됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.

예제 1: 다음 JavaScript 코드 세그먼트는 URL에서 직원 ID인 eid를 읽고 사용자에게 표시합니다.


<SCRIPT>
var pos=document.URL.indexOf(""eid="")+4;
document.write(document.URL.substring(pos,document.URL.length));
</SCRIPT>



예제 2: 다음의 HTML 형식을 고려해 보십시오.


  <div id=""myDiv"">
    Employee ID: <input type=""text"" id=""eid""><br>
    ...
    <button>Show results</button>
  </div>
  <div id=""resultsDiv"">
    ...
  </div>


다음 jQuery 코드 세그먼트는 HTML 형식에서 직원 ID를 읽고 사용자에게 표시합니다.


  $(document).ready(function(){
    $(""#myDiv"").on(""click"", ""button"", function(){
      var eid = $(""#eid"").val();
      $(""resultsDiv"").append(eid);
      ...
    });
  });


이러한 코드 예제는 ID가 eid인 텍스트 입력에서 직원 ID에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

예제 3: 다음 코드는 React 응용 프로그램 내의 DOM-based XSS 예제를 보여 줍니다.


let element = JSON.parse(getUntrustedInput());
ReactDOM.render(<App>
    {element}
</App>);


Example 3에서 공격자가 getUntrustedInput()에서 파생된 전체 JSON을 제어할 수 있는 경우 React가 element를 구성 요소로 렌더링하도록 만들 수 있기 때문에 일반적인 Cross-Site Scripting 공격인 자체 제어 값으로 dangerouslySetInnerHTML을 이용하여 개체를 전달할 수 있습니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 하지만 자신의 컴퓨터에서 악의적인 코드가 실행되도록 입력을 제공하는 이유가 있을까요? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어들여 데이터가 동적 콘텐트에 포함됩니다.","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.

3. React 이전 버전은 전체 구성 요소를 제어하여 cross-site scripting 공격에 더 취약합니다. Symbols를 사용하여 React 구성 요소를 식별하는 최신 버전에서는 악용이 차단됩니다. 하지만 Symbol을 지원(기본적으로 또는 polyfills를 통해)하지 않는 구형 브라우저는 여전히 취약합니다. 다른 Cross-Site Scripting 공격 유형은 모든 브라우저 및 React 버전에 유효합니다.",86D6531C6F6737839E0CD291D7D3E3FC,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Security Features,Credential Management: Hardcoded API Credentials,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",lambda(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/.github/workflows/test.yml","test.yml",66,"                uses: joonvena/robotframework-reporter-action@v2.2
                with:
                    gh_access_token: ${{ secrets.GITHUB_TOKEN }}
                    report_path: 'robotreport'",ConfigPair(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","사용자 이름, 암호, API 키, API 기밀 및 API 토큰을 포함한 자격 증명을 하드코드하지 마십시오. 하드코드된 자격 증명은 모든 프로젝트 개발자에게 표시될 뿐만 아니라 업데이트하기가 매우 어렵습니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 자격 증명을 변경할 수 없습니다. 자격 증명이 손상되면 조직은 보안과 시스템 가용성 중 한 가지를 선택할 수밖에 없습니다.
        ","API 자격 증명이 런타임 환경에서만 사용할 수 있는 구성 파일 또는 환경 변수에서 로드되는지 확인하십시오.",,964B6489427B42AD93C00CD160F424D6,C4BAD16D-847F-47D1-9B09-1B4E8FC9C2E4,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Security Features,Password Management: Hardcoded Password,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",lambda(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/it/java/org/owasp/webgoat/CSRFIntegrationTest.java","CSRFIntegrationTest.java",212,"    params.clear();
    params.put(""username"", ""csrf-"" + this.getUser());
    params.put(""password"", ""password"");

    // login and get the new cookie",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",29FF9EC250A65E78FFAF022F815A1479,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Input Validation and Representation,SQL Injection,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",50,"  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
      return failed(this).feedback(""required4"").build();",login(1),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",63,"                  + username_login
                  + ""' and password = '""
                  + password_login
                  + ""'"");
      ResultSet resultSet = statement.executeQuery();","java.sql.Connection.prepareStatement()","Assignment5.java의 63 줄에서 login() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","Assignment5.java의 63 줄에서 login() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","SQL injection 오류는 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스에서 데이터가 프로그램에 입력됩니다.



2. 데이터를 사용하여 SQL 쿼리를 동적으로 생성합니다.



예제 1: 다음 코드는 지정된 이름과 일치하는 항목을 검색하는 SQL 쿼리를 동적으로 생성하고 실행합니다. 쿼리는 표시되는 항목을 항목 소유자가 현재 인증된 사용자의 이름과 일치하는 항목으로 제한합니다.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter(""itemName"");
	String query = ""SELECT * FROM items WHERE owner = '""
				+ userName + ""' AND itemname = '""
				+ itemName + ""'"";
	ResultSet rs = stmt.execute(query);
...


쿼리는 다음 코드를 실행하려고 합니다.


	SELECT * FROM items
	WHERE owner = <userName>
	AND itemname = <itemName>;


하지만 상수인 기본 쿼리 문자열과 사용자 입력 문자열을 연결하여 쿼리를 동적으로 생성하기 때문에, 쿼리는 itemName에 작은따옴표가 들어 있지 않은 경우에만 정확하게 동작합니다. 사용자 이름이 wiley인 공격자가 itemName에 문자열 ""name' OR 'a'='a""를 입력하면 쿼리는 다음과 같이 생성됩니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';


OR 'a'='a' 조건을 추가하면 where 절이 항상 true로 평가하기 때문에 쿼리는 훨씬 간단한 다음 쿼리와 논리적으로 동일하게 됩니다.


	SELECT * FROM items;


공격자는 이렇게 쿼리를 단순화하여 쿼리가 인증된 사용자가 소유한 항목만 반환해야 한다는 요구 사항을 무시할 수 있습니다. 이제 쿼리는 지정된 소유자와 관계없이 items 테이블에 저장된 모든 항목을 반환합니다.

예제 2: 이 예제는 Example 1에서 생성하여 수행한 쿼리에 또 다른 악성 값이 전달될 때의 결과를 검토합니다. 사용자 이름이 wiley인 공격자가 itemName에 문자열 ""name'; DELETE FROM items; --""를 입력하면 쿼리는 다음과 같은 두 개의 쿼리가 됩니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'


Microsoft(R) SQL Server 2000을 포함한 많은 데이터베이스 서버에서 여러 SQL 문을 세미콜론으로 구분하여 한꺼번에 실행하는 것을 허용합니다. 이 공격 문자열은 세미콜론으로 구분한 문에 대한 일괄 실행을 허용하지 않는 Oracle 및 기타 데이터베이스 서버에서는 오류를 일으키지만 일괄 실행을 허용하는 데이터베이스에서는 공격자가 이런 종류의 공격으로 데이터베이스에 대해 임의의 명령을 실행할 수 있습니다.

마지막의 하이픈 쌍(--)을 보겠습니다. 이는 대부분의 데이터베이스 서버에서 해당 문에 대한 나머지 부분을 주석으로 처리하여 실행하지 말라는 의미로 해석됩니다[4]. 이 경우, 이 주석 문자는 수정된 쿼리에서 마지막의 작은따옴표 한쪽을 제거하는 역할을 합니다. 주석을 이런 식으로 사용할 수 없는 데이터베이스에서도 Example 1에서 본 것과 유사한 속임수를 사용하면 대부분의 공격이 효과를 거둘 수 있습니다. 공격자가 문자열 ""name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a""를 입력하여 다음 세 가지 유효한 문을 만드는 경우입니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';


모바일 환경에서는 SQL Injection과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString(""itemName"");
        String query = ""SELECT * FROM items WHERE owner = '""
                                + userName + ""' AND itemname = '""
                                + itemName + ""'"";
        SQLiteDatabase db = this.openOrCreateDatabase(""DB"", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, null);
...


SQL Injection 공격을 방지하는 한 가지 기존의 접근 방식은 공격을 입력값 검증 문제로 처리하고 안전한 값 목록(허용 목록)의 문자만 받거나 악의적일 가능성이 있는 값 목록(거부 목록)을 식별하여 이스케이프 처리하는 것입니다. 허용 목록 검사는 엄격한 입력값 검증 규칙을 이행하는 매우 효율적인 수단이 되기도 하지만, 매개 변수가 있는 SQL 문은 유지 관리가 쉽고 보다 강력한 보안을 제공할 수 있습니다. 대부분의 경우 거부 목록 구현은 SQL Injection 공격 방지의 효과를 떨어뜨리는 허점이 아주 많습니다. 예를 들어, 공격자는 다음과 같이 할 수 있습니다.

- 따옴표로 묶지 않은 필드를 노립니다.
- 이스케이프 처리된 메타 문자를 사용할 필요가 없는 방법을 찾습니다.
- 저장 프로시저(Stored procedure)를 사용하여 삽입된 메타 문자를 숨깁니다.

SQL 쿼리에 입력할 때 수동으로 문자를 이스케이프 처리하는 방법도 있지만 이것으로 SQL injection 공격으로부터 응용 프로그램을 보호할 수는 없습니다.

SQL injection 공격을 다루는 데 주로 제시되는 다른 솔루션은 저장 프로시저(stored procedure)를 사용하는 것입니다. 저장 프로시저(Stored procedure)는 일부 유형의 SQL injection 공격은 막을 수 있지만 다른 많은 유형은 막지 못합니다. 저장 프로시저(Stored procedure)는 일반적으로 매개 변수에 전달되는 SQL 문의 유형을 제한하여 SQL injection 공격을 막습니다. 하지만 이 제약을 피할 수 있는 많은 방법이 있어 수많은 비정상적인 문을 저장 프로시저(Stored procedure)에 전달할 수 있습니다. 되풀이하지만, 저장 프로시저(Stored procedure)는 일부 익스플로이트는 막을 수 있지만 응용 프로그램을 SQL injection 공격에 대해 안전하게 보호할 수는 없습니다.","SQL injection 취약점의 원인은 공격자가 SQL 쿼리의 컨텍스트를 변경하여 프로그래머가 데이터로 해석되기를 바라는 값을 명령으로 해석되도록 만들 수 있다는 점입니다. SQL 쿼리를 생성할 때, 프로그래머는 무엇이 명령으로 해석되어야 하고 무엇이 데이터로 해석되어야 하는지 알고 있습니다. 매개 변수가 있는 SQL 문은 데이터 위주의 컨텍스트 변경을 허용하지 않고 거의 모든 SQL injection 공격을 방지하여 이를 이행합니다. 매개 변수가 있는 SQL 문은 일반 SQL 문자열을 사용하여 생성되지만, 사용자가 제공하는 데이터를 포함해야 하는 경우에 이후에 삽입되는 데이터의 자리 표시자인 바인딩 매개 변수를 포함합니다. 다시 말해, 바인딩 매개 변수를 사용하여 프로그래머가 명령으로 처리해야 할 것과 데이터로 처리해야 할 것을 데이터베이스에 명시적으로 지정할 수 있습니다. 프로그램이 문을 실행할 준비가 되면 각 바인딩 매개 변수에 사용할 런타임 값을 데이터베이스에 지정하여 데이터가 명령 수정 코드로 해석될 위험을 피할 수 있습니다.

사용자가 제공하는 문자열을 연결하는 대신 매개 변수가 있는 SQL 문을 사용하도록 다음과 같이 예제 1을 다시 작성할 수 있습니다.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter(""itemName"");
	String query = ""SELECT * FROM items WHERE itemname=? AND owner=?"";
	PreparedStatement stmt = conn.prepareStatement(query);
	stmt.setString(1, itemName);
	stmt.setString(2, userName);
	ResultSet results = stmt.execute();
...


Android에 해당하는 코드는 다음과 같습니다.


...
	PasswordAuthentication pa = authenticator.getPasswordAuthentication();
	String userName = pa.getUserName();
	String itemName = this.getIntent().getExtras().getString(""itemName"");
	String query = ""SELECT * FROM items WHERE itemname=? AND owner=?"";
	SQLiteDatabase db = this.openOrCreateDatabase(""DB"", MODE_PRIVATE, null);
	Cursor c = db.rawQuery(query, new Object[]{itemName, userName});
...


흔히 보고서 생성 코드에서 볼 수 있는 복잡한 시나리오에서는 WHERE 절의 동적 제약 조건 추가와 같이, 사용자 입력이 SQL 문의 구조를 결정합니다. 그렇다고 이 요구 사항이 사용자 입력을 연결하여 쿼리 문자열을 만드는 것을 정당화할 수는 없습니다. 사용자 입력이 명령 구조에 영향을 미쳐야 하는 경우 간접 참조를 사용하여 SQL injection 공격을 예방합니다. 즉, SQL 문에 포함시킬 여러 요소에 해당하는 유효한 문자열 집합을 만듭니다. 문을 만들 때 사용자 입력을 사용하여 이 응용 프로그램 제어 값 집합에서 값을 선택합니다.","1. 이 때, 흔히 저지르는 실수는 사용자가 제어하는 문자열을 연결하여 생성한, 매개 변수가 있는 SQL 문을 사용하는 것입니다. 물론 이렇게 하면 매개 변수가 있는 SQL 문을 사용하는 목적이 무산됩니다. 매개 변수가 있는 SQL 문을 형성하는 문자열이 응용 프로그램에서 제어하는 상수인지 확신할 수 없는 경우, 문자열이 SQL 문자열로 직접 실행되지 않기 때문에 안전하다고 가정할 수 없습니다. SQL 문에서 사용자 제어 문자열의 모든 사용을 철저하게 조사하고 쿼리의 의미를 수정하는 데 사용되는 일이 없는지 확인해야 합니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.

3. SQL Injection 문제는 데이터 흐름 수정 작업 후에도 계속해서 보고될 수 있습니다(우선 순위 값은 감소). Fortify Static Code Analyzer에서 사용자 제어 입력이 SQL 문 구성에 사용되고 있다는 분명한 데이터 흐름 증거가 발견되면 높음/심각 우선 순위의 데이터 흐름 문제가 보고됩니다. Fortify Static Code Analyzer에서 데이터 소스를 결정할 수 없고 소스가 동적으로 변경될 수 있는 경우 낮음/중간 우선 순위의 의미 체계 문제가 보고됩니다. 이 전략은 SQL Injection과 같이 악용의 잠재적 영향이 거짓 긍정 문제를 감사하는 불편함보다 큰 일부 취약성 범주에 채택되었습니다.",335B38300BD8C08EC7CA2C4E1343A7B0,5870A527-08AF-452C-84B2-7F6C360CA7EF,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Security Features,Insecure Randomness,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",50,"  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
      return failed(this).feedback(""required4"").build();",login(1),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge1/ImageServlet.java","ImageServlet.java",17,"public class ImageServlet {

  public static final int PINCODE = new Random().nextInt(10000);

  @RequestMapping(",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","Insecure Randomness 오류는 보안이 중요한 상황에서 예측 가능한 값을 생성할 수 있는 함수를 난수 발생원으로 사용할 때 발생합니다.

컴퓨터는 결정론을 사용하는 시스템이기 때문에 진정한 무작위성을 구현할 수 없습니다. PRNG(의사 난수 발생기)는 시드로부터 이후의 값을 계산하는 알고리즘을 사용하여 무작위성에 최대한 접근합니다.

PRNG는 두 가지 종류가 있는데 통계적 PRNG 및 암호화 PRNG입니다. 통계적 PRNG는 유용한 통계적 속성을 제공하지만 출력을 쉽게 예측할 수 있고 재생하기 쉬운 숫자 스트림을 만들기 때문에 보안이 예측할 수 없는 값을 생성하는 방식에 의존하는 경우 사용하기 부적합합니다. 암호화 PRNG는 예측하기 어려운 출력을 생성하여 이 문제를 해결합니다. 암호화 값이 안전하려면 공격자가 생성된 무작위 값과 실제적인 무작위 값을 구분하는 것이 불가능하거나 아주 어려워야 합니다. 일반적으로 PRNG 알고리즘이 안전한 암호화로 알려져 있지 않은 경우에는 통계적 PRNG를 가리키는 것일 수 있는데, 이 PRNG는 보안이 중요한 상황일 때 사용해서는 안 됩니다. 이 경우 통계적 PRNG를 사용하면 추측하기 쉬운 임시 암호, 예측 가능한 암호화 키, 세션 하이재킹, DNS 스푸핑 등의 심각한 취약점을 유발할 수 있습니다.

예제: 다음 코드는 통계적 PRNG를 사용하여 구입 후 일정 기간 동안 활성 상태를 유지하는 영수증의 URL을 작성합니다.


String GenerateReceiptURL(String baseUrl) {
    Random ranGen = new Random();
    ranGen.setSeed((new Date()).getTime());
    return (baseUrl + ranGen.nextInt(400000000) + "".html"");
}


이 코드는 Random.nextInt() 함수를 사용하여 생성되는 영수증 페이지에 대한 ""고유한"" ID를 생성합니다. Random.nextInt()은 통계적 PRNG이므로 생성되는 문자열을 공격자가 쉽게 추축할 수 있습니다. 영수증 시스템의 기본 설계에도 오류가 있지만 암호화 PRNG와 같이 예측 가능한 영수증 ID를 생성하지 않는 난수 발생기를 사용했다면 훨씬 안전했을 것입니다.","가장 보안이 민감한 사안에 무작위성을 적용하는 것처럼, 예측 불가능성이 필수적일 때 암호화 PRNG를 사용합니다. 선택한 PRNG에 관계없이 항상 알고리즘의 시드를 생성하기에 충분한 엔트로피가 있는 값을 사용합니다. (현재 시간과 같은 값은 미미한 엔트로피 수준만 제공하므로 사용하지 마십시오.)

Java 언어는 java.security.SecureRandom에 암호화 PRNG를 제공합니다. java.security의 다른 알고리즘 기반 클래스와 마찬가지로 SecureRandom도 특정 알고리즘 집합에 구현과 관계 없는 래퍼를 제공합니다. SecureRandom.getInstance()를 사용하여 SecureRandom 개체의 인스턴스를 요청함으로써 알고리즘의 특정 구현을 요청할 수 있습니다. 알고리즘을 사용할 수 있는 경우 알고리즘은 SecureRandom 개체로 제공됩니다. 알고리즘을 사용할 수 없거나 특정 구현을 지정하지 않은 경우, 시스템이 선택한 SecureRandom 구현이 제공됩니다. 

Sun은 SHA1PRNG라는 Java 배포판을 사용하여 단일 SecureRandom 구현을 제공하는데 그 계산 과정을 다음과 같이 설명합니다.

""매 연산마다 1씩 증가하는 64비트 카운터와 연결된 실제 무작위 시드 값에 대해 SHA-1 해시를 계산합니다. 160비트 SHA-1 출력부터 64비트만 사용됩니다[1]."" 

하지만 Sun의 SHA1PRNG 알고리즘 구현에 대한 구체적인 내용은 상세하게 설명되어 있지 않고 구현에 사용한 엔트로피 소스가 불확실하며, 따라서 출력의 실제 무작위성이 어떤 수준인지도 불확실합니다. 웹 상에 Sun 구현에 대한 추측이 난무하지만 알고리즘의 암호화가 강력하고 보안에 민감한 상황에서 안전하게 사용할 수 있다는 주장을 반박할 만한 증거는 없습니다.",,DAC4D23B147E71AA4BE012918D1DA902,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Input Validation and Representation,Open Redirect,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",90,"    }
    try {
      var id = request.getParameter(""id"");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");","jakarta.servlet.ServletRequest.getParameter()","Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",102,"        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
            .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
            .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
      }","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java 파일은 102 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 102 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",C0D6B66EED312C47C976F1FD7D5DFDEB,6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Time and State,Race Condition,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",90,"    }
    try {
      var id = request.getParameter(""id"");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");","jakarta.servlet.ServletRequest.getParameter()","Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/webgoat/static/js/libs/ace.js","ace.js",2776,"    };
    
    host.on(""beforeEndOperation"", function() {
        if (host.curOp && host.curOp.command.name == ""insertstring"")
            return;",FunctionPointerCall: on(),"ace.js의 2776 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.","ace.js의 2776 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.","개발자는 Node.js를 사용하여 IO 차단 이벤트에 콜백을 할당할 수 있습니다. 콜백은 비동기로 실행되므로 기본 응용 프로그램이 IO에 의해 차단되지 않기 때문에 이렇게 하면 성능이 개선됩니다. 그러나 콜백 외부의 항목을 실행하려면 콜백 내의 코드가 먼저 실행되어야 하는 경우에는 race condition이 발생할 수 있습니다. 

예제 1: 다음 코드에서는 authentication을 위해 데이터베이스를 기준으로 사용자를 확인합니다.

 
...
var authenticated = true; 
...
database_connect.query('SELECT * FROM users WHERE name == ? AND password = ? LIMIT 1', userNameFromUser, passwordFromUser, function(err, results){
  if (!err && results.length > 0){
    authenticated = true;
  }else{
    authenticated = false;
  }
});

if (authenticated){
  //do something privileged stuff
  authenticatedActions();
}else{
  sendUnathenticatedMessage();
}


이 예제에서는 로그인용 사용자 자격 증명을 확인하기 위해 백엔드 데이터베이스를 호출하며, 자격 증명이 확인되면 변수를 true로 설정하고 확인되지 않으면 false로 설정합니다. 하지만 콜백은 IO에 의해 차단되므로 비동기로 실행되며 if (authenticated) 확인 후에 실행될 수 있습니다. 기본값은 true이기 때문에 사용자가 실제로 인증되었는지 여부와 관계없이 if 문이 실행됩니다.","Node.js 응용 프로그램을 만들 때는 IO 차단 이벤트와 관련 콜백이 수행하는 기능을 철저하게 확인해야 합니다. 일련의 콜백을 특정 순서로 호출해야 할 수도 있고 특정 콜백이 실행되어야 접근 가능한 코드도 있기 때문입니다.

예제 2: 다음 코드는 Example 1의 race condition을 해결합니다.


...
database_connect.query('SELECT * FROM users WHERE name == ? AND password = ? LIMIT 1', userNameFromUser, passwordFromUser, function(err, results){
  if (!err && results.length > 0){
    // do privileged stuff
    authenticatedActions();
  }else{
    sendUnauthenticatedMessage();
  }
});
...


이 코드는 간단한 예제이며 실제 시나리오는 훨씬 더 복잡할 수 있기 때문에 해당 상황을 해결하려면 코드베이스를 보다 광범위하게 리팩터링해야 할 수도 있습니다. 이러한 문제를 해결할 수 있는 간단한 방법은 promises를 활용하는 API를 사용하는 것입니다. 이러한 API는 비동기 작업의 최종 결과를 나타내며, 성공 시의 콜백과 실패 시의 콜백을 각각 지정할 수 있기 때문입니다. 이 코드를 자주 사용해야 하는 경우에는 authentication에 대해 promise를 반환하는 API를 만드는 것이 좋습니다. 그러면 개발자가 작성해야 하는 코드를 다음과 같이 간소화할 수 있습니다.


promiseAuthentication()
.then(authenticatedActions, sendUnauthenticatedMessage);


이 경우 코드는 항상 명확하게 정의된 순서로 실행되므로 코드를 보다 쉽게 파악하고 race condition을 방지할 수 있습니다.",,164D7609B14457235788ACCB474E0C90,632C0055-B853-4E37-B49F-720C6448B1C7,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Security Features,Privacy Violation,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }",Read password(),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",56,"      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }
    return ""Authorization: Basic "".concat(basicAuth);
  }
",Return(),"EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","Privacy violation은 다음 경우에 발생합니다.

1. 사용자 개인 정보가 프로그램에 입력됩니다.

2. 데이터는 콘솔, file system 또는 네트워크와 같은 외부 위치에 작성됩니다.


예제 1: 다음 코드에는 데이터베이스에 추가되는 레코드를 로그 파일의 콘텐트에 저장하여 추적하는 로깅 명령문이 있습니다.


pass = getPassword();
...
dbmsLog.println(id+"":""+pass+"":""+type+"":""+tstamp);


Example 1의 코드는 일반 텍스트 암호를 파일 시스템에 기록합니다. 많은 개발자가 파일 시스템을 안전한 데이터 저장소로 신뢰하지만 무조건 신뢰해서는 안 됩니다. 특히 개인 정보가 관련된 경우가 대표적입니다.

개인 정보는 다음의 두 가지 이유 때문에 모바일 환경에서 크게 대두되는 문제 중 하나입니다. 그중 하나는 장치 분실 가능성이 훨씬 더 높다는 점이고, 다른 하나는 모바일 응용 프로그램 사이에서 프로세스 간 통신이 이뤄진다는 점입니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다. 모바일 응용 프로그램 사이에 진행되는 프로세스 간 통신에 민감한 정보를 포함해서는 안 됩니다.

예제 2: 다음 코드는 Android WebView 저장소에서 지정된 사이트의 사용자 이름과 암호를 읽은 다음 등록된 모든 수신자에게 브로드캐스트합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction(""SEND_CREDENTIALS"");
    i.putExtra(""username"", username);
    i.putExtra(""password"", password);
    view.getContext().sendBroadcast(i);
  }
});
...


이 예는 몇 가지 문제를 보여줍니다. 첫째, WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 사용자가 루팅된 장치나 에뮬레이터를 사용하는 경우 지정된 사이트에 저장된 암호를 읽을 수 있습니다. 둘째, 일반 텍스트 자격 증명은 등록된 모든 수신자에게 브로드캐스트되어 SEND_CREDENTIALS 작업을 통해 인텐트를 수신 대기하도록 등록된 모든 수신자가 메시지를 수신합니다. 이 경우 수정 방법으로 권한을 사용하지 않는 것이 좋지만, 브로드캐스트는 수신자 수를 제한하는 권한으로도 보호되지 않습니다.

개인 정보는 다음과 같은 다양한 방식으로 프로그램에 입력됩니다.

- 암호 또는 개인 정보의 형태로 사용자가 직접 입력

- 응용 프로그램이 데이터베이스 또는 기타 데이터 저장소에서 접근

- 협력업체 또는 타사를 통해 간접적으로

일반적으로 모바일 환경에서 이 개인 정보는 암호, SSN 및 기타 일반 개인 정보에 따라 다음 사항을 포함합니다.

- 위치

- 휴대폰 번호

- 일련번호 및 장치 ID

- 네트워크 연산자 정보

- 보이스메일 정보


개인 정보로 명명되지 않은 데이터도 상황에 따라 개인 정보로 해석될 수 있습니다. 예를 들어, 학생 ID 번호는 명시적이고 공개적으로 각 학생의 개인 정보에 매핑되지 않기 때문에 보통 개인 정보로 간주하지 않습니다. 하지만 학교에서 학생의 주민 등록 번호를 기반으로 ID 번호를 생성하는 경우 ID 번호는 개인 정보로 간주해야 합니다.

보안 및 개인 정보 문제는 서로 상충하는 것처럼 보일 때가 있습니다. 보안 관점에서 보면 이후에 비정상적인 활동을 식별할 수 있도록 모든 중요한 작업을 기록해야 합니다. 하지만 개인 정보가 관련된 경우 이 방법은 위험이 따릅니다.

개인 정보를 위험하게 처리하는 방법은 여러 가지가 있겠지만 공통적인 위험은 잘못된 신뢰에서 비롯됩니다. 프로그래머는 프로그램이 실행되는 운영 환경을 신뢰하기 때문에 개인 정보를 파일 시스템, 레지스트리 또는 기타 로컬로 제어되는 리소스에 저장해도 무방하다고 생각합니다. 하지만 특정 리소스에 대한 액세스가 제한되어 있는 경우에도 액세스 권한을 가진 개인을 신뢰할 수 있다고 보장할 수 없습니다. 일례로, 2004년, AOL의 한 비양심적인 직원이 해외 도박 웹 사이트를 대상으로 영업하는 스패머에게 약 9천 2백만 개의 고객 전자 메일 주소를 팔았습니다[1].

이런 대형 익스플로이트 사건에 대응하여 개인 정보 수집 및 관리에 대한 규제가 점점 엄격해지고 있습니다. 조직의 위치, 업종 및 취급하는 개인 정보의 속성에 따라 조직은 다음의 연방 정부 및 주 정부의 규제를 하나 이상 준수할 의무가 있습니다.

- 세이프 하버 협정(Safe Harbor Privacy Framework)[3]

- GLBA(Gramm-Leach Bliley Act)[4]

- HIPAA(Health Insurance Portability and Accountability Act)[5]

- California SB-1386 [6]

이런 규제에도 불구하고 privacy violation은 우려할 만한 빈도로 계속 발생하고 있습니다.","보안과 개인 정보가 충돌할 경우, 보통 개인 정보에 더 높은 우선 순위를 부여해야 합니다. 이를 따르면서 필요한 보안 정보도 유지하기 위해 프로그램을 종료하기 전에 모든 개인 정보를 정리(cleanse)합니다.

훌륭한 개인 정보 관리를 위해서는 내부 개인 정보 지침을 작성하여 엄격하게 준수해야 합니다. 지침에는 응용 프로그램이 개인 정보 데이터를 처리하는 방식을 구체적으로 기술해야 합니다. 조직이 연방법 또는 주법에 따라 규제를 받는 경우, 개인 정보 지침이 법적 요구 사항을 만족하도록 합니다. 조직이 규제를 받지 않는 경우에도 개인 정보를 보호해야 합니다. 그렇지 않으면 고객의 신뢰를 잃을 위험이 있습니다.

개인 정보에 관한 최선의 정책은 노출을 최소화하는 것입니다. 업무 수행에 반드시 필요한 경우를 제외하고 응용 프로그램, 프로세스 및 직원에게 개인 정보에 대한 접근 권한을 부여해서는 안 됩니다. 필요 이상의 권한으로 작업을 수행할 수 없다는 최소 권한 원칙과 함께 개인 정보에 대한 접근을 최소한의 그룹으로 제한하는 것이 좋습니다.

모바일 응용 프로그램이 장치에서 실행되는 다른 응용 프로그램에 민감한 데이터를 전달하지 않도록 합니다. 개인 정보를 저장해야 하는 경우에는 항상 암호화해야 합니다. Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 따라서 암호화된 데이터베이스에 자격 증명을 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.

예제 4: 다음 코드는 Android WebView 저장소에서 지정된 사이트의 사용자 이름과 암호를 읽은 다음 이를 등록된 모든 수신자로 브로드캐스트하는 대신, 동일한 응용 프로그램 내의 다른 부분만 브로드캐스트를 볼 수 있도록 내부적으로만 브로드캐스트합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction(""SEND_CREDENTIALS"");
    i.putExtra(""username"", username);
    i.putExtra(""password"", password);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
  }
});
...
","1. Privacy Violation에 대비한 철저한 감사의 일환으로 사용자 지정 규칙을 작성하여 프로그램에 입력되는 개인 정보 또는 기타 민감한 정보의 모든 출처를 식별하도록 합니다. 개인 정보 출처 대부분은 자동으로 식별할 수 없습니다. 사용자 지정 규칙이 없으면 privacy violation 검사는 상당히 불완전할 것입니다.

2. Fortify Java Annotations FortifyPassword, FortifyNotPassword, FortifyPrivate 및 FortifyNotPrivate를 사용하여 암호 및 개인 정보를 나타내는 필드 및 변수를 표시할 수 있습니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",327A61D07BCA5E76E2F8918566E8F496,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Code Quality,Unreleased Resource: Streams,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }",Read password(),"Downloads/WebGoat-2023.5/WebGoat-2023.5/.mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",112,"        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();","fos.getChannel()","MavenWrapperDownloader.java의 downloadFileFromURL() 함수는 111 줄의 FileOutputStream()에 의해 할당된 시스템 리소스를 해제하지 못할 수도 있습니다.","MavenWrapperDownloader.java의 downloadFileFromURL() 함수는 111 줄의 FileOutputStream()에 의해 할당된 시스템 리소스를 해제하지 못할 수도 있습니다.","프로그램이 시스템 리소스를 해제하지 못할 수도 있습니다.

리소스 누출은 최소한 두 가지 공통 원인이 있습니다.

- 오류 조건 및 기타 예외 상황.

- 프로그램의 어떤 부분이 리소스 해제를 담당하고 있는지에 대한 혼란

대부분의 공개되지 않은 리소스 문제는 일반적인 소프트웨어 안정성 문제를 일으킵니다. 하지만 공격자가 의도적으로 리소스 누출을 일으킬 수 있는 경우 공격자가 리소스 풀을 고갈시켜 DoS(Denial of Service) 공격을 실행할 수도 있습니다.

예제: 다음 메서드는 자신이 연 파일 핸들을 닫지 않습니다. FileInputStream의 finalize() 메서드는 결국 close()를 호출하지만 finalize() 메서드를 호출하기까지 시간이 얼마나 걸릴지 장담할 수 없습니다. 사용량이 많은 환경에서는 이로 인해 JVM이 파일 핸들을 모두 소진시키는 결과를 초래할 수도 있습니다.

private void processFile(String fName) throws FileNotFoundException, IOException {
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
","1. 리소스를 다시 확보하는 데 finalize()를 사용하지 마십시오. 개체의 finalize() 메서드를 호출하려면 가비지 수집기(garbage collector)는 개체가 가비지 수집 대상인지 판단해야 합니다. 가비지 수집기(garbage collector)는 JVM이 메모리가 부족한 경우를 제외하고는 실행할 필요가 없기 때문에 finalize() 메서드가 필요할 때 원하는 대로 호출된다는 보장이 없습니다. 또한 결국 가비지 수집기(garbage collector)가 실행되더라도 짧은 시간에 방대한 리소스를 다시 확보하기 때문에 성능이 ""고르지 못하고"" 전반적인 시스템 처리량이 낮아질 수 있습니다. 이런 효과는 시스템의 부하가 증가할수록 더욱 두드러집니다.

마지막으로 리소스 확보 작업이 응답하지 않도록 할 수 있으면(예: 네트워크로 데이터베이스와 통신해야 하는 경우), finalize() 메서드를 실행하고 있는 스레드도 응답하지 않습니다.

2. finally 블록의 리소스를 해제하십시오. 예제 코드는 다음과 같이 다시 작성해야 합니다.


public void processFile(String fName) throws FileNotFoundException, IOException {
  FileInputStream fis;
  try {
    fis = new FileInputStream(fName);
    int sz;
    byte[] byteArray = new byte[BLOCK_SIZE];
    while ((sz = fis.read(byteArray)) != -1) {
      processBytes(byteArray, sz);
    }
  }
  finally {
    if (fis != null) {
      safeClose(fis);
    }
  }
}

public static void safeClose(FileInputStream fis) {
  if (fis != null) {
    try {
      fis.close();
    } catch (IOException e) {
      log(e);
    }
  }
}


이 해결책은 도우미 함수를 사용하여 스트림을 닫으려고 할 때 발생할 수 있는 예외를 기록합니다. 이 도우미 함수는 스트림을 닫아야 할 때마다 재사용됩니다.

또한 processFile 메서드는 fis 개체를 null로 초기화하지 않습니다. 대신 safeClose()를 호출하기 전에 fis가 null이 아닌지 검사합니다. null 검사를 하지 않으면 Java 컴파일러는 fis가 초기화되지 않았다고 보고합니다. 이 방법은 uninitialized variable을 발견하는 Java 기능을 이용한 것입니다. fis를 더 복잡한 방법을 사용하여 null로 초기화하면 초기화하지 않고 fis를 사용하는 경우를 컴파일러가 발견할 수 없습니다.",,126879C79E72DAEA161B955EFC3ECCED,74714BFC-EDF7-445B-8672-0996214D5845,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Security Features,Key Management: Hardcoded Encryption Key,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }",Read password(),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",45,"
  public static String getPrivateKeyInPEM(KeyPair keyPair) {
    String encodedString = ""-----BEGIN PRIVATE KEY-----\n"";
    encodedString =
        encodedString","fos.getChannel()","하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.","하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.","암호화 키를 하드코딩하면 프로젝트의 모든 개발자가 암호화 키를 볼 수 있고 문제를 수정하기가 매우 어렵기 때문에 하드코딩하지 마십시오. 코드가 운영 단계로 들어간 후 암호화 키를 변경하려면 소프트웨어 패치가 필요합니다. 암호화 키로 보호되는 계정이 손상되면 조직은 보안과 시스템 가용성 중 한 가지를 선택할 수밖에 없습니다.


예제 1: 다음 예제는 .pem 파일 내의 암호화 키를 보여줍니다.


...
-----BEGIN RSA PRIVATE KEY-----
MIICXwIBAAKBgQCtVacMo+w+TFOm0p8MlBWvwXtVRpF28V+o0RNPx5x/1TJTlKEl
...
DiJPJY2LNBQ7jS685mb6650JdvH8uQl6oeJ/aUmq63o2zOw=
-----END RSA PRIVATE KEY-----
...


코드에 접근할 수 있는 누구든 암호화 키를 볼 수 있습니다. 응용 프로그램을 공개한 후에는 프로그램에 패치를 적용하지 않고는 암호화 키를 변경할 방법이 없습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 응용 프로그램 실행 파일에 액세스할 수 있는 모든 공격자는 암호화 키 값을 추출할 수 있습니다.","소스 제어 시스템에 암호화 키를 체크인하거나 하드코드하지 마십시오. 항상 암호화 키를 난독화하고 외부 소스에서 관리하십시오. 시스템의 임의의 장소에 암호화 키를 일반 텍스트로 저장하는 경우 충분한 권한이 있는 사용자라면 누구나 암호화 키를 읽어 남용할 가능성이 있습니다.",,D82BB8C3FE651E8C9433DAC433992D66,6DBD0F5A-99EB-53B7-AB1E-D9B012E68020,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Environment,Password Management: Password in Configuration File,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }",Read password(),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/i18n/messages.properties","messages.properties",34,"InvalidData=Invalid Data
Go!=Go!
password=Password
password.confirm=Confirm password
username=Username",password(),"구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.","구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.","일반 텍스트 암호를 구성 파일에 저장하면 파일을 읽을 수 있는 사용자는 누구나 암호로 보호되는 리소스 접근이 허용됩니다. 때때로 개발자가 구성에 대한 접근 권한이 있는 사람에게서 응용 프로그램을 방어할 수 없다고 생각하는 경우가 있는데 이런 태도가 공격자에게 유리하게 작용합니다. 좋은 암호 관리 지침에 따르면 암호를 일반 텍스트로 저장하지 않아야 합니다.

","암호를 일반 텍스트로 저장해서는 안 됩니다. 시스템이 시작될 때 관리자에게 암호를 입력하도록 요구해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다.

일부 타사 제품에 보다 안전한 방법으로 암호를 관리하는 기능이 있다고 합니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 보안 솔루션의 경우 현실성 있는 유일한 옵션은 독점적 솔루션을 사용하는 것입니다.","1. Fortify Static Code Analyzer는 구성 파일에서 암호 속성에 사용되는 일반 이름을 검색합니다. 플래그가 지정된 항목이 암호로 사용되고 있고 암호 항목에 일반 텍스트가 포함되어 있는지 확인하여 이러한 문제를 감사하십시오.

2. 구성 파일의 항목이 기본 암호인 경우 이를 변경해야 할 뿐 아니라 구성 파일에서 난독 처리해야 합니다.",668C351ACC6D2190863E12F66A0CB9CA,29C589A2-3796-4486-A12D-BCE05ADFFE11,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Security Features,Privacy Violation: Autocomplete,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }",Read password(),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/resources/lessons/hijacksession/templates/hijackform.html","hijackform.html",16,"					<div class=""form-group input-group"">
						<span class=""input-group-addon""><i
							class=""glyphicon glyphicon-lock""></i></span> <input class=""form-control""
							placeholder=""Password"" name=""password"" type=""password"" />
					</div>",password(),"hijackform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","hijackform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,8E778A7762E99826CA67E0A83B2E4C25,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,API Abuse,Mass Assignment: Insecure Binder Configuration,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute(""basicAuth"", basicAuth);
    }",Read password(),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/idor/IDOREditOtherProfile.java","IDOREditOtherProfile.java",55,"  @PutMapping(path = ""/IDOR/profile/{userId}"", consumes = ""application/json"")
  @ResponseBody
  public AttackResult completed(
      @PathVariable(""userId"") String userId, @RequestBody UserProfile userSubmittedProfile) {
",Function: completed(),"모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.","모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.","개발을 쉽게 하고 생산성을 증가할 수 있도록, 대부분의 현대적 프레임워크에서는 개체가 바인딩할 클래스 속성과 이름이 일치하는 HTTP 요청 매개 변수로 자동 인스턴스화되고 채워질수 있도록 합니다. 개체의 자동 인스턴스화 및 채우기는 개발 속도를 높이지만 아무런 주의 없이 구현되는 경우 심각한 문제가 발생할 수 있습니다. 바운드 클래스 또는 중첩된 클래스의 모든 속성은 HTTP 요청 매개 변수로 자동 바인딩됩니다. 따라서 악의적인 사용자는 웹 폼 또는 API 계약을 통해 클라이언트에 노출되지 않더라도 바운드 또는 중첩된 클래스에 있는 모든 속성에 값을 할당할 수 있습니다.

예제 1: 다음 컨트롤러 메서드는 추가 구성 없이 Spring MVC를 사용하여 User 또는 Details 클래스에서 모든 속성으로 HTTP 요청 매개 변수를 바인딩합니다.


@RequestMapping(method = RequestMethod.POST)
public String registerUser(@ModelAttribute(""user"") User user, BindingResult result, SessionStatus status) {
  if (db.save(user).hasErrors()) {
    return ""CustomerForm"";
  } else {
    status.setComplete();
    return ""CustomerSuccess"";
  }
}


User 클래스는 다음과 같이 정의됩니다.


public class User {
  private String name;
  private String lastname;
  private int age;
  private Details details;

  // Public Getters and Setters
  ...
}


Details 클래스는 다음과 같이 정의됩니다.


public class Details {
  private boolean is_admin;
  private int id;
  private Date login_date;

  // Public Getters and Setters
  ...
}
","자동 모델 바인딩 기능을 제공하는 프레임워크를 사용하는 경우 모델 개체에 바인딩할 속성을 제어하여 공격자가 모델 또는 중첩된 클래스의 다른 비노출 속성을 식별할 수 있더라도 HTTP 요청 매개 변수에서 임의 값을 바인딩할 수 없게 하는 것이 모범 사례입니다.

사용되는 프레임워크에 따라 모델 바인딩 프로세스 제어에는 다양한 방법이 있습니다.

Spring MVC: 

바인딩 프로세스에서 사용할 HTTP 요청 매개 변수와 무시할 매개 변수를 제어할 수 있습니다.

@ModelAttribute 주석이 추가된 매개 변수를 사용하는 Spring MVC 응용 프로그램에서 바인딩할 속성을 제어하도록 바인더를 구성할 수 있습니다. 이를 위해 프레임워크가 Spring Model Binder에 참조를 삽입하도록 메서드에 @InitBinder로 주석을 추가할 수 있습니다. Spring Model Binder는 setAllowedFields 및 setDisallowedFields 메서드로 속성 바인딩 프로세스를 제어하도록 구성할 수 있습니다. BaseCommandController를 확장하는 Spring MVC 응용 프로그램은 Spring Model Binder로 참조를 가져오기 위해 initBinder(HttpServletRequest request, ServletRequestDataBinder binder) 메서드를 오버라이드할 수 있습니다.

예제 2: Spring Model Binder(3.x)가 민감한 속성의 바인딩을 허용하지 않도록 구성되어 있습니다.


final String[] DISALLOWED_FIELDS = new String[]{""details.role"", ""details.age"", ""is_admin""};

@InitBinder
public void initBinder(WebDataBinder binder) {
    binder.setDisallowedFields(DISALLOWED_FIELDS);
}


예제 3: Spring Model Binder(2.x)가 민감한 속성의 바인딩을 허용하지 않도록 구성되어 있습니다.


@Override
protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {
    binder.setDisallowedFields(new String[]{""details.role"", ""details.age"", ""is_admin""});
}


@RequestBody 주석이 추가된 매개 변수를 사용하는 Spring MVC 응용 프로그램에서 바인딩 프로세스는 HttpMessageConverter 인스턴스에 의해 처리됩니다. 해당 인스턴스는 Jackson 및 JAXB와 같은 라이브러리를 사용하여 HTTP 요청 본문을 Java 개체로 변환합니다. 이러한 라이브러리는 주석을 제공하여 허용되어야 하거나 허용되지 않아야 하는 필드를 제어합니다. 예를 들어, Jackson JSON 라이브러리의 경우 @JsonIgnore 주석을 사용하여 필드가 요청에 바인딩되는 것을 방지할 수 있습니다.

예제 4: 컨트롤러 메서드는 @RequestBody 주석을 사용하여 HTTP 요청을 Employee 클래스의 인스턴스에 바인딩합니다.


    @RequestMapping(value=""/add/employee"", method=RequestMethod.POST, consumes=""text/html"")
    public void addEmployee(@RequestBody Employee employee){
        // Do something with the employee object.
    }


응용 프로그램은 기본 Jackson HttpMessageConverter를 사용하여 JSON HTTP 요청을 Employee 클래스에 바인딩합니다. is_admin 민감한 필드의 바인딩을 방지하려면 @JsonIgnore 주석을 사용하십시오.


public class Employee {

  @JsonIgnore
  private boolean is_admin;
  ...

  // Public Getters and Setters
  ...
}


참고: Jackson 및 JAXB 주석을 구성하는 방법에 대한 자세한 내용은 다음 REST 프레임워크 정보를 확인하십시오.

Apache Struts: 

Struts 1 및 2는 관련 공용 세터 접근자가 있는 Actions 또는 ActionForms 속성에만 HTTP 요청 매개 변수를 바인딩합니다. 속성을 해당 요청에 바인딩해서는 안 되는 경우 세터를 비공개로 설정해야 합니다.

예제 5: Struts 프레임워크가 HTTP 요청 매개 변수를 자동으로 바인딩하지 않도록 비공개 세터를 구성합니다.


private String role;
private void setRole(String role)  {
   this.role = role;
}


REST 프레임워크: 

대부분의 REST 프레임워크는 콘텐트 유형이 JSON 또는 XML인 모든 HTTP 요청 본문을 모델 개체에 자동으로 바인딩합니다. JSON 및 XML 프로세싱에 사용되는 라이브러리에 따라 바인딩 프로세스 제어에 다양한 방법이 있습니다. 다음은 JAXB(XML) 및 Jackson(JSON)의 몇 가지 예입니다.

예제 6: Oracle의 JAXB 라이브러리를 사용하는 XML 문서에서 바인딩한 모델은 @XmlAccessorType, @XmlAttribute, @XmlElement 및 @XmlTransient 등의 다양한 주석을 사용하여 바인딩 프로세스를 제어할 수 있습니다. 바인더는 XmlAccessType.NONE 값이 포함된 @XmlAccessorType 주석을 사용한 모델에 주석을 달고 @XmlAttribute 및 @XmlElement 주석을 사용하여 바인딩해야 하는 필드를 선택하여 기본적으로 모든 속성을 바인딩하지 않습니다.


@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class User {
    private String role;
    private String name;
    @XmlAttribute
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }


예제 7: Jackson 라이브러리를 사용하는 JSON 문서에서 바인딩한 모델은 @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType 및 @JsonInclude 등의 다양한 주석을 사용하여 바인딩 프로세스를 제어할 수 있습니다. 바인더는 @JsonIgnore 주석으로 주석을 달아 특정 속성을 무시할 수 있습니다.


public class User {

    @JsonIgnore
    private String role;
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }


대량 할당 취약점을 방지하기 위한 다른 접근법은 HTTP 요청 매개 변수가 DTO 개체에 바운딩된 레이어 아키텍처를 사용하는 것입니다. DTO 개체는 해당 목적으로만 사용되며 웹 폼 또는 API 계약에 정의된 속성만 노출하고 나머지 비공개 속성을 정의할 수 있는 도메인 개체에 이러한 DTO 개체를 매핑합니다.","1. 이 취약점 범주는 문제를 정확하게 발견하기 위해서는 정적 분석의 기능을 넘어서는 응용 프로그램 아키텍처의 이해를 요구하므로 설계 결함으로 분류할 수 있습니다. 따라서 응용 프로그램이 HTTP 요청 바인딩에 특정 DTO 개체를 사용하도록 설계된 경우 속성을 배제하기 위해 바인더를 구성할 필요가 없을 수 있습니다.",0DB73467214500201BE9DFDD25C27D9D,66F1C785-3EDF-4CF2-9217-3275D7BC5DB7,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Input Validation and Representation,XML External Entity Injection,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",62,"  public AttackResult createNewUser(
      HttpServletRequest request,
      @RequestBody String commentStr,
      @RequestHeader(""Content-Type"") String contentType) {
    AttackResult attackResult = failed(this).build();",createNewUser(1),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",105,"    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:105에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","CommentsCache.java:105에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","XML 외부 엔터티 공격에서는 XML 기능을 활용하여 처리 시점에 동적으로 문서를 구성합니다. XML 엔터티를 사용하면 지정된 리소스에서 동적으로 데이터를 포함시킬 수 있습니다. 외부 엔터티를 사용하면 XML 문서에 외부 URI의 데이터를 포함할 수 있습니다. 다른 방식으로 처리하도록 구성하지 않은 경우 외부 엔터티는 XML 파서가 URI로 지정된 리소스(예: 로컬 컴퓨터 또는 원격 시스템의 파일)를 접근하게 만듭니다. 이 동작으로 인해 응용 프로그램이 XML 외부 엔터티(XXE) 공격에 노출되고, 이를 통해 로컬 시스템에서 denial of service를 발생시키고, 로컬 컴퓨터의 파일에 무단으로 접근하고, 원격 컴퓨터를 스캔하고, 원격 시스템에서 denial of service를 발생시킬 수 있습니다.

다음 XML 문서에서는 XXE 공격의 예를 보여 줍니다.

<?xml version=""1.0"" encoding=""ISO-8859-1""?>
 <!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM ""file:///dev/random"" >]><foo>&xxe;</foo>


이 예제에서 XML 파서가 엔터티를 /dev/random 파일의 컨텐츠로 대체하려고 시도하는 경우 서버가 중단될 수 있습니다(UNIX 시스템의 경우).","XML unmarshaller가 수신 XML 문서의 일부로 외부 엔터티를 허용하지 않도록 안전하게 구성되어야 합니다.

XXE injection을 방지하려면 XML 소스를 java.io.File, java.io.Reader 또는 java.io.InputStream으로 직접 처리하는 unmarshal 메서드를 사용하지 마십시오. 안전하게 구성된 파서로 문서를 구문 분석하고 다음 예에 표시된 것처럼 보안 파서를 XML 소스를 사용하는 unmarshal 메서드를 사용합니다.


DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(<XML Source>);
Model model = (Model) u.unmarshal(document);


StAX 파서의 경우 다음 구성이 권장됩니다.
- 외부 엔터티 확인 비활성화:

xmlInputFactory.setProperty(""javax.xml.stream.isSupportingExternalEntities"", false);


- 인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

xmlInputFactory.setProperty(""javax.xml.stream.supportDTD"", false);


- 외부 또는 로컬 엔터티 확인이 필요한 경우 안전한 리졸버(resolver)를 구축하고 XML 문서를 구문 분석하기 전에 설정합니다.

xmlInputFactory.setXMLResolver(mySafeResolver);
",,0A2051480F7728E46FF699494826E1B1,D92D11B4-E03C-4B93-9DAA-402C19BE7EFC,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Input Validation and Representation,Cross-Site Scripting: Persistent,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",24,"
  public List<User> findAllUsers() {
    return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
  }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java","MissingFunctionACUsers.java",77,"        userRepository.findAllUsers().stream()
            .map(user -> new DisplayUser(user, PASSWORD_SALT_SIMPLE))
            .collect(Collectors.toList()));
  }
","org.springframework.http.ResponseEntity.ok()","MissingFunctionACUsers.java의 usersService() 메서드가 77 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 77 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",4CC0DB7730948834E7569DC29E7B48A6,B15BA48C-C3A9-42C0-928D-B555CD29BFAD0,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Code Quality,Unreleased Resource: Database,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",24,"
  public List<User> findAllUsers() {
    return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
  }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","Downloads/WebGoat-2023.5/WebGoat-2023.5/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5Test.java","SqlInjectionLesson5Test.java",44,"  public void removeGrant() throws SQLException {
    dataSource
        .getConnection()
        .prepareStatement(""revoke select on grant_rights from unauthorized_user cascade"")
        .execute();",getConnection(),"SqlInjectionLesson5Test.java의 removeGrant() 함수는 44 줄의 <a href=""location://Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/container/LessonDataSource.java###22###1###0"">getConnection()</a>에 의해 할당된 데이터베이스 리소스를 해제하지 못할 수도 있습니다.","SqlInjectionLesson5Test.java의 removeGrant() 함수는 44 줄의 <a href=""location://Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/container/LessonDataSource.java###22###1###0"">getConnection()</a>에 의해 할당된 데이터베이스 리소스를 해제하지 못할 수도 있습니다.","리소스 누출은 최소한 두 가지 공통 원인이 있습니다.

- 오류 조건 및 기타 예외 상황.

- 프로그램의 어떤 부분이 리소스 해제를 담당하고 있는지에 대한 혼란

대부분의 공개되지 않은 리소스 문제는 일반적인 소프트웨어 안정성 문제를 일으킵니다. 하지만 공격자가 의도적으로 리소스 누출을 일으킬 수 있는 경우 공격자가 리소스 풀을 고갈시켜 DoS(Denial of Service) 공격을 실행할 수도 있습니다.

예제: 일반적인 조건에서 다음 코드는 데이터베이스 쿼리를 실행하고 데이터베이스가 반환한 결과를 처리한 다음 할당된 statement 개체를 닫습니다. 하지만 SQL을 실행하거나 결과를 처리하는 동안 예외 사항이 발생하면 statement 개체는 닫히지 않습니다. 이런 일이 자주 발생하면 데이터베이스에 사용 가능한 커서가 부족하게 되어 SQL 쿼리를 더 이상 실행할 수 없습니다.

  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();

","1. 리소스를 다시 확보하는 데 finalize()를 사용하지 마십시오. 개체의 finalize() 메서드를 호출하려면 가비지 수집기(garbage collector)는 개체가 가비지 수집 대상인지 판단해야 합니다. 가비지 수집기(garbage collector)는 JVM이 메모리가 부족한 경우를 제외하고는 실행할 필요가 없기 때문에 finalize() 메서드가 필요할 때 원하는 대로 호출된다는 보장이 없습니다. 또한 결국 가비지 수집기(garbage collector)가 실행되더라도 짧은 시간에 방대한 리소스를 다시 확보하기 때문에 성능이 ""고르지 못하고"" 전반적인 시스템 처리량이 낮아질 수 있습니다. 이런 효과는 시스템의 부하가 증가할수록 더욱 두드러집니다.

마지막으로 리소스 확보 작업이 응답하지 않도록 할 수 있으면(예: 네트워크로 데이터베이스와 통신해야 하는 경우), finalize() 메서드를 실행하고 있는 스레드도 응답하지 않습니다.

2. finally 블록의 리소스를 해제하십시오. 예제 코드는 다음과 같이 다시 작성해야 합니다.


  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}


이 해결책은 도우미 함수를 사용하여 statement를 닫으려 할 때 발생할 수 있는 예외를 기록합니다. 도우미 함수는 statement를 닫을 때마다 재사용될 것입니다.

또한 execCxnSql 메서드는 stmt 개체를 null로 초기화하지 않습니다. 대신 safeClose()를 호출하기 전에 stmt가 null이 아닌지 검사합니다. null 검사를 하지 않으면 Java 컴파일러는 stmt가 초기화되지 않았다고 보고합니다. 이 방법은 uninitialized variable을 발견하는 Java 기능을 이용한 것입니다. stmt를 더 복잡한 방법을 사용하여 null로 초기화하면 초기화하지 않고 stmt를 사용하는 경우를 컴파일러가 발견할 수 없습니다.","1. 데이터베이스 연결을 닫으면 연결 개체와 연관된 다른 리소스가 자동으로 해제될 수도 있고 그렇지 않을 수도 있습니다. 응용 프로그램이 연결 풀링을 사용하는 경우에는 연결을 닫은 후에 다른 리소스를 명시적으로 닫는 것이 좋습니다. 응용 프로그램이 연결 풀링을 사용하지 않을 경우에는 데이터베이스 연결을 닫으면 다른 리소스도 자동으로 닫힙니다. 이러한 경우, 이 취약점은 유효하지 않습니다.",3B4143342141EB51A8EA6745F88C34CD,B7DFF4A8-9817-4418-A35B-E70D10DC825E,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Environment,Dockerfile Misconfiguration: Default User Privilege,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",24,"
  public List<User> findAllUsers() {
    return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
  }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","Downloads/WebGoat-2023.5/WebGoat-2023.5/Dockerfile_desktop",Dockerfile_desktop,1,"FROM lscr.io/linuxserver/webtop:ubuntu-xfce
LABEL NAME = ""WebGoat: A deliberately insecure Web Application""
MAINTAINER ""WebGoat team""",FROM(),"Dockerfile에 USER가 지정되어 있지 않으므로 기본적으로 루트 사용자로 실행됩니다.","Dockerfile에 USER가 지정되어 있지 않으므로 기본적으로 루트 사용자로 실행됩니다.","Dockerfile에 USER가 지정되어 있지 않으면 Docker 컨테이너는 기본적으로 슈퍼 사용자 권한으로 실행됩니다. 이러한 슈퍼 사용자 권한은 컨테이너 안에서 실행 중인 코드로 전파되며 필요 이상으로 많은 권한을 제공합니다. 슈퍼 사용자 권한으로 Docker 컨테이너를 실행하면 공격 표면이 확장되어 공격자가 더 심각한 형태의 악용을 감행할 수 있습니다.","따라서 가능한 경우 루트 사용자가 아닌 사용자로 컨테이너를 실행하는 것이 좋습니다.

루트가 아닌 사용자를 사용하도록 Docker 컨테이너를 수정하려면 Dockerfile에서 다음과 같이 다른 사용자를 지정해야 합니다.

RUN useradd myLowPrivilegeUser
USER myLowPrivilegeUser

    ",,F8A0F676D23B0CE1F581A2966E424F8C,375B7CCC-5920-4230-AE53-A7B264045525,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Environment,Dockerfile Misconfiguration: Dependency Confusion,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",24,"
  public List<User> findAllUsers() {
    return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
  }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","Downloads/WebGoat-2023.5/WebGoat-2023.5/Dockerfile_desktop",Dockerfile_desktop,12,"COPY config/desktop/WebGoat.txt /config/Desktop/

RUN \
 case $(uname -m) in \
  x86_64) ARCH=x64;; \",RUN(),"비특정 버전을 사용하여 빌드 종속성을 검색하면 빌드 시스템이 악성 바이너리에 취약해지거나 시스템에서 예기치 않은 동작이 발생할 수 있습니다.","비특정 버전을 사용하여 빌드 종속성을 검색하면 빌드 시스템이 악성 바이너리에 취약해지거나 시스템에서 예기치 않은 동작이 발생할 수 있습니다.","Dockerfile은 종속성 및 기본 이미지에 대해 바인딩되지 않은 버전 범위를 지정할 수 있습니다. 공격자가 리포지토리에 악성 버전의 종속성을 추가하거나 공격자의 제어 하에 있는 리포지토리에서 종속성을 다운로드하도록 빌드 시스템을 교란할 수 있는 상황에서 Docker가 특정 버전의 종속성 없이 구성되어 있으면 Docker는 손상된 종속성을 자동으로 다운로드하고 실행합니다.

이러한 유형의 약점은 공격자가 개발자의 구성 오류, 타이포스쿼팅을 활용하고 오픈 소스 리포지토리에 악성 패키지를 추가할 수 있는 공급망 공격의 결과로 악용될 수 있습니다. 이 유형의 공격은 게시된 패키지의 신뢰를 악용하여 액세스 권한을 얻고 데이터를 반출합니다.

Docker에서 latest 태그는 이미지의 버전을 제공하기 위한 다이제스트 또는 고유 태그를 사용하지 않고 이미지의 버전 수준을 자동으로 나타냅니다. Docker는 최신 이미지 매니페스트 파일을 가리키는 메커니즘으로 latest 태그를 자동으로 할당합니다. 태그는 변경이 가능하기 때문에 공격자는 latest(또는 imagename-lst, imagename-last, myimage와 같은 약한 태그)를 사용하여 이미지 또는 계층을 바꿀 수 있습니다.

예제 1: 다음 구성은 Docker에 ubuntu의 최신 버전을 사용하는 기본 이미지를 선택하도록 지시합니다.

    FROM ubuntu:Latest
    ...


Docker는 패키지 관리자를 지원하도록 구성된 리포지토리의 신뢰성을 검증하지 않습니다.

예제 2: 다음 구성은 패키지 관리자 zypper에 지정된 패키지의 최신 버전을 검색하도록 지시합니다.

...
zypper install package
...

Example 2에서 리포지토리가 손상된 경우 공격자는 동적 기준을 충족하는 버전을 업로드하고 zypper로 하여금 종속성의 악성 버전을 다운로드하도록 할 수 있습니다.","버전 고정 또는 단순 고정을 수행하십시오. 버전 고정은 응용 프로그램 또는 시스템에 사용할 이미지, 라이브러리 및 지원 패키지의 버전을 명시적으로 지정합니다. 고정의 주된 목표는 시스템 안정성을 보장하여 반복 가능한 배포를 달성하는 것입니다. 고정을 수행하면 최종 사용자, 개발자 및 테스터가 모두 동일한 코드 기반을 사용할 수 있습니다. 또한 고정을 사용하면 응용 프로그램 보안 검증 및 맬웨어 감지의 엄격한 프로세스를 거친 안전한 종속성의 사용을 보장할 수 있습니다.

Docker에서 zypper(또는 기타 패키지 관리자)를 호출하는 경우 다음 형식을 사용하십시오.
    
    RUN zypper install <package_name>=<version> \
    RUN gem install <package_name> --version <version>
    RUN gem install <package_name> -v <version>
    RUN apk add <package_name>=<version>
    RUN apt-get update && apt-get install -y  \
      <package_name>=<version>  \
      <package_name>=<version> \
      <package_name>=<version> \
      && rm -rf /var/lib/apt/lists/*
    
여기서 <package_name>은 설치할 종속성의 이름이고 <version>은 응용 프로그램에 사용해야 하는 정확한 버전 또는 릴리스입니다.

Fortify는 또한 다음을 권장합니다.
- 패키지 관리자에 사용되는 리포지토리를 신뢰할 수 있는지 아니면 적절히 보관되는지 확인하고, 악성 코드를 패키지에 추가하는 것을 포함하여 설치 패키지 대체가 가능하지 않은지 확인하십시오.
- 공개 리포지토리 또는 신뢰할 수 없는 리포지토리를 사용하지 마십시오.
- 회귀 테스트를 실행하기 전에 패키지에서 맬웨어 및 보안 취약점을 검사하십시오.
- 디지털 서명된 이미지를 사용하십시오.
- latest와 같은 이미지 태그 또는 imagename-lst, imagename-last, myimage와 같은 취약한 태그를 운영 환경의 배포에 사용하지 마십시오.
- 특정 버전 태그와 같이 더 안정적인 태그를 사용하십시오. 그러나 이러한 태그도 변경되지 않는다는 보장은 없습니다.
- 뮤턴트 태그를 만들지 마십시오.
- 이미지 소스 및 해당 계층에 대한 엄격한 제어를 구현하십시오.",,F311119CB9A7E566CD0798F54D580940,10AB223B-7AA6-464A-A036-4616C822C299,,,,Wed Apr 17 14:13:45 KST 2024,
Critical,Critical,Input Validation and Representation,Dynamic Code Evaluation: Unsafe XStream Deserialization,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java","VulnerableComponentsLesson.java",40,"
  @PostMapping(""/VulnerableComponents/attack1"")
  public @ResponseBody AttackResult completed(@RequestParam String payload) {
    XStream xstream = new XStream();
    xstream.setClassLoader(Contact.class.getClassLoader());",completed(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java","VulnerableComponentsLesson.java",57,"                .replace("" <"", ""<"");
      }
      contact = (Contact) xstream.fromXML(payload);
    } catch (Exception ex) {
      return failed(this).feedback(""vulnerable-components.close"").output(ex.getMessage()).build();","com.thoughtworks.xstream.XStream.fromXML()","VulnerableComponentsLesson.java 파일은 57 줄에서 XStream을 사용하여 확인되지 않은 XML 입력을 역직렬화합니다. 런타임 시 사용자가 제어하는 XML 문서를 역직렬화하면 공격자가 서버에서 악성 코드를 실행할 수 있습니다.","VulnerableComponentsLesson.java 파일은 57 줄에서 XStream을 사용하여 확인되지 않은 XML 입력을 역직렬화합니다. 런타임 시 사용자가 제어하는 XML 문서를 역직렬화하면 공격자가 서버에서 악성 코드를 실행할 수 있습니다.","개발자는 XStream 라이브러리를 통해 손쉽게 개체를 전송하여 XML 문서로 직렬화할 수 있습니다. 그러나 XStream 역직렬화는 공격자가 서버에서 임의의 Java 코드를 실행하도록 허용할 수 있습니다.

예제 1: 다음 Java 코드는 신뢰할 수 없는 입력을 처리하는 XStream 인스턴스를 보여줍니다.


XStream xstream = new XStream();
String body = IOUtils.toString(request.getInputStream(), ""UTF-8"");
Contact expl = (Contact) xstream.fromXML(body);
","XStream은 버전 1.4.7 이후부터 java.beans.EventHandler 등의 알려진 불량 클래스 역직렬화를 암시적으로 방지합니다. 그러나 향후 새로운 가젯이 발견될 수 있기 때문에 거부 목록 접근 방식은 충분하지 않습니다. 또한 XStream 1.4.7은 개발자가 유형 권한을 정의하도록 허용합니다. 이러한 권한을 사용하여 역직렬화되는 유형을 명시적으로 허용(허용 목록)할 수 있으므로 개체 그래프에 예기치 않은 유형을 삽입할 수 없습니다. 외부 소스에서 데이터를 역직렬화하는 응용 프로그램은 이 기능을 사용하여 임의 명령 실행 위험을 제한해야 합니다. 공격자가 다양한 클래스를 사용하여 원격 코드 실행을 수행하고 거부 목록을 우회할 수 있으므로 항상 허용 목록 접근 방식(허용되는 유형 검사)을 사용해야 합니다.

예제 2: 다음 Java 코드는 허용되는 유형을 정의하여 신뢰할 수 없는 입력을 안전하게 처리하는 XStream 인스턴스를 보여 줍니다.


XStream xstream = new XStream();
// clear out existing permissions and set own ones
xstream.addPermission(NoPermissionType.NONE);
// allow some basics
xstream.addPermission(NullPermission.NULL);
xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);
xstream.allowTypeHierarchy(Collection.class);
// allow any type from the same package
xstream.allowTypesByWildcard(new String[] {
    Contact.class.getPackage().getName()+"".*""
});
String body = IOUtils.toString(request.getInputStream(), ""UTF-8"");
Contact expl = (Contact) xstream.fromXML(body);


허용 목록에서 허용되는 모든 클래스를 감사하여 역직렬화해도 안전한지를 확인해야 합니다.

XStream을 Spring 프로젝트의 마샬링 솔루션으로 사용하는 경우 “converters” 속성을 사용하여 org.springframework.oxm.xstream.CatchAllConverter 변환기로 시작하는 사용자 지정 변환기 체인을 설정하십시오.

예제 3: 다음 Spring 구성은 “converters” 속성을 사용하여 사용자 지정 변환 체인을 설정합니다. 

    <bean id=""marshallingHttpMessageConverter"" class=""org.springframework.http.converter.xml.MarshallingHttpMessageConverter"">
        <property name=""marshaller"" ref=""xstreamMarshaller""/>
        <property name=""unmarshaller"" ref=""xstreamMarshaller""/>
    </bean>

    <bean id=""xstreamMarshaller"" class=""org.springframework.oxm.xstream.XStreamMarshaller"">
        <property name=""aliases"">
            <props>
                <prop key=""contact"">org.company.converters.Contact</prop>
            </props>
        </property>
        <property name=""converters"">
            <list>
                <bean class=""org.springframework.oxm.xstream.CatchAllConverter""/>
                <bean class=""org.company.converters.ContactConverter""/>
            </list>
        </property>
    </bean>
",,7F03CE88BFEC1BE527092446C93EB6D7,3B3C6BD3-2ACF-46BE-AB6B-1719C0D8940B,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Security Features,Insecure Randomness: User-Controlled Seed,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"  }

  public static void main(String[] args) {
    if (args == null || args.length != 2) {
      System.out.println(""Need a username and key"");",main(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",17,"    if (username.equalsIgnoreCase(""admin"")) {
      // Admin has a fix reset link
      random.setSeed(key.length());
    }
    return scramble(random, scramble(random, scramble(random, MD5.getHashString(username))));","java.util.Random.setSeed()","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,140E99ACA7DA41F5640C2A65B803CD23,3CB1D23E-CE0D-47E5-B387-F1026CDA0D64,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Security Features,Password Management: Empty Password,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"  }

  public static void main(String[] args) {
    if (args == null || args.length != 2) {
      System.out.println(""Need a username and key"");",main(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/xxe/User.java","User.java",31,"
  private String username = """";
  private String password = """";

  public String getPassword() {",FieldAccess: password(),"빈 암호는 쉽게 해결할 수 없는 방식으로 시스템 보안을 침해할 수 있습니다.","빈 암호는 쉽게 해결할 수 없는 방식으로 시스템 보안을 침해할 수 있습니다.","빈 문자열을 암호 변수로 지정하는 것은 좋은 방법이 아닙니다. 빈 암호를 사용하여 다른 시스템을 인증하는 데 성공하게 되면 빈 암호를 받기 때문에 해당 계정의 보안이 침해될 수 있습니다. 올바른 값이 변수에 할당될 때까지 빈 암호가 단순히 자리 표시자로 사용되는 경우에는 코드에 익숙치 않은 사용자를 혼란시킬 수 있으며 예기치 못한 제어 흐름 경로에 문제를 일으킬 수 있습니다.



예제 1: 다음 코드는 빈 암호를 사용하여 데이터베이스에 연결하려 시도합니다.

    ...
    DriverManager.getConnection(url, ""scott"", """");
    ...


Example 1의 코드가 성공하면 데이터베이스 사용자 계정인 “scott”이 공격자가 쉽게 추측할 수 있는 빈 암호로 구성되어 있음을 나타냅니다. 프로그램을 공개한 후에는 비어 있지 않은 암호를 사용하기 위한 계정 업데이트를 위해 코드 변경이 필요합니다.

예제 2: 다음 코드는 암호 변수를 빈 문자열로 초기화하고 암호의 저장된 값 읽기를 시도하여 사용자가 제공하는 값과 비교합니다.


    ...
    String storedPassword = """";
    String temp;

    if ((temp = readPassword()) != null) {
        storedPassword = temp;
    }

    if(storedPassword.equals(userPassword))
        // Access protected resources
        ...
    }
    ...


readPassword()가 데이터베이스 오류 또는 다른 문제로 인해 저장된 암호를 검색하지 못하면 공격자가 userPassword에 대해 빈 문자열을 입력하여 암호 확인을 무시할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 3: 다음 코드는 사용자 이름과 암호 변수를 빈 문자열로 초기화하고, 서버가 현재 요청을 이전에 거부하지 않은 경우 Android WebView 저장소에서 자격 증명을 읽은 후 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String username = """";
    String password = """";

    if (handler.useHttpAuthUsernamePassword()) {
      String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
      username = credentials[0];
      password = credentials[1];
    }
    handler.proceed(username, password);
  }
});
...


Example 2와 마찬가지로 useHttpAuthUsernamePassword()에서 false를 반환하면 공격자가 빈 암호를 입력하여 보호된 페이지를 볼 수 있습니다.","항상, 암호화된 외부 리소스에서 저장된 암호 값을 읽고 암호 변수에 의미 있는 값을 지정하십시오. 민감한 리소스를 빈 암호 또는 null 암호로 보호하지 않도록 해야 합니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 따라서 암호화된 데이터베이스에 자격 증명을 저장할 수 있습니다.

예제 4: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",74F1E8AD635A457A4F9E96B9052D094D,8bd01c50-a769-11de-8a39-0800200c9a66,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Time and State,Race Condition: Singleton Member Field,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"  }

  public static void main(String[] args) {
    if (args == null || args.length != 2) {
      System.out.println(""Need a username and key"");",main(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java","LogBleedingTask.java",47,"  @PostConstruct
  public void generatePassword() {
    password = UUID.randomUUID().toString();
    log.info(
        ""Password for admin: {}"",",AssignmentStatement(),"LogBleedingTask 클래스는 하나뿐이기 때문에 password 멤버 필드는 사용자 간에 공유됩니다. 결과는 하나의 사용자가 다른 사용자의 데이터를 볼 수 있는 것입니다.","LogBleedingTask 클래스는 하나뿐이기 때문에 password 멤버 필드는 사용자 간에 공유됩니다. 결과는 하나의 사용자가 다른 사용자의 데이터를 볼 수 있는 것입니다.","많은 Servlet 개발자들은 Servlet이 단일 항목이라는 사실을 모릅니다. Servlet의 인스턴스는 하나뿐이며, 이 단일 인스턴스를 여러 번 사용하여 다른 스레드에 의해서 동시에 처리되는 여러 요청을 처리합니다. 

이런 무지로 인해 일반적으로 발생하는 결과는 개발자가 사용자로 하여금 실수로 다른 사용자의 데이터를 볼 수 있도록 Servlet 멤버 필드를 사용하는 것입니다. 다시 말해, 사용자 데이터를 Servlet 멤버 필드에 저장하여 데이터 접근 경쟁 조건(race condition)을 야기합니다.

예제 1: 다음 Servlet은 요청 매개 변수의 값을 멤버 필드에 저장한 다음, 나중에 매개 변수 값을 응답 출력 스트림으로 보냅니다.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     name = req.getParameter(""name"");
     ...
     out.println(name + "", thanks for visiting!"");
   }
}


이 코드는 단일 사용자 환경에서는 올바로 동작하지만, 두 명의 사용자가 거의 동시에 Servlet에 접근하면 다음과 같이 두 요청 처리기 스레드가 얽힐 수 있습니다.

스레드 1:	name에 ""Dick"" 할당
스레드 2:	name에 ""Jane"" 할당
스레드 1:	print ""Jane, thanks for visiting!""
스레드 2:	print ""Jane, thanks for visiting!""

따라서 첫 번째 사용자에게 두 번째 사용자의 이름이 표시됩니다.","Servlet 멤버 필드를 상수 저장 외에 다른 용도로 사용하지 마십시오. 즉, 모든 멤버 필드를 static final로 지정하십시오.

개발자가 데이터를 코드의 한 장소에서 다른 장소로 옮겨야 할 때 사용자 데이터에 Servlet 멤버 필드를 사용하고 싶을 것입니다. 그래야 할 경우, 별도의 클래스를 선언하고 Servlet은 새 클래스를 ""래핑""하는 데만 사용하도록 하십시오. 

예제 2: Example 1의 버그는 다음과 같이 수정할 수 있습니다.


public class GuestBook extends HttpServlet {

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
	GBRequestHandler handler = new GBRequestHandler();
	handler.handle(req, res);
   }
}

public class GBRequestHandler {

   String name;

   public void handle(HttpServletRequest req, HttpServletResponse res) {
     name = req.getParameter(""name"");
     ...
     out.println(name + "", thanks for visiting!"");
   }

}


또는 Servlet이 동기화된 차단을 사용하여 서블릿 인스턴스 변수에 접근할 수 있지만 동기화된 차단을 사용하면 중요한 성능 문제가 발생할 수 있습니다.

동기화된 블록 내에서 필드 접근을 래핑하는 경우 같은 동기화 블록 또는 메서드 내에서 해당 멤버에 대한 모든 읽기 및 쓰기 작업을 수행해야 문제를 방지할 수 있습니다.

예제 3: Example 1 쓰기 작업(할당)을 동기화된 블록에서 래핑해도 문제는 해결되지 않습니다. 스레드가 name 필드 수정을 위한 잠금을 획득하기는 하지만 이후 잠금을 해제하므로 두 번째 스레드가 값을 다시 변경할 수 있기 때문입니다. name 값을 변경한 후 첫 번째 스레드가 실행을 다시 시작하면 두 번째 스레드가 할당한 값이 인쇄됩니다.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     synchronized(name) {
        name = req.getParameter(""name"");
     }
     ...
     out.println(name + "", thanks for visiting!"");
   }
}


이러한 race condition을 해결하려면 공유 멤버 필드에 대한 모든 쓰기 및 읽기 작업을 동일한 동기화된 블록 내에서 최소 단위로 실행해야 합니다.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     synchronized(name) {
        name = req.getParameter(""name"");
        ...
        out.println(name + "", thanks for visiting!"");
     }
   }
}
",,FA3D4834DC852AEB4341576A9CC76F7F,46BD334E-BA05-4177-B856-06B1034F5FB3,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Input Validation and Representation,Server-Side Request Forgery,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",44,"  @PostMapping(""/SSRF/task2"")
  @ResponseBody
  public AttackResult completed(@RequestParam String url) {
    return furBall(url);
  }",completed(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",51,"    if (url.matches(""http://ifconfig\\.pro"")) {
      String html;
      try (InputStream in = new URL(url).openStream()) {
        html =
            new String(in.readAllBytes(), StandardCharsets.UTF_8)","java.net.URL.openStream()","51 줄의 openStream() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.","51 줄의 openStream() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.","공격자가 응용 프로그램 서버에서 설정된 네트워크 연결에 영향을 미칠 수 있을 때 SSRF(Server-Side Request Forgery)가 발생합니다. 네트워크 연결의 출처는 응용 프로그램 서버 내부 IP가 되며, 공격자는 이 연결을 이용해서 네트워크 제어를 무시하고 원래는 노출되지 않은 내부 리소스를 스캔 또는 공격할 수 있게 됩니다.



예제: 다음은 공격자가 서버가 연결하는 URL을 제어할 수 있게 되는 예입니다.


String url = request.getParameter(""url"");
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet(url);
CloseableHttpResponse response1 = httpclient.execute(httpGet);


공격자가 네트워크 연결을 하이재킹하는 능력은 해당 공격자가 제어 가능한 URI의 특정 부분 및 연결에 사용된 라이브러리에 좌우됩니다. 예를 들어, URI 스키마를 제어할 수 있게 되면 공격자는 http 또는 https와는 다른 다음 프로토콜을 사용할 수 있게 됩니다.

- up://
- ldap://
- jar://
- gopher://
- mailto://
- ssh2://
- telnet://
- expect://

이렇게 하이재킹된 네트워크 연결을 이용하여 공격자는 다음과 같은 공격을 수행할 수 있습니다.

- 인트라넷 리소스 포트 스캐닝
- 방화벽 무시
- 응용 프로그램 서버 또는 인트라넷에서 실행 중인 취약 프로그램 공격
- Injection 공격 또는 CSRF를 활용한 내/외부 웹 응용 프로그램 공격
- file:// 스키마를 활용하여 로컬 파일에 접근
- Windows 시스템에서 공격자가 file:// 스키마 및 UNC 경로를 통해 내부 공유 자료에 접근 및 스캔 가능
- DNS 캐시 감염 공격 수행","사용자 제어 데이터를 기반으로 하여 네트워크 연결을 설정하지 마십시오. 또한 요청은 예정된 대상으로 전달되는지 확인해야 합니다. 대상 URI 구축을 위해 사용자 데이터가 필요한 경우에는 다음과 같은 간접 참조를 사용하십시오. 즉, 사용자가 선택해야 하는 올바른 리소스 이름의 목록을 만듭니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.

또한 필요한 경우 사용자 입력이 대상 시스템의 지정된 리소스에만 사용되도록 하십시오. URI 스키마, 호스트, 포트는 응용 프로그램이 제어하도록 해야 합니다. 이런 방식을 통해 공격자가 가할 수 있는 피해를 크게 줄일 수 있습니다.",,1CE8A3993EC5BF68D0047C66EA8F9468,33DDCCB9-248C-46E8-BF4E-0A8DFA006946,,,,Wed Apr 17 14:13:45 KST 2024,
High,High,Code Quality,Unreleased Resource: Files,"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",44,"  @PostMapping(""/SSRF/task2"")
  @ResponseBody
  public AttackResult completed(@RequestParam String url) {
    return furBall(url);
  }",completed(0),"Downloads/WebGoat-2023.5/WebGoat-2023.5/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",69,"      FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());

      ZipFile zip = new ZipFile(uploadedZipFile.toFile());
      Enumeration<? extends ZipEntry> entries = zip.entries();
      while (entries.hasMoreElements()) {","zip = new ZipFile(...)","ProfileZipSlip.java의 processZipUpload() 함수는 69 줄의 ZipFile()에 의해 할당된 파일 핸들을 해제하지 못할 수도 있습니다.","ProfileZipSlip.java의 processZipUpload() 함수는 69 줄의 ZipFile()에 의해 할당된 파일 핸들을 해제하지 못할 수도 있습니다.","프로그램이 파일 핸들을 해제하지 못할 수도 있습니다.

리소스 누출은 최소한 두 가지 공통 원인이 있습니다.

- 오류 조건 및 기타 예외 상황.

- 프로그램의 어떤 부분이 리소스 해제를 담당하고 있는지에 대한 혼란

대부분의 공개되지 않은 리소스 문제는 일반적인 소프트웨어 안정성 문제를 일으킵니다. 하지만 공격자가 의도적으로 리소스 누출을 일으킬 수 있는 경우 공격자가 리소스 풀을 고갈시켜 DoS(Denial of Service) 공격을 실행할 수도 있습니다.

예제 1: 다음 메서드는 자신이 연 파일 핸들을 닫지 않습니다. ZipFile의 finalize() 메서드는 결국 close()를 호출하지만 finalize() 메서드를 호출하기까지 시간이 얼마나 걸릴지 장담할 수 없습니다. 사용량이 많은 환경에서는 이로 인해 JVM이 파일 핸들을 모두 소진시키는 결과를 초래할 수도 있습니다.


public void printZipContents(String fName) throws ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException {
  ZipFile zf = new ZipFile(fName);
  Enumeration<ZipEntry> e = zf.entries();

  while (e.hasMoreElements()) {
    printFileInfo(e.nextElement());
  }
}


예제 2: 일반적인 조건에서 다음 해결책은 모든 zip 파일 항목을 출력한 후 파일 핸들을 올바르게 닫습니다. 그러나 항목을 반복하는 동안 예외가 발생하는 경우, zip 파일 핸들은 닫히지 않습니다. 이런 일이 빈번하게 발생하는 경우, JVM에는 사용 가능한 파일 핸들이 계속 부족할 수 있습니다.


public void printZipContents(String fName) throws ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException {
  ZipFile zf = new ZipFile(fName);
  Enumeration<ZipEntry> e = zf.entries();

  while (e.hasMoreElements()) {
    printFileInfo(e.nextElement());
  }
  zf.close();
}
","1. 리소스를 다시 확보하는 데 finalize()를 사용하지 마십시오. 개체의 finalize() 메서드를 호출하려면 가비지 수집기(garbage collector)는 개체가 가비지 수집 대상인지 판단해야 합니다. 가비지 수집기(garbage collector)는 JVM이 메모리가 부족한 경우를 제외하고는 실행할 필요가 없기 때문에 finalize() 메서드가 필요할 때 원하는 대로 호출된다는 보장이 없습니다. 또한 결국 가비지 수집기(garbage collector)가 실행되더라도 짧은 시간에 방대한 리소스를 다시 확보하기 때문에 성능이 ""고르지 못하고"" 전반적인 시스템 처리량이 낮아질 수 있습니다. 이런 효과는 시스템의 부하가 증가할수록 더욱 두드러집니다.

마지막으로 리소스 확보 작업이 응답하지 않도록 할 수 있으면(예: 네트워크로 통신해야 하는 경우), finalize() 메서드를 실행하고 있는 스레드도 응답하지 않습니다.

예제 3: finally 블록의 리소스를 해제하십시오. Example 2의 코드는 다음과 같이 다시 작성할 수 있습니다.


public void printZipContents(String fName) throws ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException {
  ZipFile zf;
  try {
    zf = new ZipFile(fName);
    Enumeration<ZipEntry> e = zf.entries();
    ...
  }
  finally {
    if (zf != null) {
      safeClose(zf);
    }
  }
}

public static void safeClose(ZipFile zf) {
  if (zf != null) {
    try {
      zf.close();
    } catch (IOException e) {
      log(e);
    }
  }
}


이 해결책은 도우미 함수를 사용하여 파일을 닫으려 할 때 발생할 수 있는 예외를 기록합니다. 도우미 함수는 파일을 닫을 때마다 재사용될 것입니다.

또한 printZipContents 메서드는 zf 개체를 null로 초기화하지 않습니다. 대신 safeClose()를 호출하기 전에 zf가 null이 아닌지 검사합니다. null 검사를 하지 않으면 Java 컴파일러는 zf가 초기화되지 않았다고 보고합니다. 이 방법은 uninitialized variable을 발견하는 Java 기능을 이용한 것입니다. zf를 더 복잡한 방법을 사용하여 null로 초기화하면 초기화하지 않고 zf를 사용하는 경우를 컴파일러가 발견할 수 없습니다.",,381DF997102B00173D237486D12C65D0,15A7E886-8858-4BA6-B35E-91FAA8C562F4,,,,Wed Apr 17 14:13:45 KST 2024,
