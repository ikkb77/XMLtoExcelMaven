<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ReportDefinition type="xml">
    <TemplateName>developer-all-issue</TemplateName>
    <TemplatePath>C:\Users\ikkb7\AppData\Local\Fortify\config\AWB-23.2.0\reports\developer-all-issue.xml</TemplatePath>
    <LogoPath>/OT_logo.png</LogoPath>
    <Footnote>Copyright 2023 Open Text.</Footnote>
    <UserName>ikkb7</UserName>
    <ReportSection enabled="true" optionalSubsections="false">
        <Title>Report Overview</Title>
        <SubSection enabled="true">
            <Title>Report Summary</Title>
            <Description>This provides a high level summary of the findings that the analysis produced.  Also includes basic information on the scope of the scan.</Description>
            <Text>On Feb 7, 2024, a source code review was performed over the WebGoat-2023.8 code base. 2,232 files, 29,188 LOC (Executable) were scanned. A total of 660 issues were uncovered during the analysis.  This report provides a comprehensive description of all the types of issues found in this project.  Specific examples and source code are provided for each issue type.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issue Summary by Fortify Priority Order</Title>
            <Description>A table summarizing the number of issues found and the breakdown of issues in each Fortify Priority Level</Description>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Fortify Priority Order</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="445">
                        <groupTitle>Low</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="112">
                        <groupTitle>High</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="91">
                        <groupTitle>Critical</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="12">
                        <groupTitle>Medium</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="false">
        <Title>Issue Summary</Title>
        <SubSection enabled="true">
            <Title>Overall number of results</Title>
            <Description>Results count</Description>
            <Text>The scan found 660 issues.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issues By Category</Title>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="215">
                        <groupTitle>Poor Error Handling: Overly Broad Throws</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="49">
                        <groupTitle>System Information Leak: External</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="35">
                        <groupTitle>Path Manipulation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="33">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="30">
                        <groupTitle>Mass Assignment: Insecure Binder Configuration</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="27">
                        <groupTitle>SQL Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="23">
                        <groupTitle>Password Management: Hardcoded Password</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>System Information Leak: Internal</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>Credential Management: Hardcoded API Credentials</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>Insecure Randomness</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Cookie Security: HTTPOnly not Set</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Cross-Site Scripting: DOM</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="14">
                        <groupTitle>Cookie Security: Cookie not Sent Over SSL</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Open Redirect</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Access Control: Database</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Resource Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>System Information Leak</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Password Management: Password in Comment</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Privacy Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Log Forging</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Often Misused: File Upload</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Race Condition</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Denial of Service: StringBuilder</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>J2EE Bad Practices: Leftover Debug Code</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Key Management: Hardcoded Encryption Key</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Poor Error Handling: Empty Catch Block</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Unchecked Return Value</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Bad Practices: JVM Termination</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Log Forging (debug)</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>XML Entity Expansion Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>XML External Entity Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cross-Site Scripting: Self</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Password Management: Password in Configuration File</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Password Management: Weak Cryptography</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Privacy Violation: Autocomplete</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: Incorrect Serializable Method Signature</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Command Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Denial of Service</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dockerfile Misconfiguration: Default User Privilege</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dockerfile Misconfiguration: Dependency Confusion</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dynamic Code Evaluation: Unsafe Deserialization</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dynamic Code Evaluation: Unsafe XStream Deserialization</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>File Disclosure: Spring</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>HTML5: Overly Permissive Message Posting Policy</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Insecure Randomness: User-Controlled Seed</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Often Misused: Authentication</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Password Management: Empty Password</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Path Manipulation: Zip Entry Overwrite</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Race Condition: Singleton Member Field</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Server-Side Request Forgery</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Spring Security Misconfiguration: Disabled Security Headers</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Weak Cryptographic Hash</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Results Outline</Title>
        <SubSection enabled="true">
            <Title>Vulnerability Examples by Category</Title>
            <Description>Results summary of all issue categories.  Vulnerability examples are provided by category.</Description>
            <IssueListing listing="true" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="list">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="215">
                        <groupTitle>Poor Error Handling: Overly Broad Throws</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MavenWrapperDownloader.java의 downloadFileFromURL() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>메서드를 Exception 또는 Throwable이 발생하도록 선언하면 호출자가 올바른 오류 처리 및 오류 복구 작업을 수행하기 어렵습니다. Java의 예외 메커니즘은 호출자가 손쉽게 잘못을 예상하고 각각의 고유한 예외 상황을 처리하기 위한 코드를 쓸 수 있도록 설계되어 있습니다. 일반적인 형태의 예외 사항이 발생하도록 메서드를 선언하면 이런 메커니즘이 아무 소용이 없습니다.

예제: 다음 메서드는 세 가지 형식의 예외 사항이 발생합니다.


public void doExchange()
  throws IOException, InvocationTargetException,
         SQLException {
  ...
}



코드를 다음과 같이 쓰는 것이 깔끔해 보입니다.


public void doExchange()
  throws Exception {
  ...
}


하지만 이 방법은 호출자가 발생하는 예외 사항을 이해하고 처리하는 기능을 방해합니다. 또한 doExchange()의 이후 수정 버전에서 이전 예외 사항과 다르게 처리해야 하는 새 형식의 예외 사항을 도입하는 경우 이 요구 사항을 쉽게 적용할 수 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Exception 또는 Throwable이 발생하도록 메서드를 선언하지 마십시오. 메서드에서 발생한 예외 사항을 복구할 수 없거나 호출자가 쉽게 파악할 수 없는 경우 검사하는 예외 사항 대신 검사하지 않는 예외 사항 발생을 고려해 보십시오. Exception 대신 RuntimeException 또는 Error를 확장하거나 메서드에 try/catch 래퍼를 추가하여 검사할 예외 사항을 검사하지 않는 예외로 변환하는 예외 클래스를 구현하면 됩니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>215</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="13132ECFC7C65367ABBBD906163C10E0" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Servers.java의 sort() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Servers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java</FilePath>
<LineStart>67</LineStart>
<Snippet>  @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
  @ResponseBody
  public List&lt;Server&gt; sort(@RequestParam String column) throws Exception {
    List&lt;Server&gt; servers = new ArrayList&lt;&gt;();
</Snippet>
<TargetFunction>Function: sort()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F757A95D4B19866B54A52F0E3C37509F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ResetLinkAssignmentTest.java의 knownLinkShouldReturnPasswordResetPage() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentTest.java</FilePath>
<LineStart>79</LineStart>
<Snippet>
  @Test
  void knownLinkShouldReturnPasswordResetPage() throws Exception {
    // Create a reset link
    mockMvc</Snippet>
<TargetFunction>Function: knownLinkShouldReturnPasswordResetPage()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3B4132C5AECCD9761F5C63193AF3D43B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACUsersTest.java의 addUser() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACUsersTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsersTest.java</FilePath>
<LineStart>60</LineStart>
<Snippet>
  @Test
  void addUser() throws Exception {
    var user =
        """</Snippet>
<TargetFunction>Function: addUser()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="29E02620B4195D3D0F7C6A4B271236BE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CrossSiteScriptingLesson1Test.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CrossSiteScriptingLesson1Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson1Test.java</FilePath>
<LineStart>58</LineStart>
<Snippet>
  @Test
  void success() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post(CONTEXT_PATH).param("checkboxAttack1", "value"))</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AB25B990201E4F041C281D97F9D3A670" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 solveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>54</LineStart>
<Snippet>
  @Test
  void solveAssignment() throws Exception {
    ObjectMapper objectMapper = new ObjectMapper();
</Snippet>
<TargetFunction>Function: solveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1949306FC7FC144C938BDDCD12EE4178" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTSecretKeyEndpointTest.java의 incorrectToken() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpointTest.java</FilePath>
<LineStart>120</LineStart>
<Snippet>
  @Test
  public void incorrectToken() throws Exception {
    Claims claims = createClaims("Tom");
    String token = Jwts.builder().setClaims(claims).signWith(HS512, "wrong_password").compact();</Snippet>
<TargetFunction>Function: incorrectToken()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="91D11F35BA5D8C62E3E26132683FC4F5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson9Test.java의 SmithIsMostEarningCompletesAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9Test.java</FilePath>
<LineStart>185</LineStart>
<Snippet>
  @Test
  public void SmithIsMostEarningCompletesAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: SmithIsMostEarningCompletesAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D743DCD69DBDA301E66C517EC7221826" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HttpBasicsInterceptRequestTest.java의 missingParam() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HttpBasicsInterceptRequestTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/httpproxies/HttpBasicsInterceptRequestTest.java</FilePath>
<LineStart>81</LineStart>
<Snippet>
  @Test
  public void missingParam() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: missingParam()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C73E21879FAD7D4676FA7BB43A8B0222" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 validLoginWithoutCookieTest() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>89</LineStart>
<Snippet>  @Test
  @DisplayName("Valid credentials login without authentication cookie")
  void validLoginWithoutCookieTest() throws Exception {
    String username = "webgoat";
    String password = "webgoat";</Snippet>
<TargetFunction>Function: validLoginWithoutCookieTest()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="224D6410A944598A79881BD0BD7C9218" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ClientSideFilteringFreeAssignmentTest.java의 wrongSalary() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ClientSideFilteringFreeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ClientSideFilteringFreeAssignmentTest.java</FilePath>
<LineStart>31</LineStart>
<Snippet>
  @Test
  public void wrongSalary() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongSalary()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E0363D64F0486E1D3CF177C937E33080" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadRetrievalTest.java의 shouldReceiveRandomPicture() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrievalTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrievalTest.java</FilePath>
<LineStart>69</LineStart>
<Snippet>
  @Test
  public void shouldReceiveRandomPicture() throws Exception {
    mockMvc
        .perform(get("/PathTraversal/random-picture"))</Snippet>
<TargetFunction>Function: shouldReceiveRandomPicture()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E71E655E6DBEA27660BA7965B2424236" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SSRFTest1.java의 modifyUrlJerry() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTest1.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/ssrf/SSRFTest1.java</FilePath>
<LineStart>38</LineStart>
<Snippet>
  @Test
  public void modifyUrlJerry() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/SSRF/task1").param("url", "images/jerry.png"))</Snippet>
<TargetFunction>Function: modifyUrlJerry()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0F71F796B80DE81F988A939575AF81E2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 addressCorrectShouldOrderByHostnameUsingSubstr() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>39</LineStart>
<Snippet>
  @Test
  public void addressCorrectShouldOrderByHostnameUsingSubstr() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: addressCorrectShouldOrderByHostnameUsingSubstr()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3E79DA77424A9071E9503386A1BDB8F2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACHiddenMenusTest.java의 HiddenMenusSuccess() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACHiddenMenusTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACHiddenMenusTest.java</FilePath>
<LineStart>50</LineStart>
<Snippet>
  @Test
  public void HiddenMenusSuccess() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: HiddenMenusSuccess()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B5CC9E93B98D8A457A7E92DE1D47790C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 guestShouldNotBeAbleToVote() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>214</LineStart>
<Snippet>
  @Test
  public void guestShouldNotBeAbleToVote() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: guestShouldNotBeAbleToVote()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C184F544D46B393F24D191CA693E2188" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Assignment7Test.java의 resetPasswordTest() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment7Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7Test.java</FilePath>
<LineStart>70</LineStart>
<Snippet>  @Test
  @DisplayName("Reset password test")
  void resetPasswordTest() throws Exception {
    ResultActions result =
        mockMvc.perform(MockMvcRequestBuilders.get(RESET_PASSWORD_PATH + "/any"));</Snippet>
<TargetFunction>Function: resetPasswordTest()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5DA414EE0B955FD1392D145E0DFF41C0" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ShopEndpointTest.java의 askForUnknownCouponCode() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ShopEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ShopEndpointTest.java</FilePath>
<LineStart>72</LineStart>
<Snippet>
  @Test
  public void askForUnknownCouponCode() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: askForUnknownCouponCode()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4BE3C9EE056B5CB4A0FCA51385E9655C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HttpBasicsInterceptRequestTest.java의 failure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HttpBasicsInterceptRequestTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/httpproxies/HttpBasicsInterceptRequestTest.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  @Test
  public void failure() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: failure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="28AF48E20D448DA7ACF1B1A6D04D0089" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 invalidLoginWithUnsatisfiedServletRequestParameterExceptionOnUsernameMissing() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>125</LineStart>
<Snippet>  @Test
  @DisplayName("UnsatisfiedServletRequestParameterException test for missing username")
  void invalidLoginWithUnsatisfiedServletRequestParameterExceptionOnUsernameMissing()
      throws Exception {
    mockMvc</Snippet>
<TargetFunction>Function: invalidLoginWithUnsatisfiedServletRequestParameterExceptionOnUsernameMissing()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5D1FF0210D07EECBD0CE2C1DA7116AB1" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 loginShouldNotWorkForTom() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>182</LineStart>
<Snippet>
  @Test
  void loginShouldNotWorkForTom() throws Exception {
    ObjectMapper objectMapper = new ObjectMapper();
</Snippet>
<TargetFunction>Function: loginShouldNotWorkForTom()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="88FD0AF3E76A0A38E4DADE523FC0B809" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson10b.java의 JavaObjectFromString() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson10b.java</FilePath>
<LineStart>138</LineStart>
<Snippet>    private String contents = null;

    public JavaObjectFromString(String className, String contents) throws Exception {
      super(new URI(className), Kind.SOURCE);
      this.contents = contents;</Snippet>
<TargetFunction>Function: JavaObjectFromString()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DD280829C768D268036C6BF7CAB679F3" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 postingWrongAnswerShouldNotPassTheLesson() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>130</LineStart>
<Snippet>
  @Test
  public void postingWrongAnswerShouldNotPassTheLesson() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: postingWrongAnswerShouldNotPassTheLesson()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A3C94E3DC3448AC8A0C763A7D98A2AC5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DeserializeTest.java의 wrongVersion() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DeserializeTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/deserialization/DeserializeTest.java</FilePath>
<LineStart>69</LineStart>
<Snippet>
  @Test
  void wrongVersion() throws Exception {
    String token =
        "rO0ABXNyADFvcmcuZHVtbXkuaW5zZWN1cmUuZnJhbWV3b3JrLlZ1bG5lcmFibGVUYXNrSG9sZGVyAAAAAAAAAAECAANMABZyZXF1ZXN0ZWRFeGVjdXRpb25UaW1ldAAZTGphdmEvdGltZS9Mb2NhbERhdGVUaW1lO0wACnRhc2tBY3Rpb250ABJMamF2YS9sYW5nL1N0cmluZztMAAh0YXNrTmFtZXEAfgACeHBzcgANamF2YS50aW1lLlNlcpVdhLobIkiyDAAAeHB3DgUAAAfjCR4GIQgMLRSoeHQACmVjaG8gaGVsbG90AAhzYXlIZWxsbw";</Snippet>
<TargetFunction>Function: wrongVersion()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A08ACF20B0799230E450F78D3502490E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 tomShouldBeAbleToVote() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>168</LineStart>
<Snippet>
  @Test
  public void tomShouldBeAbleToVote() throws Exception {
    MvcResult result =
        mockMvc</Snippet>
<TargetFunction>Function: tomShouldBeAbleToVote()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C6FF693D079ECD2DE6A4B036576A689" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ClientSideFilteringAssignmentTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ClientSideFilteringAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ClientSideFilteringAssignmentTest.java</FilePath>
<LineStart>27</LineStart>
<Snippet>
  @Test
  public void success() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="46F2BFE9AB9C37BECCAE7D6B06FA3D48" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>VulnerableComponentsLessonTest.java의 testIllegalTransformation() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableComponentsLessonTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLessonTest.java</FilePath>
<LineStart>61</LineStart>
<Snippet>  @Test
  @Disabled
  public void testIllegalTransformation() throws Exception {
    XStream xstream = new XStream();
    xstream.setClassLoader(Contact.class.getClassLoader());</Snippet>
<TargetFunction>Function: testIllegalTransformation()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1A551EF7BDB56019FB690CA209E4CCA0" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson8Test.java의 malformedQueryReturnsError() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8Test.java</FilePath>
<LineStart>97</LineStart>
<Snippet>
  @Test
  public void malformedQueryReturnsError() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: malformedQueryReturnsError()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FDE018D9F27DE0120EBD7E3B32869998" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTSecretKeyEndpointTest.java의 incorrectUser() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpointTest.java</FilePath>
<LineStart>105</LineStart>
<Snippet>
  @Test
  public void incorrectUser() throws Exception {
    Claims claims = createClaims("Tom");
    String token = Jwts.builder().setClaims(claims).signWith(HS512, JWT_SECRET).compact();</Snippet>
<TargetFunction>Function: incorrectUser()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B91D17732D57C89E795888FC8A8B0A6C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 invalidTokenShouldSeeGuestView() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>156</LineStart>
<Snippet>
  @Test
  public void invalidTokenShouldSeeGuestView() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: invalidTokenShouldSeeGuestView()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DA188F3523703B40D26183B283745FBE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ResetLinkAssignmentTest.java의 changePasswordWithoutPasswordShouldReturnPasswordForm() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentTest.java</FilePath>
<LineStart>53</LineStart>
<Snippet>
  @Test
  void changePasswordWithoutPasswordShouldReturnPasswordForm() throws Exception {
    MvcResult mvcResult =
        mockMvc</Snippet>
<TargetFunction>Function: changePasswordWithoutPasswordShouldReturnPasswordForm()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CF1C2238074DD10EC039F0185AB6EB92" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DeserializeTest.java의 checkOtherObject() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DeserializeTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/deserialization/DeserializeTest.java</FilePath>
<LineStart>98</LineStart>
<Snippet>
  @Test
  void checkOtherObject() throws Exception {
    String token =
        "rO0ABXQAVklmIHlvdSBkZXNlcmlhbGl6ZSBtZSBkb3duLCBJIHNoYWxsIGJlY29tZSBtb3JlIHBvd2VyZnVsIHRoYW4geW91IGNhbiBwb3NzaWJseSBpbWFnaW5l";</Snippet>
<TargetFunction>Function: checkOtherObject()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="46E57062F360CFFECF9C807B2351A37D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson8Test.java의 multipleAccounts() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8Test.java</FilePath>
<LineStart>54</LineStart>
<Snippet>
  @Test
  public void multipleAccounts() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: multipleAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="438DF2F936AD2AF46AB06AC271F67B20" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Assignment1Test.java의 wrongPassword() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment1Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java</FilePath>
<LineStart>72</LineStart>
<Snippet>
  @Test
  void wrongPassword() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongPassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6A9FF5B8BB39408C78E3E897B37CB04D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6bTest.java의 submitWrongPassword() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6bTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6bTest.java</FilePath>
<LineStart>46</LineStart>
<Snippet>
  @Test
  public void submitWrongPassword() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: submitWrongPassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2A7425FC6984AAF7E7DAEA5867004B26" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 noTokenWhileCheckoutShouldReturn401() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>252</LineStart>
<Snippet>
  @Test
  void noTokenWhileCheckoutShouldReturn401() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/JWT/refresh/checkout"))</Snippet>
<TargetFunction>Function: noTokenWhileCheckoutShouldReturn401()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F4BBD847AC085C17B3E6C5C37C3E3780" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson10Test.java의 tableExistsIsFailure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10Test.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  @Test
  public void tableExistsIsFailure() throws Exception {
    try {
      mockMvc</Snippet>
<TargetFunction>Function: tableExistsIsFailure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C248045F27800F95CE7511A24EBD223B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadRetrievalTest.java의 unknownFileShouldGiveDirectoryContents() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrievalTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrievalTest.java</FilePath>
<LineStart>78</LineStart>
<Snippet>
  @Test
  public void unknownFileShouldGiveDirectoryContents() throws Exception {
    mockMvc
        .perform(get("/PathTraversal/random-picture?id=test"))</Snippet>
<TargetFunction>Function: unknownFileShouldGiveDirectoryContents()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1156BDFD64CCECD0AF28A0ED2E8A0BE9" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderJKUEndpointTest.java의 shouldFailNotPresent() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderJKUEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpointTest.java</FilePath>
<LineStart>68</LineStart>
<Snippet>  @Test
  @DisplayName("When JWKS is not present in WebWolf then the call should fail")
  void shouldFailNotPresent() throws Exception {
    var token = createTokenAndSignIt();
</Snippet>
<TargetFunction>Function: shouldFailNotPresent()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="63247BBFA97A230D8DC5ED1ECC50F572" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlOnlyInputValidationOnKeywordsTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidationOnKeywordsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywordsTest.java</FilePath>
<LineStart>15</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="41952675550F1B8EA87D6AE5B72D1BCC" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6aTest.java의 correctSolution() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6aTest.java</FilePath>
<LineStart>79</LineStart>
<Snippet>
  @Test
  public void correctSolution() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: correctSolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CCD11CD3823618F8532C0B7F31E3899E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>WebSecurityConfig.java의 authenticationManager() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java</FilePath>
<LineStart>105</LineStart>
<Snippet>
  @Bean
  public AuthenticationManager authenticationManager(
      AuthenticationConfiguration authenticationConfiguration) throws Exception {
    return authenticationConfiguration.getAuthenticationManager();</Snippet>
<TargetFunction>Function: authenticationManager()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EF4E2C86F910E37F168C4D38783EBF0A" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 unknownUserShouldSeeGuestView() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>241</LineStart>
<Snippet>
  @Test
  public void unknownUserShouldSeeGuestView() throws Exception {
    Claims claims = Jwts.claims();
    claims.put("admin", "true");</Snippet>
<TargetFunction>Function: unknownUserShouldSeeGuestView()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="68BB6A31603677AB1720A8C278FB66B4" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 validCommentMustBeAdded() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>59</LineStart>
<Snippet>
  @Test
  public void validCommentMustBeAdded() throws Exception {
    int nrOfComments = countComments();
    mockMvc</Snippet>
<TargetFunction>Function: validCommentMustBeAdded()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FD837A58968BC8C36007D5D34A226AD1" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderKIDEndpointTest.java의 withJerrysKeyShouldNotSolveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderKIDEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpointTest.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
  @Test
  public void withJerrysKeyShouldNotSolveAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: withJerrysKeyShouldNotSolveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9C272A54D3067BAA43BA98D32E4B2DC5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlOnlyInputValidationTest.java의 containsSpace() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationTest.java</FilePath>
<LineStart>28</LineStart>
<Snippet>
  @Test
  public void containsSpace() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: containsSpace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="276A748FECD60C2439D4A0E81F6C8A77" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>WebSecurityConfig.java의 configureGlobal() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java</FilePath>
<LineStart>86</LineStart>
<Snippet>
  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(userDetailsService);
  }</Snippet>
<TargetFunction>Function: configureGlobal()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="92D8203825DF8F50AF2C8332F7C6E0C6" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson8Test.java의 wrongNameReturnsNoAccounts() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8Test.java</FilePath>
<LineStart>71</LineStart>
<Snippet>
  @Test
  public void wrongNameReturnsNoAccounts() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongNameReturnsNoAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8E01B49C01FE4FD8D239D50BB602242E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadRetrievalTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrievalTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrievalTest.java</FilePath>
<LineStart>33</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    // Look at the response
    mockMvc</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EBE5301FE9EE562916684326D13E0636" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DeserializeTest.java의 fail() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DeserializeTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/deserialization/DeserializeTest.java</FilePath>
<LineStart>57</LineStart>
<Snippet>
  @Test
  void fail() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: fail()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="863A677F29F5F6BDB748019AFA18B5B8" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MavenWrapperDownloader.java의 downloadFileFromURL() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>97</LineStart>
<Snippet>    }

    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv("MVNW_USERNAME") != null &amp;&amp; System.getenv("MVNW_PASSWORD") != null) {
            String username = System.getenv("MVNW_USERNAME");</Snippet>
<TargetFunction>Function: downloadFileFromURL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C677DBBD2D50B3FE1EFDE5249BEAB62" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson8Test.java의 wrongTANReturnsNoAccounts() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8Test.java</FilePath>
<LineStart>84</LineStart>
<Snippet>
  @Test
  public void wrongTANReturnsNoAccounts() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongTANReturnsNoAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C61D28A0E5903340A47703AB9C3E0AC" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson9Test.java의 malformedQueryReturnsError() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9Test.java</FilePath>
<LineStart>159</LineStart>
<Snippet>
  @Test
  public void malformedQueryReturnsError() throws Exception {
    try {
      mockMvc</Snippet>
<TargetFunction>Function: malformedQueryReturnsError()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9F415933D7817A058670B259DA7FB77F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>WebSecurityConfig.java의 filterChain() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java</FilePath>
<LineStart>49</LineStart>
<Snippet>
  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http.authorizeHttpRequests(
            auth -&gt; {</Snippet>
<TargetFunction>Function: filterChain()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8496D07C18CA0BA842D183E638A2CFBA" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ContentTypeAssignmentTest.java의 countComments() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignmentTest.java</FilePath>
<LineStart>101</LineStart>
<Snippet>  }

  private int countComments() throws Exception {
    var response =
        mockMvc</Snippet>
<TargetFunction>Function: countComments()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C118974BDC79447DBF88D500B1FEBDF4" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadFixTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadFixTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFixTest.java</FilePath>
<LineStart>26</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    var profilePicture =
        new MockMultipartFile(</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="ED7F9CC04F79C681E5D21523C1F7D79D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DeserializeTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DeserializeTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/deserialization/DeserializeTest.java</FilePath>
<LineStart>33</LineStart>
<Snippet>
  @Test
  void success() throws Exception {
    if (OS.indexOf("win") &gt; -1) {
      mockMvc</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4A555B9CEFB6FE1F5AFAA807741FC14B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HintServiceTest.java의 hintsPerAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HintServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/container/service/HintServiceTest.java</FilePath>
<LineStart>37</LineStart>
<Snippet>
  @Test
  void hintsPerAssignment() throws Exception {
    Assignment assignment = Mockito.mock(Assignment.class);
    when(assignment.getPath()).thenReturn("/HttpBasics/attack1");</Snippet>
<TargetFunction>Function: hintsPerAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7899B79620BD9C0C80421E2FF4E3B25F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>WebSecurityConfig.java의 authenticationManager() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java</FilePath>
<LineStart>96</LineStart>
<Snippet>
  @Bean
  public AuthenticationManager authenticationManager(
      AuthenticationConfiguration authenticationConfiguration) throws Exception {
    return authenticationConfiguration.getAuthenticationManager();</Snippet>
<TargetFunction>Function: authenticationManager()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D961B4BB0924EB73C7C6AF8B2C6D521E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 wrongXmlShouldGiveErrorBack() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>72</LineStart>
<Snippet>
  @Test
  public void wrongXmlShouldGiveErrorBack() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongXmlShouldGiveErrorBack()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="907BDE6B943F5A94340A18D1885D7763" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderJKUEndpointTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderJKUEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpointTest.java</FilePath>
<LineStart>56</LineStart>
<Snippet>
  @Test
  void solve() throws Exception {
    setupJsonWebKeySetInWebWolf();
    var token = createTokenAndSignIt();</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B2DF94B62A50A1984C98B2073D3D1207" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>VulnerableComponentsLessonTest.java의 testIllegalPayload() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableComponentsLessonTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLessonTest.java</FilePath>
<LineStart>74</LineStart>
<Snippet>
  @Test
  public void testIllegalPayload() throws Exception {
    XStream xstream = new XStream();
    xstream.setClassLoader(Contact.class.getClassLoader());</Snippet>
<TargetFunction>Function: testIllegalPayload()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FF4EE4D8366FEC2D91C63DEEF61AD899" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DisplayUser.java의 genUserHash() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DisplayUser.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/DisplayUser.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  }

  protected String genUserHash(String username, String password, String passwordSalt)
      throws Exception {
    MessageDigest md = MessageDigest.getInstance("SHA-256");</Snippet>
<TargetFunction>Function: genUserHash()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C9E1B148A1AAD1ED2C8B4106E26CBF3B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 checkoutWitRandomTokenShouldFail() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>131</LineStart>
<Snippet>
  @Test
  void checkoutWitRandomTokenShouldFail() throws Exception {
    String accessTokenTom =
        "eyJhbGciOiJIUzUxMiJ9.eyJpLXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q";</Snippet>
<TargetFunction>Function: checkoutWitRandomTokenShouldFail()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DA16E029FFE60BA742B63B6988712EFB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5Test.java의 noGrantShouldNotSolveIt() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5Test.java</FilePath>
<LineStart>70</LineStart>
<Snippet>
  @Test
  public void noGrantShouldNotSolveIt() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: noGrantShouldNotSolveIt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9B411821EBBB502D27F8324A99BC2783" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson9Test.java의 multipleAccounts() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9Test.java</FilePath>
<LineStart>70</LineStart>
<Snippet>
  @Test
  public void multipleAccounts() throws Exception {
    try {
      mockMvc</Snippet>
<TargetFunction>Function: multipleAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D323E6DFD319C91F128CAB12FB22B85F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HijackSessionAssignmentTest.java의 testBlankCookie() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HijackSessionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignmentTest.java</FilePath>
<LineStart>96</LineStart>
<Snippet>
  @Test
  void testBlankCookie() throws Exception {
    ResultActions result =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: testBlankCookie()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F637AF09F60D875275D8D2F37DFCDD9C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>73</LineStart>
<Snippet>  @Test
  @DisplayName("Lesson completed")
  void success() throws Exception {
    Cookie cookie = new Cookie(COOKIE_NAME, "NjI2MTcwNGI3YTQxNGE1OTU2NzQ2ZDZmNzQ=");
</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3C17874B98713E71533FA3EB09A6A24F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson9Test.java의 wrongTANReturnsNoAccounts() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9Test.java</FilePath>
<LineStart>132</LineStart>
<Snippet>
  @Test
  public void wrongTANReturnsNoAccounts() throws Exception {
    try {
      mockMvc</Snippet>
<TargetFunction>Function: wrongTANReturnsNoAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1F0168F042B3097831F3FE5722EDDBA9" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>VulnerableComponentsLessonTest.java의 testTransformation() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableComponentsLessonTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLessonTest.java</FilePath>
<LineStart>51</LineStart>
<Snippet>
  @Test
  public void testTransformation() throws Exception {
    XStream xstream = new XStream();
    xstream.setClassLoader(Contact.class.getClassLoader());</Snippet>
<TargetFunction>Function: testTransformation()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A17E16BB30569D130EF2D49F219241D8" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 countComments() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>42</LineStart>
<Snippet>  }

  private int countComments() throws Exception {
    var response =
        mockMvc</Snippet>
<TargetFunction>Function: countComments()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C9E0301E605426BF77B40ACC3E346AF8" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 falseShouldSortById() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>96</LineStart>
<Snippet>
  @Test
  public void falseShouldSortById() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: falseShouldSortById()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B2328A990A2D125E3143A745B621DE87" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 performXXE() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>165</LineStart>
<Snippet>  }

  private void performXXE(String xml) throws Exception {
    // Call with XXE injection
    mockMvc</Snippet>
<TargetFunction>Function: performXXE()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FC43962E442E9258FB1C2531D1C6740C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 cookieLoginNotSolvedFlow() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>112</LineStart>
<Snippet>          + "2.- Valid cookie login (not tom) sent. "
          + "3.- Valid cookie with not known username sent ")
  void cookieLoginNotSolvedFlow(String cookieValue) throws Exception {
    Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
    mockMvc</Snippet>
<TargetFunction>Function: cookieLoginNotSolvedFlow()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9A29C307B6824DC503E1569463667B5F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ContentTypeAssignmentTest.java의 workingAttack() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignmentTest.java</FilePath>
<LineStart>69</LineStart>
<Snippet>
  @Test
  public void workingAttack() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: workingAttack()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="89819C5C7645BF888081B4C2E95F3BCD" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SimpleXXETest.java의 postingPlainTextShouldThrowException() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleXXETest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/SimpleXXETest.java</FilePath>
<LineStart>90</LineStart>
<Snippet>
  @Test
  public void postingPlainTextShouldThrowException() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/xxe/simple").content("test"))</Snippet>
<TargetFunction>Function: postingPlainTextShouldThrowException()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C558D8B526E3950FAD944EC75EF4BAEA" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DeserializeTest.java의 expiredTask() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DeserializeTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/deserialization/DeserializeTest.java</FilePath>
<LineStart>84</LineStart>
<Snippet>
  @Test
  void expiredTask() throws Exception {
    String token =
        "rO0ABXNyADFvcmcuZHVtbXkuaW5zZWN1cmUuZnJhbWV3b3JrLlZ1bG5lcmFibGVUYXNrSG9sZGVyAAAAAAAAAAICAANMABZyZXF1ZXN0ZWRFeGVjdXRpb25UaW1ldAAZTGphdmEvdGltZS9Mb2NhbERhdGVUaW1lO0wACnRhc2tBY3Rpb250ABJMamF2YS9sYW5nL1N0cmluZztMAAh0YXNrTmFtZXEAfgACeHBzcgANamF2YS50aW1lLlNlcpVdhLobIkiyDAAAeHB3DgUAAAfjCR4IDC0YfvNIeHQACmVjaG8gaGVsbG90AAhzYXlIZWxsbw";</Snippet>
<TargetFunction>Function: expiredTask()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="38F78C5157C09FB4648B0296F4E92C93" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 addressIncorrectShouldOrderByIdUsingSubstr() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>72</LineStart>
<Snippet>
  @Test
  public void addressIncorrectShouldOrderByIdUsingSubstr() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: addressIncorrectShouldOrderByIdUsingSubstr()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="986FD9F71045C158D91B17A80993955C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MailboxControllerTest.java의 userShouldBeAbleToReadOwnEmail() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MailboxControllerTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/mailbox/MailboxControllerTest.java</FilePath>
<LineStart>93</LineStart>
<Snippet>  @Test
  @WithMockUser(username = "test1234")
  public void userShouldBeAbleToReadOwnEmail() throws Exception {
    Email email =
        Email.builder()</Snippet>
<TargetFunction>Function: userShouldBeAbleToReadOwnEmail()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="55072E49CB5EF46D5DC91F95B6099BAE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BypassRestrictionsFrontendValidationTest.java의 notBypassingAllFieldShouldNotPass() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BypassRestrictionsFrontendValidationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/bypassrestrictions/BypassRestrictionsFrontendValidationTest.java</FilePath>
<LineStart>61</LineStart>
<Snippet>
  @Test
  void notBypassingAllFieldShouldNotPass() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: notBypassingAllFieldShouldNotPass()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1F796557B3C495389EB976FFD132DE14" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson9Test.java의 wrongNameReturnsNoAccounts() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9Test.java</FilePath>
<LineStart>105</LineStart>
<Snippet>
  @Test
  public void wrongNameReturnsNoAccounts() throws Exception {
    try {
      mockMvc</Snippet>
<TargetFunction>Function: wrongNameReturnsNoAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5849C0F1239BADB0634D07F22662781B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Assignment1Test.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment1Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java</FilePath>
<LineStart>55</LineStart>
<Snippet>
  @Test
  void success() throws Exception {
    InetAddress addr = InetAddress.getLocalHost();
    String host = addr.getHostAddress();</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9F29F57FFF50E8AE8F85052CF0ADF0BD" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 trueShouldSortByHostname() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>85</LineStart>
<Snippet>
  @Test
  public void trueShouldSortByHostname() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: trueShouldSortByHostname()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6E8659BEF638FC7E7D8076B1ED4A4BDE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MailboxControllerTest.java의 sendingMailShouldStoreIt() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MailboxControllerTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/mailbox/MailboxControllerTest.java</FilePath>
<LineStart>73</LineStart>
<Snippet>
  @Test
  public void sendingMailShouldStoreIt() throws Exception {
    Email email =
        Email.builder()</Snippet>
<TargetFunction>Function: sendingMailShouldStoreIt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="26D61656218CB20F58156B848124C123" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>LessonMenuServiceTest.java의 lessonCompleted() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LessonMenuServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/container/service/LessonMenuServiceTest.java</FilePath>
<LineStart>95</LineStart>
<Snippet>
  @Test
  void lessonCompleted() throws Exception {
    Lesson l1 = Mockito.mock(Lesson.class);
    when(l1.getTitle()).thenReturn("ZA");</Snippet>
<TargetFunction>Function: lessonCompleted()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E58D81E9EBB39CEF47B2EFE87E8DEFD2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>LessonProgressServiceTest.java의 jsonLessonOverview() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LessonProgressServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/container/service/LessonProgressServiceTest.java</FilePath>
<LineStart>82</LineStart>
<Snippet>
  @Test
  void jsonLessonOverview() throws Exception {
    this.mockMvc
        .perform(</Snippet>
<TargetFunction>Function: jsonLessonOverview()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="96AA53ECA79CDCE727AEF59B5682B6AB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTDecodeEndpointTest.java의 wrongUserShouldNotSolveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTDecodeEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTDecodeEndpointTest.java</FilePath>
<LineStart>32</LineStart>
<Snippet>
  @Test
  public void wrongUserShouldNotSolveAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongUserShouldNotSolveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BDC57CB9F44147162E226B57BCB52E7E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>StoredXssCommentsTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>StoredXssCommentsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/StoredXssCommentsTest.java</FilePath>
<LineStart>55</LineStart>
<Snippet>
  @Test
  public void success() throws Exception {
    ResultActions results =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FD15C50051A72954561D1376A4FA55F5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACYourHashAdminTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACYourHashAdminTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACYourHashAdminTest.java</FilePath>
<LineStart>24</LineStart>
<Snippet>
  @Test
  void solve() throws Exception {
    var userHash =
        new DisplayUser(new User("Jerry", "doesnotreallymatter", true), PASSWORD_SALT_ADMIN)</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0B46601DAC12E486350B6CF4EEE1D1D6" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadRemoveUserInputTest.java의 normalUpdate() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRemoveUserInputTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInputTest.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  @Test
  public void normalUpdate() throws Exception {
    var profilePicture =
        new MockMultipartFile(</Snippet>
<TargetFunction>Function: normalUpdate()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AAEDBBFFBF864B553C35972246E003A2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5aTest.java의 sqlInjectionWrongShouldDisplayError() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5aTest.java</FilePath>
<LineStart>81</LineStart>
<Snippet>
  @Test
  public void sqlInjectionWrongShouldDisplayError() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: sqlInjectionWrongShouldDisplayError()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AEAC83CA2B0891008E8B0DE4C18BD467" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTSecretKeyEndpointTest.java의 oneOfClaimIsMissingShouldNotSolveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpointTest.java</FilePath>
<LineStart>91</LineStart>
<Snippet>
  @Test
  public void oneOfClaimIsMissingShouldNotSolveAssignment() throws Exception {
    Claims claims = createClaims("WebGoat");
    claims.remove("aud");</Snippet>
<TargetFunction>Function: oneOfClaimIsMissingShouldNotSolveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8DA298AA3333535E9D9814472282CDB4" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BypassRestrictionsFrontendValidationTest.java의 bypassAllFieldShouldPass() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BypassRestrictionsFrontendValidationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/bypassrestrictions/BypassRestrictionsFrontendValidationTest.java</FilePath>
<LineStart>44</LineStart>
<Snippet>
  @Test
  void bypassAllFieldShouldPass() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: bypassAllFieldShouldPass()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8BB43B5EE12050FA67F27EC2F12DC2A7" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 allAnswersFalseGetResultsReturnsFalseFalseFalseFalse() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>191</LineStart>
<Snippet>
  @Test
  public void allAnswersFalseGetResultsReturnsFalseFalseFalseFalse() throws Exception {
    String[] solution0 = {"Solution 1"};
    String[] solution1 = {"Solution 2"};</Snippet>
<TargetFunction>Function: allAnswersFalseGetResultsReturnsFalseFalseFalseFalse()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6EC987110E383A342A61F1CABF6D592B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ResetLinkAssignmentTest.java의 changePasswordWithoutLinkShouldReturnPasswordLinkNotFound() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentTest.java</FilePath>
<LineStart>65</LineStart>
<Snippet>
  @Test
  void changePasswordWithoutLinkShouldReturnPasswordLinkNotFound() throws Exception {
    MvcResult mvcResult =
        mockMvc</Snippet>
<TargetFunction>Function: changePasswordWithoutLinkShouldReturnPasswordLinkNotFound()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9AD9DDE48D59CB8E1B046586E53499E6" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6aTest.java의 noResultsReturned() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6aTest.java</FilePath>
<LineStart>90</LineStart>
<Snippet>
  @Test
  public void noResultsReturned() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: noResultsReturned()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="93DC7693DB4BFC2CD70340E9FEC1585E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTDecodeEndpointTest.java의 solveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTDecodeEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTDecodeEndpointTest.java</FilePath>
<LineStart>23</LineStart>
<Snippet>
  @Test
  public void solveAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: solveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="53DE17BD01767160243465789D518A3D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 noTokenWhileRequestingNewTokenShouldReturn401() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>259</LineStart>
<Snippet>
  @Test
  void noTokenWhileRequestingNewTokenShouldReturn401() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/JWT/refresh/newToken"))</Snippet>
<TargetFunction>Function: noTokenWhileRequestingNewTokenShouldReturn401()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2747AF64BFA037AF56348294AE6F81D2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>WebSecurityConfig.java의 filterChain() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java</FilePath>
<LineStart>56</LineStart>
<Snippet>
  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http.authorizeHttpRequests(
            auth -&gt;</Snippet>
<TargetFunction>Function: filterChain()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="985A57AC744500D7CD26E61017A990B9" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 solveAssignmentWithBoolean() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>76</LineStart>
<Snippet>
  @Test
  public void solveAssignmentWithBoolean() throws Exception {
    // Create new token and set alg to none and do not sign it
    Claims claims = Jwts.claims();</Snippet>
<TargetFunction>Function: solveAssignmentWithBoolean()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="422F3304B79AA4B6878F8844E465FD77" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 addressCorrectShouldOrderByHostname() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>26</LineStart>
<Snippet>
  @Test
  public void addressCorrectShouldOrderByHostname() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: addressCorrectShouldOrderByHostname()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2C2B80333E5B177D7D68537D7B1927E7" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionYourHashTest.java의 hashDoesNotMatch() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionYourHashTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionYourHashTest.java</FilePath>
<LineStart>45</LineStart>
<Snippet>
  @Test
  void hashDoesNotMatch() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/access-control/user-hash").param("userHash", "42"))</Snippet>
<TargetFunction>Function: hashDoesNotMatch()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="818BFD90545E6AD1A9F68C3FDACC4DC9" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SSRFTest2.java의 modifyUrlCat() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTest2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/ssrf/SSRFTest2.java</FilePath>
<LineStart>60</LineStart>
<Snippet>
  @Test
  public void modifyUrlCat() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/SSRF/task2").param("url", "images/cat.jpg"))</Snippet>
<TargetFunction>Function: modifyUrlCat()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5759DADFC057EDE4303F05F0DD686F6C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SSRFTest2.java의 modifyUrlIfconfigPro() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTest2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/ssrf/SSRFTest2.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
  @Test
  public void modifyUrlIfconfigPro() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/SSRF/task2").param("url", "http://ifconfig.pro"))</Snippet>
<TargetFunction>Function: modifyUrlIfconfigPro()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C3C4731CC854D23BFE7CB2FDB03E118" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>100</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AD7736DF0ADAADC8070EDCADCF0D5446" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 invalidLoginWithUnsatisfiedServletRequestParameterExceptionOnPasswordMissing() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>134</LineStart>
<Snippet>  @Test
  @DisplayName("UnsatisfiedServletRequestParameterException test for missing password")
  void invalidLoginWithUnsatisfiedServletRequestParameterExceptionOnPasswordMissing()
      throws Exception {
    mockMvc</Snippet>
<TargetFunction>Function: invalidLoginWithUnsatisfiedServletRequestParameterExceptionOnPasswordMissing()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="28D33DA08CA948B5C5C1E367EEAAA8CC" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5Test.java의 differentTableShouldNotSolveIt() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5Test.java</FilePath>
<LineStart>60</LineStart>
<Snippet>
  @Test
  public void differentTableShouldNotSolveIt() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: differentTableShouldNotSolveIt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EA543391176E59EBBE0813E1FEA8B465" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadTest.java의 shouldNotOverrideExistingFile() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadTest.java</FilePath>
<LineStart>59</LineStart>
<Snippet>
  @Test
  public void shouldNotOverrideExistingFile() throws Exception {
    var profilePicture =
        new MockMultipartFile("uploadedFile", "picture.jpg", "text/plain", "an image".getBytes());</Snippet>
<TargetFunction>Function: shouldNotOverrideExistingFile()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AF4997185218D34FFBA865E0DB3CD5AB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadTest.java</FilePath>
<LineStart>26</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    var profilePicture =
        new MockMultipartFile(</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="363B2AB3EBF822502B5AAFAF399C924F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SimpleXXETest.java의 postingJsonCommentShouldNotSolveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleXXETest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/SimpleXXETest.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  @Test
  public void postingJsonCommentShouldNotSolveAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: postingJsonCommentShouldNotSolveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3B81755AFAC016DC1E6A1BD66EF1DFA0" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SimpleXXETest.java의 postingXmlCommentWithoutXXEShouldNotSolveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleXXETest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/SimpleXXETest.java</FilePath>
<LineStart>77</LineStart>
<Snippet>
  @Test
  public void postingXmlCommentWithoutXXEShouldNotSolveAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: postingXmlCommentWithoutXXEShouldNotSolveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="84FE10FA6969FE2DBEC005BB9E970BFB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACHiddenMenusTest.java의 HiddenMenusClose() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACHiddenMenusTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACHiddenMenusTest.java</FilePath>
<LineStart>64</LineStart>
<Snippet>
  @Test
  public void HiddenMenusClose() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: HiddenMenusClose()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CE2F3795871678D766FFF70B0128B0F4" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ContentTypeAssignmentTest.java의 sendingXmlButContentTypeIsJson() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignmentTest.java</FilePath>
<LineStart>53</LineStart>
<Snippet>
  @Test
  public void sendingXmlButContentTypeIsJson() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: sendingXmlButContentTypeIsJson()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A10D4E45A76D4320FC638B25300949D1" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DOMCrossSiteScriptingTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DOMCrossSiteScriptingTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/DOMCrossSiteScriptingTest.java</FilePath>
<LineStart>54</LineStart>
<Snippet>
  @Test
  public void success() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3B44A7C11C06F993ABDC90EAF035BD26" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ReportCardServiceTest.java의 withLessons() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ReportCardServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/container/service/ReportCardServiceTest.java</FilePath>
<LineStart>51</LineStart>
<Snippet>  @Test
  @WithMockUser(username = "guest", password = "guest")
  void withLessons() throws Exception {
    when(lesson.getTitle()).thenReturn("Test");
    when(course.getTotalOfLessons()).thenReturn(1);</Snippet>
<TargetFunction>Function: withLessons()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="14B844DF49812845BFD10B3BED03B8D3" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 solveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>58</LineStart>
<Snippet>
  @Test
  public void solveAssignment() throws Exception {
    // Create new token and set alg to none and do not sign it
    Claims claims = Jwts.claims();</Snippet>
<TargetFunction>Function: solveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2D99C3A844B9D591125040F9E9757113" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionYourHashTest.java의 hashMatches() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionYourHashTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionYourHashTest.java</FilePath>
<LineStart>53</LineStart>
<Snippet>
  @Test
  void hashMatches() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: hashMatches()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F3765805E5A8255A99CFADDA0040D0F1" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Assignment7Test.java의 gitTest() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment7Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7Test.java</FilePath>
<LineStart>95</LineStart>
<Snippet>  @Test
  @DisplayName("git test")
  void gitTest() throws Exception {
    ResultActions result = mockMvc.perform(MockMvcRequestBuilders.get(GIT_PATH));
    result.andExpect(content().contentType("application/zip"));</Snippet>
<TargetFunction>Function: gitTest()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0A90F0E44679AF5A068C6DB3A1E2E2B6" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ResetLinkAssignmentTest.java의 wrongResetLink() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentTest.java</FilePath>
<LineStart>40</LineStart>
<Snippet>
  @Test
  void wrongResetLink() throws Exception {
    MvcResult mvcResult =
        mockMvc</Snippet>
<TargetFunction>Function: wrongResetLink()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CCCFF24712204B59C456F0A636419B9E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTSecretKeyEndpointTest.java의 solveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpointTest.java</FilePath>
<LineStart>69</LineStart>
<Snippet>
  @Test
  public void solveAssignment() throws Exception {
    Claims claims = createClaims("WebGoat");
    String token = Jwts.builder().setClaims(claims).signWith(HS512, JWT_SECRET).compact();</Snippet>
<TargetFunction>Function: solveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FEE1D85923F0FB52B3395C3CFDAC9449" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson10Test.java의 tableMissingIsSuccess() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10Test.java</FilePath>
<LineStart>61</LineStart>
<Snippet>
  @Test
  public void tableMissingIsSuccess() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: tableMissingIsSuccess()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="94B0B618D0354DA90B52191F050FA3BE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderKIDEndpointTest.java의 shouldNotBeAbleToBypassWithSimpleToken() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderKIDEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpointTest.java</FilePath>
<LineStart>63</LineStart>
<Snippet>
  @Test
  public void shouldNotBeAbleToBypassWithSimpleToken() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: shouldNotBeAbleToBypassWithSimpleToken()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C3E1B65C253D55727CF0A5A4B4A902DF" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MailboxControllerTest.java의 differentUserShouldNotBeAbleToReadOwnEmail() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MailboxControllerTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/mailbox/MailboxControllerTest.java</FilePath>
<LineStart>119</LineStart>
<Snippet>  @Test
  @WithMockUser(username = "test1233")
  public void differentUserShouldNotBeAbleToReadOwnEmail() throws Exception {
    Email email =
        Email.builder()</Snippet>
<TargetFunction>Function: differentUserShouldNotBeAbleToReadOwnEmail()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CF3A6E99B68355BEB610249D5F7DE5D8" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadFixTest.java의 normalUpdate() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadFixTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFixTest.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  @Test
  public void normalUpdate() throws Exception {
    var profilePicture =
        new MockMultipartFile(</Snippet>
<TargetFunction>Function: normalUpdate()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B73F6E27DEFDE5D91BBBACFA2934D563" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SecurityQuestionAssignmentTest.java의 oneQuestionShouldNotSolveTheAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityQuestionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/SecurityQuestionAssignmentTest.java</FilePath>
<LineStart>30</LineStart>
<Snippet>
  @Test
  public void oneQuestionShouldNotSolveTheAssignment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: oneQuestionShouldNotSolveTheAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FE229CD940CC8C0F74235469E92ED9A2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 flowForJerryAlwaysWorks() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>144</LineStart>
<Snippet>
  @Test
  void flowForJerryAlwaysWorks() throws Exception {
    ObjectMapper objectMapper = new ObjectMapper();
</Snippet>
<TargetFunction>Function: flowForJerryAlwaysWorks()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F030942ADDC71C1DBDB400DAF9C71DE1" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 resetWithoutTokenShouldNotWork() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>94</LineStart>
<Snippet>
  @Test
  public void resetWithoutTokenShouldNotWork() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: resetWithoutTokenShouldNotWork()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4E6A814D2D0B16C74405163EEE08D077" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 allAnswersWrongIsFailure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>101</LineStart>
<Snippet>
  @Test
  public void allAnswersWrongIsFailure() throws Exception {
    String[] solution0 = {"Solution 2"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: allAnswersWrongIsFailure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D2ED30375DEC7A552C0C757FB4D75C5B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionChallenge.java의 registerNewUser() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  // assignment path is bounded to class so we use different http method :-)
  @ResponseBody
  public AttackResult registerNewUser(
      @RequestParam String username_reg,
      @RequestParam String email_reg,</Snippet>
<TargetFunction>Function: registerNewUser()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7CF13D66D4AEDFA40697C4F7E8AE15FB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SSRFTest1.java의 modifyUrlTom() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTest1.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/ssrf/SSRFTest1.java</FilePath>
<LineStart>30</LineStart>
<Snippet>
  @Test
  public void modifyUrlTom() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/SSRF/task1").param("url", "images/tom.png"))</Snippet>
<TargetFunction>Function: modifyUrlTom()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="37BA0791BC2EFA364E51D47F9804FB7A" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 guestShouldNotGetAToken() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>104</LineStart>
<Snippet>
  @Test
  public void guestShouldNotGetAToken() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: guestShouldNotGetAToken()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BB3C20383EE3F93B75D22E4C6A62E3C9" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACUsersTest.java의 getUsers() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACUsersTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsersTest.java</FilePath>
<LineStart>46</LineStart>
<Snippet>
  @Test
  void getUsers() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: getUsers()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8DC3D95EE68DD3B342C96FEFEE0103C5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 invalidTomLogin() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>179</LineStart>
<Snippet>  @Test
  @DisplayName("Invalid login with tom username")
  void invalidTomLogin() throws Exception {
    ResultActions result =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: invalidTomLogin()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AB0220D79104A57E285E9B839E9B43B5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Assignment7Test.java의 sendPasswordResetLinkTest() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment7Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7Test.java</FilePath>
<LineStart>84</LineStart>
<Snippet>  @Test
  @DisplayName("Send password reset link test")
  void sendPasswordResetLinkTest() throws Exception {
    ResultActions result =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: sendPasswordResetLinkTest()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8D781CB45989FB2927086787BB226F22" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CrossSiteScriptingLesson1Test.java의 failure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CrossSiteScriptingLesson1Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson1Test.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  @Test
  void failure() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post(CONTEXT_PATH))</Snippet>
<TargetFunction>Function: failure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9B7702CA30983D2350E2DDDEEA6E07FB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SecurityQuestionAssignmentTest.java의 solvingForOneUserDoesNotSolveForOtherUser() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityQuestionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/SecurityQuestionAssignmentTest.java</FilePath>
<LineStart>91</LineStart>
<Snippet>
  @Test
  public void solvingForOneUserDoesNotSolveForOtherUser() throws Exception {
    MockHttpSession mocksession = new MockHttpSession();
    mockMvc.perform(</Snippet>
<TargetFunction>Function: solvingForOneUserDoesNotSolveForOtherUser()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5F0A52F68AF773511D709C904B3F1CED" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 eraseAuthenticationCookie() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>191</LineStart>
<Snippet>  @Test
  @DisplayName("Erase authentication cookie")
  void eraseAuthenticationCookie() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get(ERASE_COOKIE_CONTEXT_PATH))</Snippet>
<TargetFunction>Function: eraseAuthenticationCookie()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="91F2E143F572B4C622A0BCF3CEE11366" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Assignment5.java의 login() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java</FilePath>
<LineStart>49</LineStart>
<Snippet>  @PostMapping("/challenge/5")
  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {</Snippet>
<TargetFunction>Function: login()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7841EE100AF0DF12B2D753D141422DB4" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ChromeDevToolsTest.java의 NetworkAssignmentTest_Fail() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ChromeDevToolsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/chromedevtools/ChromeDevToolsTest.java</FilePath>
<LineStart>41</LineStart>
<Snippet>
  @Test
  public void NetworkAssignmentTest_Fail() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: NetworkAssignmentTest_Fail()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="466FC5C1E132353BADD25A0CE1314F05" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 threeAnswersWrongIsFailure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>83</LineStart>
<Snippet>
  @Test
  public void threeAnswersWrongIsFailure() throws Exception {
    String[] solution0 = {"Solution 1"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: threeAnswersWrongIsFailure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4752A8753960B5F24BB579B76F56A91D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACYourHashAdminTest.java의 wrongUserHash() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACYourHashAdminTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACYourHashAdminTest.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  @Test
  void wrongUserHash() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongUserHash()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="ACD2E5F461C90F9D7E7EC42064059091" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6aTest.java의 wrongNumberOfColumns() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6aTest.java</FilePath>
<LineStart>47</LineStart>
<Snippet>
  @Test
  public void wrongNumberOfColumns() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongNumberOfColumns()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6281CE0F5EDB039A5776B6A760E1BA66" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 addressIncorrectShouldOrderByHostname() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>107</LineStart>
<Snippet>
  @Test
  public void addressIncorrectShouldOrderByHostname() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: addressIncorrectShouldOrderByHostname()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="46B733334CD1C7D2FCF96E36B0F6524E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BypassRestrictionsFrontendValidationTest.java의 noChangesShouldNotPassTheLesson() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BypassRestrictionsFrontendValidationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/bypassrestrictions/BypassRestrictionsFrontendValidationTest.java</FilePath>
<LineStart>27</LineStart>
<Snippet>
  @Test
  void noChangesShouldNotPassTheLesson() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: noChangesShouldNotPassTheLesson()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1F4DC8DF015609BCF8045B7397B5EAC" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 solveOnlyParamReferenceEntityInExternalDTD() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>133</LineStart>
<Snippet>
  @Test
  public void solveOnlyParamReferenceEntityInExternalDTD() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");</Snippet>
<TargetFunction>Function: solveOnlyParamReferenceEntityInExternalDTD()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C1D654A13F8526C3A6B0647829E0F290" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>WebSecurityConfig.java의 configureGlobal() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java</FilePath>
<LineStart>95</LineStart>
<Snippet>
  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(userDetailsService);
  }</Snippet>
<TargetFunction>Function: configureGlobal()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3E29E030D1475E6D9ECE9A41F7F37479" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HijackSessionAssignmentTest.java의 testValidCookie() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HijackSessionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignmentTest.java</FilePath>
<LineStart>76</LineStart>
<Snippet>
  @Test
  void testValidCookie() throws Exception {
    lenient().when(authenticationMock.isAuthenticated()).thenReturn(true);
    lenient()</Snippet>
<TargetFunction>Function: testValidCookie()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1A8278DF495CC3CD5D3F8D0404751CB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ContentTypeAssignmentTest.java의 postingJsonShouldAddComment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignmentTest.java</FilePath>
<LineStart>83</LineStart>
<Snippet>
  @Test
  public void postingJsonShouldAddComment() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: postingJsonShouldAddComment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2AC3FA126040942BAEFAFA1062BAC82A" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HttpBasicsInterceptRequestTest.java의 missingHeader() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HttpBasicsInterceptRequestTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/httpproxies/HttpBasicsInterceptRequestTest.java</FilePath>
<LineStart>95</LineStart>
<Snippet>
  @Test
  public void missingHeader() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: missingHeader()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="18C11775A04CBDCB90055564999AE3E5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderJKUEndpointTest.java의 generateRsaKey() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderJKUEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpointTest.java</FilePath>
<LineStart>49</LineStart>
<Snippet>  }

  private KeyPair generateRsaKey() throws Exception {
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
    keyPairGenerator.initialize(2048);</Snippet>
<TargetFunction>Function: generateRsaKey()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7F91FA0AC62C95222641C240DA016E02" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5aTest.java의 knownAccountShouldDisplayData() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5aTest.java</FilePath>
<LineStart>38</LineStart>
<Snippet>
  @Test
  public void knownAccountShouldDisplayData() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: knownAccountShouldDisplayData()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7263D8F4E15AF00F5C74ACAD89B425BD" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ClientSideFilteringFreeAssignmentTest.java의 getSalaries() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ClientSideFilteringFreeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ClientSideFilteringFreeAssignmentTest.java</FilePath>
<LineStart>43</LineStart>
<Snippet>
  @Test
  public void getSalaries() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get("/clientSideFiltering/salaries"))</Snippet>
<TargetFunction>Function: getSalaries()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F94E925E030C135A228F0C18BEE990CD" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadTest.java의 normalUpdate() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadTest.java</FilePath>
<LineStart>77</LineStart>
<Snippet>
  @Test
  public void normalUpdate() throws Exception {
    var profilePicture =
        new MockMultipartFile("uploadedFile", "picture.jpg", "text/plain", "an image".getBytes());</Snippet>
<TargetFunction>Function: normalUpdate()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6D08552329EF74761445F12B1323501E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 invalidLoginWithBlankPassword() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>155</LineStart>
<Snippet>  @Test
  @DisplayName("Invalid blank password login")
  void invalidLoginWithBlankPassword() throws Exception {
    ResultActions result =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: invalidLoginWithBlankPassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C1061037FE3D97581C5D38A85EF50163" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 oneAnswerWrongIsFailure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>47</LineStart>
<Snippet>
  @Test
  public void oneAnswerWrongIsFailure() throws Exception {
    String[] solution0 = {"Solution 1"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: oneAnswerWrongIsFailure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4D06885CAEF5E5BA5E2CBA52C4951C98" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 allAnswersCorrectIsSuccess() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>29</LineStart>
<Snippet>
  @Test
  public void allAnswersCorrectIsSuccess() throws Exception {
    String[] solution0 = {"Solution 3"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: allAnswersCorrectIsSuccess()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4FBA11AEF2B6EA81F0CF98FA712FB06E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 newTokenShouldWorkForJerry() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>195</LineStart>
<Snippet>
  @Test
  void newTokenShouldWorkForJerry() throws Exception {
    ObjectMapper objectMapper = new ObjectMapper();
    Map&lt;String, Object&gt; loginJson = new HashMap&lt;&gt;();</Snippet>
<TargetFunction>Function: newTokenShouldWorkForJerry()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DA21BDDFF261D66C6E97CF6F6FA1C157" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>StoredXssCommentsTest.java의 failure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>StoredXssCommentsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/StoredXssCommentsTest.java</FilePath>
<LineStart>68</LineStart>
<Snippet>
  @Test
  public void failure() throws Exception {
    ResultActions results =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: failure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="50855E85DA013F27E6C45885358BFEA6" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 loginShouldNotWorkForJerryWithWrongPassword() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>169</LineStart>
<Snippet>
  @Test
  void loginShouldNotWorkForJerryWithWrongPassword() throws Exception {
    ObjectMapper objectMapper = new ObjectMapper();
</Snippet>
<TargetFunction>Function: loginShouldNotWorkForJerryWithWrongPassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="835E32FD0DC7081F75D4460B5888CC78" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HttpBasicsInterceptRequestTest.java의 whenPostAssignmentShouldNotPass() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HttpBasicsInterceptRequestTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/httpproxies/HttpBasicsInterceptRequestTest.java</FilePath>
<LineStart>109</LineStart>
<Snippet>
  @Test
  public void whenPostAssignmentShouldNotPass() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: whenPostAssignmentShouldNotPass()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B9CDECD910DD8B8217B26ED5F6D60D88" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 twoAnswersWrongIsFailure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>65</LineStart>
<Snippet>
  @Test
  public void twoAnswersWrongIsFailure() throws Exception {
    String[] solution0 = {"Solution 1"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: twoAnswersWrongIsFailure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="14BB09249A41139F5755E3F8F3A73558" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 simpleXXEShouldNotWork() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>85</LineStart>
<Snippet>
  @Test
  public void simpleXXEShouldNotWork() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");</Snippet>
<TargetFunction>Function: simpleXXEShouldNotWork()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CED75EF52E24CFF1515CC96C4E71BA4E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CSRFFeedbackTest.java의 postingJsonMessageThroughWebGoatShouldWork() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CSRFFeedbackTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/csrf/CSRFFeedbackTest.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
  @Test
  public void postingJsonMessageThroughWebGoatShouldWork() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: postingJsonMessageThroughWebGoatShouldWork()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DBE3F30C98A6C9CB456DC3BEFADB9877" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DOMCrossSiteScriptingTest.java의 failure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DOMCrossSiteScriptingTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/DOMCrossSiteScriptingTest.java</FilePath>
<LineStart>68</LineStart>
<Snippet>
  @Test
  public void failure() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: failure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C6B9BCDC2C3769C841895F2AC970669B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ContentTypeAssignmentTest.java의 postingInvalidJsonShouldNotAddComment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignmentTest.java</FilePath>
<LineStart>111</LineStart>
<Snippet>
  @Test
  public void postingInvalidJsonShouldNotAddComment() throws Exception {
    var numberOfComments = countComments();
    mockMvc</Snippet>
<TargetFunction>Function: postingInvalidJsonShouldNotAddComment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E1953E83F38C079EFECE92792DE55D00" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson9Test.java의 oneAccount() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9Test.java</FilePath>
<LineStart>43</LineStart>
<Snippet>
  @Test
  public void oneAccount() throws Exception {
    try {
      mockMvc</Snippet>
<TargetFunction>Function: oneAccount()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9533E69FA36373EC65C8FF0065E15F7B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 knownAccountShouldDisplayData() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>18</LineStart>
<Snippet>
  @Test
  public void knownAccountShouldDisplayData() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: knownAccountShouldDisplayData()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="344B0E69C444FF8D18D0905DF8385D41" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 tomShouldSeeNumberOfVotes() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>136</LineStart>
<Snippet>
  @Test
  public void tomShouldSeeNumberOfVotes() throws Exception {
    MvcResult result =
        mockMvc</Snippet>
<TargetFunction>Function: tomShouldSeeNumberOfVotes()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B12CA81D98E5826ECD0EF3C6F1A285B5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MissingFunctionACHiddenMenusTest.java의 HiddenMenusFailure() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACHiddenMenusTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACHiddenMenusTest.java</FilePath>
<LineStart>78</LineStart>
<Snippet>
  @Test
  public void HiddenMenusFailure() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: HiddenMenusFailure()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3C1BB082C7C8D47EB8E7D8E4785886CC" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 invalidLoginWithBlankCredentials() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>143</LineStart>
<Snippet>  @Test
  @DisplayName("Invalid blank credentials login")
  void invalidLoginWithBlankCredentials() throws Exception {
    ResultActions result =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: invalidLoginWithBlankCredentials()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C679CA6EC05D4CEFDB66488BF2141314" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlOnlyInputValidationOnKeywordsTest.java의 containsForbiddenSqlKeyword() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidationOnKeywordsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywordsTest.java</FilePath>
<LineStart>28</LineStart>
<Snippet>
  @Test
  public void containsForbiddenSqlKeyword() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: containsForbiddenSqlKeyword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F4E8A009F74694C397267ADEB36B9D15" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>StoredXssCommentsTest.java의 isNotEncoded() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>StoredXssCommentsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xss/StoredXssCommentsTest.java</FilePath>
<LineStart>86</LineStart>
<Snippet>  // Ensures it is vulnerable
  @Test
  public void isNotEncoded() throws Exception {
    // do get to get comments after posting xss payload
    ResultActions taintedResults =</Snippet>
<TargetFunction>Function: isNotEncoded()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="63EA73A7ED821303DB5BEAC03D968CDA" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTSecretKeyEndpointTest.java의 unsignedToken() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpointTest.java</FilePath>
<LineStart>132</LineStart>
<Snippet>
  @Test
  void unsignedToken() throws Exception {
    Claims claims = createClaims("WebGoat");
    String token = Jwts.builder().setClaims(claims).compact();</Snippet>
<TargetFunction>Function: unsignedToken()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6042619641131E318A99C38428AB162B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SSRFTest1.java의 modifyUrlCat() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTest1.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/ssrf/SSRFTest1.java</FilePath>
<LineStart>46</LineStart>
<Snippet>
  @Test
  public void modifyUrlCat() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/SSRF/task1").param("url", "images/cat.jpg"))</Snippet>
<TargetFunction>Function: modifyUrlCat()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8D62D7DE8D1A1C3D9C5EDF2C3808B864" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 unknownUserWithValidTokenShouldNotBeAbleToVote() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>223</LineStart>
<Snippet>
  @Test
  public void unknownUserWithValidTokenShouldNotBeAbleToVote() throws Exception {
    Claims claims = Jwts.claims();
    claims.put("admin", "true");</Snippet>
<TargetFunction>Function: unknownUserWithValidTokenShouldNotBeAbleToVote()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="251FE46775580E712CBEA06DDCF06DBE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTSecretKeyEndpointTest.java의 solveAssignmentWithLowercase() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpointTest.java</FilePath>
<LineStart>80</LineStart>
<Snippet>
  @Test
  public void solveAssignmentWithLowercase() throws Exception {
    Claims claims = createClaims("webgoat");
    String token = Jwts.builder().setClaims(claims).signWith(HS512, JWT_SECRET).compact();</Snippet>
<TargetFunction>Function: solveAssignmentWithLowercase()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="40A8878ADCD31F3C687CAC49CF76333B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ShopEndpointTest.java의 getCoupon() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ShopEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ShopEndpointTest.java</FilePath>
<LineStart>64</LineStart>
<Snippet>
  @Test
  public void getCoupon() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get("/clientSideFiltering/challenge-store/coupons/webgoat"))</Snippet>
<TargetFunction>Function: getCoupon()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E863D0036249642FB0C1D3825DF583F2" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ClientSideFilteringAssignmentTest.java의 wrongCouponCode() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ClientSideFilteringAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ClientSideFilteringAssignmentTest.java</FilePath>
<LineStart>36</LineStart>
<Snippet>
  @Test
  public void wrongCouponCode() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongCouponCode()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="199D33CEDE4822D68843C26B9425F759" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 unknownRefreshTokenShouldGiveUnauthorized() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>224</LineStart>
<Snippet>
  @Test
  void unknownRefreshTokenShouldGiveUnauthorized() throws Exception {
    ObjectMapper objectMapper = new ObjectMapper();
    Map&lt;String, Object&gt; loginJson = new HashMap&lt;&gt;();</Snippet>
<TargetFunction>Function: unknownRefreshTokenShouldGiveUnauthorized()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B9AD1DBFA86FE23AE79856BECD18A6AE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderKIDEndpointTest.java의 solveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderKIDEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpointTest.java</FilePath>
<LineStart>33</LineStart>
<Snippet>
  @Test
  public void solveAssignment() throws Exception {
    String key = "deletingTom";
    Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();</Snippet>
<TargetFunction>Function: solveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="16B002B9C71CAFC4925AADA46F3E2118" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionChallengeLogin.java의 login() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallengeLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java</FilePath>
<LineStart>52</LineStart>
<Snippet>  @PostMapping("/SqlInjectionAdvanced/challenge_Login")
  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    try (var connection = dataSource.getConnection()) {</Snippet>
<TargetFunction>Function: login()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C5DF5CAD019E47C966F97E7D1B42F67A" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 solutionWithAlgNone() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>100</LineStart>
<Snippet>
  @Test
  void solutionWithAlgNone() throws Exception {
    String tokenWithNoneAlgorithm =
        Jwts.builder()</Snippet>
<TargetFunction>Function: solutionWithAlgNone()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7C092A05F6582BF7105EBA00A2245ECE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 firstAnswerFalseGetResultsReturnsFalseTrueTrueTrue() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>143</LineStart>
<Snippet>
  @Test
  public void firstAnswerFalseGetResultsReturnsFalseTrueTrueTrue() throws Exception {
    String[] solution0 = {"Solution 2"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: firstAnswerFalseGetResultsReturnsFalseTrueTrueTrue()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8B524F2104617ED506B93A35981F532D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SecurityQuestionAssignmentTest.java의 answeringSameQuestionTwiceShouldNotSolveAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityQuestionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/SecurityQuestionAssignmentTest.java</FilePath>
<LineStart>68</LineStart>
<Snippet>
  @Test
  public void answeringSameQuestionTwiceShouldNotSolveAssignment() throws Exception {
    MockHttpSession mocksession = new MockHttpSession();
    mockMvc</Snippet>
<TargetFunction>Function: answeringSameQuestionTwiceShouldNotSolveAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="42981B12993E95B770BB4BF7E47BA191" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlOnlyInputValidationTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationTest.java</FilePath>
<LineStart>15</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1F65B6E1F260E42FA6DD46AB3AD4347E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson8Test.java의 oneAccount() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8Test.java</FilePath>
<LineStart>41</LineStart>
<Snippet>
  @Test
  public void oneAccount() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: oneAccount()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="488D6F1241D24483B061982C2FF0D4E4" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SimpleXXETest.java의 workingAttack() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleXXETest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/SimpleXXETest.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
  @Test
  public void workingAttack() throws Exception {
    // Call with XXE injection
    mockMvc</Snippet>
<TargetFunction>Function: workingAttack()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DD22CD46A64E3D6F63F8DC9FAAE0A392" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ChromeDevToolsTest.java의 NetworkAssignmentTest_Success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ChromeDevToolsTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/chromedevtools/ChromeDevToolsTest.java</FilePath>
<LineStart>30</LineStart>
<Snippet>
  @Test
  public void NetworkAssignmentTest_Success() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: NetworkAssignmentTest_Success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="76C4B397ECB4574CE54A1AB92E5B487E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ShopEndpointTest.java의 fetchAllTheCouponsShouldContainGetItForFree() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ShopEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ShopEndpointTest.java</FilePath>
<LineStart>82</LineStart>
<Snippet>
  @Test
  public void fetchAllTheCouponsShouldContainGetItForFree() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get("/clientSideFiltering/challenge-store/coupons/"))</Snippet>
<TargetFunction>Function: fetchAllTheCouponsShouldContainGetItForFree()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BDE0299C43D9ADE550B10583B53DF721" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 noTokenWhileLoginShouldReturn401() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>266</LineStart>
<Snippet>
  @Test
  void noTokenWhileLoginShouldReturn401() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.post("/JWT/refresh/login"))</Snippet>
<TargetFunction>Function: noTokenWhileLoginShouldReturn401()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2C0793638D52AF88ABF2D7B454D3B366" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson13Test.java의 postingCorrectAnswerShouldPassTheLesson() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13Test.java</FilePath>
<LineStart>120</LineStart>
<Snippet>
  @Test
  public void postingCorrectAnswerShouldPassTheLesson() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: postingCorrectAnswerShouldPassTheLesson()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A1E0EC0E77DF04A104CC8C1DAC781AA7" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5aTest.java의 sqlInjection() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5aTest.java</FilePath>
<LineStart>67</LineStart>
<Snippet>
  @Test
  public void sqlInjection() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: sqlInjection()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="94F2FECFD70ACB1C902199173FD59E9A" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTRefreshEndpointTest.java의 checkoutWithTomsTokenFromAccessLogShouldFail() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>119</LineStart>
<Snippet>
  @Test
  void checkoutWithTomsTokenFromAccessLogShouldFail() throws Exception {
    String accessTokenTom =
        "eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q";</Snippet>
<TargetFunction>Function: checkoutWithTomsTokenFromAccessLogShouldFail()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="538E1FC9D01503D5289519D8D5C58C57" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ShopEndpointTest.java의 getSuperCoupon() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ShopEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ShopEndpointTest.java</FilePath>
<LineStart>54</LineStart>
<Snippet>
  @Test
  public void getSuperCoupon() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: getSuperCoupon()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5DC45F79049C1068977EDC4AF4A1093A" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>BlindSendFileAssignmentTest.java의 containsComment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>51</LineStart>
<Snippet>  }

  private void containsComment(String expected) throws Exception {
    mockMvc
        .perform(get("/xxe/comments").contentType(MediaType.APPLICATION_JSON))</Snippet>
<TargetFunction>Function: containsComment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FC3A4920F107D97A7A0A0BBAFE5F731E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ClientSideFilteringFreeAssignmentTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ClientSideFilteringFreeAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/clientsidefiltering/ClientSideFilteringFreeAssignmentTest.java</FilePath>
<LineStart>23</LineStart>
<Snippet>
  @Test
  public void success() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="54291E9EF4EA15E0DCFF7775FD2C41EF" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadRemoveUserInputTest.java의 solve() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRemoveUserInputTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInputTest.java</FilePath>
<LineStart>26</LineStart>
<Snippet>
  @Test
  public void solve() throws Exception {
    var profilePicture =
        new MockMultipartFile(</Snippet>
<TargetFunction>Function: solve()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8EC9D6EF8CD32ACF3F4B57C476E613C9" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6aTest.java의 wrongDataTypeOfColumns() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6aTest.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  @Test
  public void wrongDataTypeOfColumns() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongDataTypeOfColumns()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8C1B6A20742D511BC8A825E17576387D" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6bTest.java의 submitCorrectPassword() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6bTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6bTest.java</FilePath>
<LineStart>36</LineStart>
<Snippet>
  @Test
  public void submitCorrectPassword() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: submitCorrectPassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E5E59C1EF3A7727A54B2A1DA13385AEF" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTHeaderJKUEndpointTest.java의 setup() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderJKUEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpointTest.java</FilePath>
<LineStart>35</LineStart>
<Snippet>
  @BeforeEach
  public void setup() throws Exception {
    when(webSession.getCurrentLesson()).thenReturn(new JWT());
    this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();</Snippet>
<TargetFunction>Function: setup()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="55169C2F4BABD5019C303046FD25441C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5Test.java의 grantSolution() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5Test.java</FilePath>
<LineStart>50</LineStart>
<Snippet>
  @Test
  public void grantSolution() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: grantSolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="34F252AD451B0180AD4F20776942ACE1" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>LessonMenuServiceTest.java의 lessonsShouldBeOrdered() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LessonMenuServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/container/service/LessonMenuServiceTest.java</FilePath>
<LineStart>76</LineStart>
<Snippet>
  @Test
  void lessonsShouldBeOrdered() throws Exception {
    Lesson l1 = Mockito.mock(Lesson.class);
    Lesson l2 = Mockito.mock(Lesson.class);</Snippet>
<TargetFunction>Function: lessonsShouldBeOrdered()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1351B07A06EBF43F4B49A0DEFD364D3" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6aTest.java의 noUnionUsed() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6aTest.java</FilePath>
<LineStart>101</LineStart>
<Snippet>
  @Test
  public void noUnionUsed() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: noUnionUsed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BE1EE03D66ACC10A2B4DEA051E25DBEC" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SpoofCookieAssignmentTest.java의 cheat() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>167</LineStart>
<Snippet>  @Test
  @DisplayName("cheater test")
  void cheat() throws Exception {
    ResultActions result =
        mockMvc.perform(</Snippet>
<TargetFunction>Function: cheat()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4417DBD2B462A75FD9126B496744668C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson2Test.java의 solution() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson2Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2Test.java</FilePath>
<LineStart>36</LineStart>
<Snippet>
  @Test
  public void solution() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: solution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F6EAAB5EA1169E6E1D2FD9BF9E76B164" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5aTest.java의 unknownAccount() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5aTest.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  @Disabled
  @Test
  public void unknownAccount() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: unknownAccount()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="669EF1C101925E237E0FC7F189CB690E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ProfileUploadTest.java의 attemptWithWrongDirectory() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadTest.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  @Test
  public void attemptWithWrongDirectory() throws Exception {
    var profilePicture =
        new MockMultipartFile(</Snippet>
<TargetFunction>Function: attemptWithWrongDirectory()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FBC0A0E980F92CE298D475219CFF4539" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 secondAnswerFalseGetResultsReturnsTrueFalseTrueTrue() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>167</LineStart>
<Snippet>
  @Test
  public void secondAnswerFalseGetResultsReturnsTrueFalseTrueTrue() throws Exception {
    String[] solution0 = {"Solution 3"};
    String[] solution1 = {"Solution 2"};</Snippet>
<TargetFunction>Function: secondAnswerFalseGetResultsReturnsTrueFalseTrueTrue()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C1D795A128FCA2E14D9005F09E636CFE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>VulnerableTaskHolder.java의 readObject() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableTaskHolder.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java</FilePath>
<LineStart>44</LineStart>
<Snippet>   * @author stupid develop
   */
  private void readObject(ObjectInputStream stream) throws Exception {
    // unserialize data so taskName and taskAction are available
    stream.defaultReadObject();</Snippet>
<TargetFunction>Function: readObject()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="47B7E15E814801E836E6E2EBC9D8A072" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson6aTest.java의 wrongSolution() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6aTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson6aTest.java</FilePath>
<LineStart>37</LineStart>
<Snippet>
  @Test
  public void wrongSolution() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: wrongSolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F3DD0B22DF75F6FFEFAF84257F5BE10C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>HttpBasicsInterceptRequestTest.java의 success() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HttpBasicsInterceptRequestTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/httpproxies/HttpBasicsInterceptRequestTest.java</FilePath>
<LineStart>51</LineStart>
<Snippet>
  @Test
  public void success() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: success()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A86EB109674FFAE6437C774976FE88E7" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SecurityQuestionAssignmentTest.java의 twoQuestionsShouldSolveTheAssignment() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityQuestionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/passwordreset/SecurityQuestionAssignmentTest.java</FilePath>
<LineStart>45</LineStart>
<Snippet>
  @Test
  public void twoQuestionsShouldSolveTheAssignment() throws Exception {
    MockHttpSession mocksession = new MockHttpSession();
    mockMvc</Snippet>
<TargetFunction>Function: twoQuestionsShouldSolveTheAssignment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FB8F3A6C2E3D03DB0CB31D7B6C71EBC3" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 tomShouldGetAToken() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>115</LineStart>
<Snippet>
  @Test
  public void tomShouldGetAToken() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: tomShouldGetAToken()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D7C9A0D94C6FEF2CE57B4211E7989A74" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CSRFFeedbackTest.java의 csrfAttack() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CSRFFeedbackTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/csrf/CSRFFeedbackTest.java</FilePath>
<LineStart>64</LineStart>
<Snippet>
  @Test
  public void csrfAttack() throws Exception {
    mockMvc
        .perform(</Snippet>
<TargetFunction>Function: csrfAttack()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="304CE63A1F63BB91498FEF1A5F59A3B5" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CIAQuizTest.java의 allAnswersCorrectGetResultsReturnsTrueTrueTrueTrue() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CIAQuizTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cia/CIAQuizTest.java</FilePath>
<LineStart>119</LineStart>
<Snippet>
  @Test
  public void allAnswersCorrectGetResultsReturnsTrueTrueTrueTrue() throws Exception {
    String[] solution0 = {"Solution 3"};
    String[] solution1 = {"Solution 1"};</Snippet>
<TargetFunction>Function: allAnswersCorrectGetResultsReturnsTrueTrueTrueTrue()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="66F44FC0F2D4F3D6B77541233F4B7ADE" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTVotesEndpointTest.java의 guestShouldNotSeeNumberOfVotes() 메서드는 일반 예외 사항(generic exception)이 발생하기 때문에 호출자가 오류 처리 및 복구 작업을 하기가 어려워집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>126</LineStart>
<Snippet>
  @Test
  public void guestShouldNotSeeNumberOfVotes() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get("/JWT/votings").cookie(new Cookie("access_token", "")))</Snippet>
<TargetFunction>Function: guestShouldNotSeeNumberOfVotes()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="49">
                        <groupTitle>System Information Leak: External</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction("SEND_EXCEPTION");
    i.putExtra("exception", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = "NfcActivity";
private static final String DATA_SPLITTER = "__:DATA:__";
private static final String MIME_TYPE = "application/my.applications.mimetype";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, "액세스 거부" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction("SEND_EXCEPTION");
    i.putExtra("exception", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>49</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E030F0A7D821A420C924E25872D575A1" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>118</LineStart>
<Snippet>      return ok(failed(this).feedback("jwt-refresh-not-tom").feedbackArgs(user).build());
    } catch (ExpiredJwtException e) {
      return ok(failed(this).output(e.getMessage()).build());
    } catch (JwtException e) {
      return ok(failed(this).feedback("jwt-invalid-token").build());</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>118</LineStart>
<Snippet>      return ok(failed(this).feedback("jwt-refresh-not-tom").feedbackArgs(user).build());
    } catch (ExpiredJwtException e) {
      return ok(failed(this).output(e.getMessage()).build());
    } catch (JwtException e) {
      return ok(failed(this).feedback("jwt-invalid-token").build());</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CC4A1036E8A98FBBD0ED9458923FB219" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRemoveUserInput.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java</FilePath>
<LineStart>36</LineStart>
<Snippet>  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFileRemoveUserInput") MultipartFile file) {
    return super.execute(file, file.getOriginalFilename());
  }
}</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>55</LineStart>
<Snippet>
    } catch (IOException e) {
      return failed(this).output(e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FEEF25132260F685151FFAF38FF89026" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUpload.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java</FilePath>
<LineStart>39</LineStart>
<Snippet>      @RequestParam("uploadedFile") MultipartFile file,
      @RequestParam(value = "fullName", required = false) String fullName) {
    return super.execute(file, fullName);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>55</LineStart>
<Snippet>
    } catch (IOException e) {
      return failed(this).output(e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CFEDF9F1D4880686CD27E2A1380B0302" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryConfidentiality(name, auth_tan);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>105</LineStart>
<Snippet>      } catch (SQLException e) {
        return failed(this)
            .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")
            .build();
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B0E45353707A038DB254B8D36D2B6555" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>58</LineStart>
<Snippet>      @RequestParam String userid, @RequestParam String login_count, HttpServletRequest request)
      throws IOException {
    return injectableQuery(login_count, userid);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>129</LineStart>
<Snippet>              this.getClass().getName()
                  + " : "
                  + e.getMessage()
                  + "&lt;br&gt; Your query was: "
                  + queryString.replace("?", login_count))</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="625D44C94264E535DCCC6CDB9DB20B0E" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java</FilePath>
<LineStart>85</LineStart>
<Snippet>    }

    return attackResult;
  }
</Snippet>
<TargetFunction>Return attackResult()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ContentTypeAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java</FilePath>
<LineStart>80</LineStart>
<Snippet>        }
      } catch (Exception e) {
        error = ExceptionUtils.getStackTrace(e);
        attackResult = failed(this).feedback("xxe.content.type.feedback.xml").output(error).build();
      }</Snippet>
<TargetFunction>org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1C83BA6CA6F2C33847CC36DF6FD12CBF" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleMailAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/SimpleMailAssignment.java</FilePath>
<LineStart>78</LineStart>
<Snippet>  public AttackResult resetPassword(@RequestParam String emailReset) {
    String email = ofNullable(emailReset).orElse("unknown@webgoat.org");
    return sendEmail(extractUsername(email), email);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SimpleMailAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/SimpleMailAssignment.java</FilePath>
<LineStart>103</LineStart>
<Snippet>        return informationMessage(this)
            .feedback("password-reset-simple.email_failed")
            .output(e.getMessage())
            .build();
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="230CF82EF62A4A10B186007C16578B7B" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidation.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java</FilePath>
<LineStart>52</LineStart>
<Snippet>    }
    AttackResult attackResult = lesson6a.injectableQuery(userId);
    return new AttackResult(
        attackResult.isLessonCompleted(),
        attackResult.getFeedback(),</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>112</LineStart>
<Snippet>    } catch (Exception e) {
      return failed(this)
          .output(this.getClass().getName() + " : " + e.getMessage() + YOUR_QUERY_WAS + query)
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8EFFF56A97DB309D22C80110F55F5369" ruleID="AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadBase.java의 getProfilePicture() 함수는 91 줄의 body()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. body()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>91</LineStart>
<Snippet>    return ResponseEntity.ok()
        .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
        .body(getProfilePictureAsBase64());
  }
</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.BodyBuilder.body()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>97</LineStart>
<Snippet>    var profilePictureDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    var profileDirectoryFiles = profilePictureDirectory.listFiles();

    if (profileDirectoryFiles != null &amp;&amp; profileDirectoryFiles.length &gt; 0) {</Snippet>
<TargetFunction>java.io.File.listFiles()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="43F65F902B4DF03F659AEF5D9D6029D6" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>61</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryIntegrity(name, auth_tan);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>89</LineStart>
<Snippet>        System.err.println(e.getMessage());
        return failed(this)
            .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")
            .build();
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="26937F59EA6E478AD38AB039E604FABF" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java</FilePath>
<LineStart>92</LineStart>
<Snippet>      }
    } catch (Exception e) {
      return failed(this).feedback("jwt-invalid-token").output(e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JWTSecretKeyEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java</FilePath>
<LineStart>92</LineStart>
<Snippet>      }
    } catch (Exception e) {
      return failed(this).feedback("jwt-invalid-token").output(e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="43F65F902B4DF03F659AEF5D9D6029D7" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>61</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryIntegrity(name, auth_tan);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>98</LineStart>
<Snippet>      System.err.println(e.getMessage());
      return failed(this)
          .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4AAF31D3235605F26483E62502E5E1E4" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTask2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java</FilePath>
<LineStart>45</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String url) {
    return furBall(url);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSRFTask2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java</FilePath>
<LineStart>56</LineStart>
<Snippet>                .replaceAll("\n", "&lt;br&gt;"); // Otherwise the \n gets escaped in the response
      } catch (MalformedURLException e) {
        return getFailedResult(e.getMessage());
      } catch (IOException e) {
        // in case the external site is down, the test and lesson should still be ok</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3018975C7E2504C8E2FDF05DF73CA07D" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>102</LineStart>
<Snippet>      comments.addComment(comment, false);
    } catch (Exception e) {
      return failed(this).output(e.toString()).build();
    }
    return failed(this).build();</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>102</LineStart>
<Snippet>      comments.addComment(comment, false);
    } catch (Exception e) {
      return failed(this).output(e.toString()).build();
    }
    return failed(this).build();</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D985B0C74D6F4FB372896EC8E0AC2CF8" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>54</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>78</LineStart>
<Snippet>
      } catch (SQLException sqle) {
        return failed(this).output(sqle.getMessage()).build();
      }
    } catch (Exception e) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BAFB9F4402E6986469C40D67C47ADBA5" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      return credentialsLoginFlow(username, password, response);
    } else {
      return cookieLoginFlow(cookieValue);
    }
  }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>114</LineStart>
<Snippet>    } catch (Exception e) {
      // for providing some instructive guidance, we won't return 4xx error here
      return failed(this).output(e.getMessage()).build();
    }
    if (users.containsKey(cookieUsername)) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="155F86F437DD35A0AC5E642E96DD9938" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CSRFFeedback.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java</FilePath>
<LineStart>70</LineStart>
<Snippet>      objectMapper.readValue(feedback.getBytes(), Map.class);
    } catch (IOException e) {
      return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
    }
    boolean correctCSRF =</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CSRFFeedback.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java</FilePath>
<LineStart>70</LineStart>
<Snippet>      objectMapper.readValue(feedback.getBytes(), Map.class);
    } catch (IOException e) {
      return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
    }
    boolean correctCSRF =</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CFEDF9F1D4880686CD27E2A1380B0303" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryConfidentiality(name, auth_tan);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>111</LineStart>
<Snippet>    } catch (Exception e) {
      return failed(this)
          .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="32226568FC8924D66E6D27E364F7F756" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidationOnKeywords.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java</FilePath>
<LineStart>58</LineStart>
<Snippet>    }
    AttackResult attackResult = lesson6a.injectableQuery(userId);
    return new AttackResult(
        attackResult.isLessonCompleted(),
        attackResult.getFeedback(),</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>108</LineStart>
<Snippet>        }
      } catch (SQLException sqle) {
        return failed(this).output(sqle.getMessage() + YOUR_QUERY_WAS + query).build();
      }
    } catch (Exception e) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E6EA7FD618883135F8FBC0803E00BBCD" ruleID="AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 getProfilePicture() 함수는 109 줄의 body()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. body()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>109</LineStart>
<Snippet>          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())
                  .getBytes());
    } catch (IOException | URISyntaxException e) {
      log.error("Image not found", e);</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.BodyBuilder.body()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>108</LineStart>
<Snippet>          .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())
                  .getBytes());
    } catch (IOException | URISyntaxException e) {</Snippet>
<TargetFunction>java.io.File.listFiles()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="39A4E35F9FDBBFDBCCED6B8DC02256A4" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String action_string) {
    return injectableQueryAvailability(action_string);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>106</LineStart>
<Snippet>    } catch (Exception e) {
      return failed(this)
          .output("&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F2852734D74FAAD385B25A516E58D462" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java</FilePath>
<LineStart>78</LineStart>
<Snippet>      }
    } catch (SQLException sqle) {
      return failed(this).feedback("sql-injection.2.failed").output(sqle.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D6CB87797727C6A953EAE890D04912B7" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidationOnKeywords.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java</FilePath>
<LineStart>58</LineStart>
<Snippet>    }
    AttackResult attackResult = lesson6a.injectableQuery(userId);
    return new AttackResult(
        attackResult.isLessonCompleted(),
        attackResult.getFeedback(),</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>112</LineStart>
<Snippet>    } catch (Exception e) {
      return failed(this)
          .output(this.getClass().getName() + " : " + e.getMessage() + YOUR_QUERY_WAS + query)
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="37A3463B8AFF5632E97F6092649F396F" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContentTypeAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java</FilePath>
<LineStart>85</LineStart>
<Snippet>    }

    return attackResult;
  }
</Snippet>
<TargetFunction>Return attackResult()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ContentTypeAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java</FilePath>
<LineStart>80</LineStart>
<Snippet>        }
      } catch (Exception e) {
        error = ExceptionUtils.getStackTrace(e);
        attackResult = failed(this).feedback("xxe.content.type.feedback.xml").output(error).build();
      }</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1FC70DF4F58351860C34349CAB34C9B4" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlOnlyInputValidation.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java</FilePath>
<LineStart>52</LineStart>
<Snippet>    }
    AttackResult attackResult = lesson6a.injectableQuery(userId);
    return new AttackResult(
        attackResult.isLessonCompleted(),
        attackResult.getFeedback(),</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>108</LineStart>
<Snippet>        }
      } catch (SQLException sqle) {
        return failed(this).output(sqle.getMessage() + YOUR_QUERY_WAS + query).build();
      }
    } catch (Exception e) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3100CB7E3C1438E61C17CDC86B9DB51E" ruleID="AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 getProfilePicture() 함수는 106 줄의 location()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. location()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>106</LineStart>
<Snippet>      }
      return ResponseEntity.status(HttpStatus.NOT_FOUND)
          .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.HeadersBuilder.location()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1E995EC78E90C0B489F36536986BFC0C" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>213</LineStart>
<Snippet>        }
      } catch (JwtException e) {
        return failed(this).feedback("jwt-invalid-token").output(e.toString()).build();
      }
    }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>213</LineStart>
<Snippet>        }
      } catch (JwtException e) {
        return failed(this).feedback("jwt-invalid-token").output(e.toString()).build();
      }
    }</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="DA62026215230969B4BE3B7C58F81DAE" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>58</LineStart>
<Snippet>      @RequestParam String userid, @RequestParam String login_count, HttpServletRequest request)
      throws IOException {
    return injectableQuery(login_count, userid);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>121</LineStart>
<Snippet>        return failed(this)
            .output(
                sqle.getMessage() + "&lt;br&gt; Your query was: " + queryString.replace("?", login_count))
            .build();
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CFA636D041B15CDDFFB5BBA5FB3653EE" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleXXE.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java</FilePath>
<LineStart>84</LineStart>
<Snippet>      error = ExceptionUtils.getStackTrace(e);
    }
    return failed(this).output(error).build();
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SimpleXXE.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java</FilePath>
<LineStart>82</LineStart>
<Snippet>      }
    } catch (Exception e) {
      error = ExceptionUtils.getStackTrace(e);
    }
    return failed(this).output(error).build();</Snippet>
<TargetFunction>org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="826C55FE4F115F012B295336392EC928" ruleID="AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>JWTRefreshEndpoint.java의 checkout() 함수는 118 줄의 ok()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. ok()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>118</LineStart>
<Snippet>      return ok(failed(this).feedback("jwt-refresh-not-tom").feedbackArgs(user).build());
    } catch (ExpiredJwtException e) {
      return ok(failed(this).output(e.getMessage()).build());
    } catch (JwtException e) {
      return ok(failed(this).feedback("jwt-invalid-token").build());</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.ok()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>118</LineStart>
<Snippet>      return ok(failed(this).feedback("jwt-refresh-not-tom").feedbackArgs(user).build());
    } catch (ExpiredJwtException e) {
      return ok(failed(this).output(e.getMessage()).build());
    } catch (JwtException e) {
      return ok(failed(this).feedback("jwt-invalid-token").build());</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8FDA61133CF2262FD279C744209231AF" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>55</LineStart>
<Snippet>      return failed(this).feedback("path-traversal-zip-slip.no-zip").build();
    } else {
      return processZipUpload(file);
    }
  }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>80</LineStart>
<Snippet>      return isSolved(currentImage, getProfilePictureAsBase64());
    } catch (IOException e) {
      return failed(this).output(e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="929904495CB59A19ABF75D40E19D0EE4" ruleID="AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 getProfilePicture() 함수는 102 줄의 location()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. location()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>102</LineStart>
<Snippet>        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
            .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
            .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
      }</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.HeadersBuilder.location()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="37B36EAEA9DA9E85E93B2E40FC0F11F1" ruleID="0DF8AF25-8291-4D4A-AD05-AB2072AD6A81">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>application-webwolf.properties</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/application-webwolf.properties</FilePath>
<LineStart>1</LineStart>
<Snippet>server.error.include-stacktrace=always
server.error.path=/error.html
server.servlet.context-path=${webwolf.context}</Snippet>
<TargetFunction>server.error.include-stacktrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FD0756D23D590962CD6E84E31820F3BF" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadFix.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java</FilePath>
<LineStart>39</LineStart>
<Snippet>      @RequestParam("uploadedFileFix") MultipartFile file,
      @RequestParam(value = "fullNameFix", required = false) String fullName) {
    return super.execute(file, fullName != null ? fullName.replace("../", "") : "");
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>55</LineStart>
<Snippet>
    } catch (IOException e) {
      return failed(this).output(e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="AF39CEADDC42DFE23E3496CC9EF2DEC3" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderJKUEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java</FilePath>
<LineStart>66</LineStart>
<Snippet>        }
      } catch (MalformedURLException | JWTVerificationException | JwkException e) {
        return failed(this).feedback("jwt-invalid-token").output(e.toString()).build();
      }
    }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JWTHeaderJKUEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderJKUEndpoint.java</FilePath>
<LineStart>66</LineStart>
<Snippet>        }
      } catch (MalformedURLException | JWTVerificationException | JwkException e) {
        return failed(this).feedback("jwt-invalid-token").output(e.toString()).build();
      }
    }</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9FECB299D077DB3FD8DCDC794E05D654" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>57</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam(value = "userid_6a") String userId) {
    return injectableQuery(userId);
    // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from
    // user_system_data --</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>108</LineStart>
<Snippet>        }
      } catch (SQLException sqle) {
        return failed(this).output(sqle.getMessage() + YOUR_QUERY_WAS + query).build();
      }
    } catch (Exception e) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="237BF0E8D0CC653FF9D1F2D1C252925A" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CSRFFeedback.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java</FilePath>
<LineStart>70</LineStart>
<Snippet>      objectMapper.readValue(feedback.getBytes(), Map.class);
    } catch (IOException e) {
      return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
    }
    boolean correctCSRF =</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CSRFFeedback.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java</FilePath>
<LineStart>70</LineStart>
<Snippet>      objectMapper.readValue(feedback.getBytes(), Map.class);
    } catch (IOException e) {
      return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
    }
    boolean correctCSRF =</Snippet>
<TargetFunction>org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="899648E3B8C5E0BBA4F18EE9BE9F95EA" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  public AttackResult completed(
      @RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
    return injectableQuery(account + " " + operator + " " + injection);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>98</LineStart>
<Snippet>      return failed(this)
          .output(
              this.getClass().getName() + " : " + e.getMessage() + "&lt;br&gt; Your query was: " + query)
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E2E2889F243E5FE2386BFFF46B2238A9" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>55</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>74</LineStart>
<Snippet>        }
      } catch (SQLException sqle) {
        return failed(this).output(sqle.getMessage()).build();
      }
    } catch (Exception e) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D3EC6880409A0660A85E7BCB48CBC085" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>54</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>81</LineStart>
<Snippet>      }
    } catch (Exception e) {
      return failed(this).output(this.getClass().getName() + " : " + e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BBBD3BBA45AF76ED097B33315AFC6451" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MailAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/MailAssignment.java</FilePath>
<LineStart>69</LineStart>
<Snippet>        restTemplate.postForEntity(webWolfURL, mailEvent, Object.class);
      } catch (RestClientException e) {
        return informationMessage(this)
            .feedback("webwolf.email_failed")
            .output(e.getMessage())</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MailAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/MailAssignment.java</FilePath>
<LineStart>71</LineStart>
<Snippet>        return informationMessage(this)
            .feedback("webwolf.email_failed")
            .output(e.getMessage())
            .build();
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="47C412D11FC0B11039E14E31ADB87763" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderKIDEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpoint.java</FilePath>
<LineStart>117</LineStart>
<Snippet>        }
      } catch (JwtException e) {
        return failed(this).feedback("jwt-invalid-token").output(e.toString()).build();
      }
    }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JWTHeaderKIDEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpoint.java</FilePath>
<LineStart>117</LineStart>
<Snippet>        }
      } catch (JwtException e) {
        return failed(this).feedback("jwt-invalid-token").output(e.toString()).build();
      }
    }</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="81401AE0F5A1D717DE5F4DB45481F9CD" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>55</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>77</LineStart>
<Snippet>      }
    } catch (Exception e) {
      return failed(this).output(this.getClass().getName() + " : " + e.getMessage()).build();
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7E36960DB6F36C20D6A4AA5A190380EC" ruleID="0DF8AF25-8291-4D4A-AD05-AB2072AD6A81">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>application-webgoat.properties</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/application-webgoat.properties</FilePath>
<LineStart>1</LineStart>
<Snippet>server.error.include-stacktrace=always
server.error.path=/error.html
server.servlet.context-path=${WEBGOAT_CONTEXT:/WebGoat}</Snippet>
<TargetFunction>server.error.include-stacktrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B0C24527BCD9EE675D2AA9BF9DD975BC" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java</FilePath>
<LineStart>72</LineStart>
<Snippet>  public AttackResult completed(String query) {
    createUser();
    return injectableQuery(query);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java</FilePath>
<LineStart>89</LineStart>
<Snippet>      return failed(this)
          .output(
              this.getClass().getName() + " : " + e.getMessage() + "&lt;br&gt; Your query was: " + query)
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="068CD987B813838FBA185DFF60EC0673" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>57</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam(value = "userid_6a") String userId) {
    return injectableQuery(userId);
    // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from
    // user_system_data --</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>112</LineStart>
<Snippet>    } catch (Exception e) {
      return failed(this)
          .output(this.getClass().getName() + " : " + e.getMessage() + YOUR_QUERY_WAS + query)
          .build();
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="39A4E35F9FDBBFDBCCED6B8DC02256A3" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String action_string) {
    return injectableQueryAvailability(action_string);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>95</LineStart>
<Snippet>              .output(
                  "&lt;span class='feedback-negative'&gt;"
                      + e.getMessage()
                      + "&lt;/span&gt;&lt;br&gt;"
                      + output.toString())</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F30016AD21C1DA8CE86D201D63BC6224" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SimpleXXE.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java</FilePath>
<LineStart>84</LineStart>
<Snippet>      error = ExceptionUtils.getStackTrace(e);
    }
    return failed(this).output(error).build();
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SimpleXXE.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java</FilePath>
<LineStart>82</LineStart>
<Snippet>      }
    } catch (Exception e) {
      error = ExceptionUtils.getStackTrace(e);
    }
    return failed(this).output(error).build();</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="99BBC0E51399EDD6DCCD1F1D04255D2B" ruleID="7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  public AttackResult completed(
      @RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
    return injectableQuery(account + " " + operator + " " + injection);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>93</LineStart>
<Snippet>        }
      } catch (SQLException sqle) {
        return failed(this).output(sqle.getMessage() + "&lt;br&gt; Your query was: " + query).build();
      }
    } catch (Exception e) {</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="35">
                        <groupTitle>Path Manipulation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 "../../tomcat/conf/server.xml" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty("sub")+".txt");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString("reportName");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>35</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="AD9B232BDA422C11F1E9163BF8F479DF" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 Salaries.java의 60 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  public void copyFiles() {
    ClassPathResource classPathResource = new ClassPathResource("lessons/employees.xml");
    File targetDirectory = new File(webGoatHomeDirectory, "/ClientSideFiltering");
    if (!targetDirectory.exists()) {
      targetDirectory.mkdir();</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  public void copyFiles() {
    ClassPathResource classPathResource = new ClassPathResource("lessons/employees.xml");
    File targetDirectory = new File(webGoatHomeDirectory, "/ClientSideFiltering");
    if (!targetDirectory.exists()) {
      targetDirectory.mkdir();</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="44DFF5F848A3A4387C29E15F3E4C82A0" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 Ping.java의 52 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>52</LineStart>
<Snippet>    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);
    File logFile = new File(webGoatHomeDirectory, "/XXE/log" + webSession.getUserName() + ".txt");
    try {
      try (PrintWriter pw = new PrintWriter(logFile)) {</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F5C8050DD911AEF6197C9F97038A2BAD" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 42 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
    try {
      var uploadedFile = new File(uploadDirectory, fullName);
      uploadedFile.createNewFile();
      FileCopyUtils.copy(file.getBytes(), uploadedFile);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUpload.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java</FilePath>
<LineStart>38</LineStart>
<Snippet>  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFile") MultipartFile file,
      @RequestParam(value = "fullName", required = false) String fullName) {
    return super.execute(file, fullName);
  }</Snippet>
<TargetFunction>uploadFileHandler(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D68CC19B38ECE61F9DA754BA2D186E4D" ruleID="6138BBAF-C3B7-4EDC-A8CB-D44308310F85">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileZipSlip.java의 66 줄에 있는 resolve()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
    try {
      var uploadedZipFile = tmpZipDirectory.resolve(file.getOriginalFilename());
      FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());
</Snippet>
<TargetFunction>java.nio.file.Path.resolve()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>51</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(@RequestParam("uploadedFileZipSlip") MultipartFile file) {
    if (!file.getOriginalFilename().toLowerCase().endsWith(".zip")) {
      return failed(this).feedback("path-traversal-zip-slip.no-zip").build();</Snippet>
<TargetFunction>uploadFileHandler(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="41CFF3A025C0D6E58F750C96E65167CB" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 42 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
    try {
      var uploadedFile = new File(uploadDirectory, fullName);
      uploadedFile.createNewFile();
      FileCopyUtils.copy(file.getBytes(), uploadedFile);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRemoveUserInput.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java</FilePath>
<LineStart>35</LineStart>
<Snippet>  @ResponseBody
  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFileRemoveUserInput") MultipartFile file) {
    return super.execute(file, file.getOriginalFilename());
  }</Snippet>
<TargetFunction>uploadFileHandler(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="95DD252DFEFFBC870E642BDEC0EED195" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 62 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  protected File cleanupAndCreateDirectoryForUser() {
    var uploadDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    if (uploadDirectory.exists()) {
      FileSystemUtils.deleteRecursively(uploadDirectory);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRemoveUserInput.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java</FilePath>
<LineStart>25</LineStart>
<Snippet>
  public ProfileUploadRemoveUserInput(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileUploadRemoveUserInput(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BCC0CC7930F0C1517E78308FD4FF0933" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>50</LineStart>
<Snippet>    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);
        System.out.println("- Using base directory: " + baseDirectory.getAbsolutePath());
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>48</LineStart>
<Snippet>    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);</Snippet>
<TargetFunction>main(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1B61377BCB9F2C2012F68C537B6D33D2" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadRetrieval.java의 92 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>92</LineStart>
<Snippet>      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");

      if (catPicture.getName().toLowerCase().contains("path-traversal-secret.jpg")) {</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>90</LineStart>
<Snippet>    }
    try {
      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");</Snippet>
<TargetFunction>jakarta.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3FFAFBE7B47F00C4F83114ECCB24445A" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 Ping.java의 52 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>52</LineStart>
<Snippet>    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);
    File logFile = new File(webGoatHomeDirectory, "/XXE/log" + webSession.getUserName() + ".txt");
    try {
      try (PrintWriter pw = new PrintWriter(logFile)) {</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>52</LineStart>
<Snippet>    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);
    File logFile = new File(webGoatHomeDirectory, "/XXE/log" + webSession.getUserName() + ".txt");
    try {
      try (PrintWriter pw = new PrintWriter(logFile)) {</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E4E024548C018C8E3CA493B08C0CAF98" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 42 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
    try {
      var uploadedFile = new File(uploadDirectory, fullName);
      uploadedFile.createNewFile();
      FileCopyUtils.copy(file.getBytes(), uploadedFile);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadFix.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java</FilePath>
<LineStart>38</LineStart>
<Snippet>  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFileFix") MultipartFile file,
      @RequestParam(value = "fullNameFix", required = false) String fullName) {
    return super.execute(file, fullName != null ? fullName.replace("../", "") : "");
  }</Snippet>
<TargetFunction>uploadFileHandler(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D49C01075B955F42C9CD41FBFAE8DA94" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 MvcConfiguration.java의 70 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>MvcConfiguration.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java</FilePath>
<LineStart>70</LineStart>
<Snippet>  @PostConstruct
  public void createDirectory() {
    File file = new File(fileLocation);
    if (!file.exists()) {
      file.mkdirs();</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MvcConfiguration.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java</FilePath>
<LineStart>70</LineStart>
<Snippet>  @PostConstruct
  public void createDirectory() {
    File file = new File(fileLocation);
    if (!file.exists()) {
      file.mkdirs();</Snippet>
<TargetFunction>Read this.fileLocation()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="6BE3625FBA2D75101C3662E751B074B7" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 96 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>96</LineStart>
<Snippet>  protected byte[] getProfilePictureAsBase64() {
    var profilePictureDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    var profileDirectoryFiles = profilePictureDirectory.listFiles();
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUpload.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java</FilePath>
<LineStart>27</LineStart>
<Snippet>
  public ProfileUpload(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileUpload(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A1CE96EAD145969665279C4C06C74769" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 96 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>96</LineStart>
<Snippet>  protected byte[] getProfilePictureAsBase64() {
    var profilePictureDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    var profileDirectoryFiles = profilePictureDirectory.listFiles();
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadFix.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java</FilePath>
<LineStart>27</LineStart>
<Snippet>
  public ProfileUploadFix(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileUploadFix(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="6371CA732CC34C9D8F1EED44315CD105" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 WebGoat.java의 62 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  @Bean(name = "pluginTargetDirectory")
  public File pluginTargetDirectory(@Value("${webgoat.user.directory}") final String webgoatHome) {
    return new File(webgoatHome);
  }
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>61</LineStart>
<Snippet>
  @Bean(name = "pluginTargetDirectory")
  public File pluginTargetDirectory(@Value("${webgoat.user.directory}") final String webgoatHome) {
    return new File(webgoatHome);
  }</Snippet>
<TargetFunction>pluginTargetDirectory(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4E57DC59BA00C5A9605F988B4E3C89D3" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignmentTest.java의 135 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>135</LineStart>
<Snippet>  public void solveOnlyParamReferenceEntityInExternalDTD() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    // Host DTD on WebWolf site
    String dtd =</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="08A9340FFDBB75BAE225CEB7DF68CDFF" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignment.java의 74 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>74</LineStart>
<Snippet>    var fileContents = "WebGoat 8.0 rocks... (" + randomAlphabetic(10) + ")";
    userToFileContents.put(user, fileContents);
    File targetDirectory = new File(webGoatHomeDirectory, "/XXE/" + user.getUsername());
    if (!targetDirectory.exists()) {
      targetDirectory.mkdirs();</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  public BlindSendFileAssignment(
      @Value("${webgoat.user.directory}") String webGoatHomeDirectory, CommentsCache comments) {
    this.webGoatHomeDirectory = webGoatHomeDirectory;
    this.comments = comments;</Snippet>
<TargetFunction>BlindSendFileAssignment(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1776D7E566A366EA65C81DE6D2A62616" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 MD5.java의 49 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>MD5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java</FilePath>
<LineStart>49</LineStart>
<Snippet>      for (String element : args) {
        try {
          System.out.println(MD5.getHashString(new File(element)) + " " + element);
        } catch (IOException x) {
          System.err.println(x.getMessage());</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MD5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java</FilePath>
<LineStart>43</LineStart>
<Snippet>   * @since ostermillerutils 1.00.00
   */
  public static void main(String[] args) {
    if (args.length == 0) {
      System.err.println("Please specify a file.");</Snippet>
<TargetFunction>main(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7781A6373CDAD8AF0B9748FC683BC31D" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 Salaries.java의 77 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>77</LineStart>
<Snippet>  public List&lt;Map&lt;String, Object&gt;&gt; invoke() {
    NodeList nodes = null;
    File d = new File(webGoatHomeDirectory, "ClientSideFiltering/employees.xml");
    XPathFactory factory = XPathFactory.newInstance();
    XPath path = factory.newXPath();</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>77</LineStart>
<Snippet>  public List&lt;Map&lt;String, Object&gt;&gt; invoke() {
    NodeList nodes = null;
    File d = new File(webGoatHomeDirectory, "ClientSideFiltering/employees.xml");
    XPathFactory factory = XPathFactory.newInstance();
    XPath path = factory.newXPath();</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F768070C86C399E3B57A9F6B1BABD2A9" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 62 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  protected File cleanupAndCreateDirectoryForUser() {
    var uploadDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    if (uploadDirectory.exists()) {
      FileSystemUtils.deleteRecursively(uploadDirectory);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="14FF6BB67AD85A374460A2F26479A12F" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 96 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>96</LineStart>
<Snippet>  protected byte[] getProfilePictureAsBase64() {
    var profilePictureDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    var profileDirectoryFiles = profilePictureDirectory.listFiles();
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B5CC4D9BFC281A19EE73A7B1FBEFCCAE" ruleID="788E3752-66EE-4EE0-8C5D-9F24DBBECEE1">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileZipSlip.java의 67 줄에 있는 toFile()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>67</LineStart>
<Snippet>    try {
      var uploadedZipFile = tmpZipDirectory.resolve(file.getOriginalFilename());
      FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());

      ZipFile zip = new ZipFile(uploadedZipFile.toFile());</Snippet>
<TargetFunction>java.nio.file.Path.toFile()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>51</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(@RequestParam("uploadedFileZipSlip") MultipartFile file) {
    if (!file.getOriginalFilename().toLowerCase().endsWith(".zip")) {
      return failed(this).feedback("path-traversal-zip-slip.no-zip").build();</Snippet>
<TargetFunction>uploadFileHandler(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D9B48A1D330F5765C3039D4702EB12B0" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 62 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  protected File cleanupAndCreateDirectoryForUser() {
    var uploadDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    if (uploadDirectory.exists()) {
      FileSystemUtils.deleteRecursively(uploadDirectory);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadFix.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java</FilePath>
<LineStart>27</LineStart>
<Snippet>
  public ProfileUploadFix(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileUploadFix(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="540A4D6982DE29B8A3F762DB51FA0058" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadRetrieval.java의 47 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>47</LineStart>
<Snippet>
  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();
  }</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4ADCD2E1C5C65FD63752956C8C4A72D6" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignmentTest.java의 102 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>102</LineStart>
<Snippet>  public void solve() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    // Host DTD on WebWolf site
    String dtd =</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="953DB6D38309B8C16197BCC4252A3920" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileZipSlip.java의 73 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      while (entries.hasMoreElements()) {
        ZipEntry e = entries.nextElement();
        File f = new File(tmpZipDirectory.toFile(), e.getName());
        InputStream is = zip.getInputStream(e);
        Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>70</LineStart>
<Snippet>
      ZipFile zip = new ZipFile(uploadedZipFile.toFile());
      Enumeration&lt;? extends ZipEntry&gt; entries = zip.entries();
      while (entries.hasMoreElements()) {
        ZipEntry e = entries.nextElement();</Snippet>
<TargetFunction>java.util.zip.ZipFile.entries()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A9BBC930673021D9F8D9E50C485E4AB6" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignmentTest.java의 87 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>87</LineStart>
<Snippet>  public void simpleXXEShouldNotWork() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    String content =
        "&lt;?xml version=\"1.0\" standalone=\"yes\" ?&gt;&lt;!DOCTYPE user [&lt;!ENTITY root SYSTEM"</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B61A0BDEDB9A66D9391842DAB6FFE08F" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 62 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  protected File cleanupAndCreateDirectoryForUser() {
    var uploadDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    if (uploadDirectory.exists()) {
      FileSystemUtils.deleteRecursively(uploadDirectory);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  public ProfileZipSlip(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileZipSlip(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B5CC4D9BFC281A19EE73A7B1FBEFCCAF" ruleID="788E3752-66EE-4EE0-8C5D-9F24DBBECEE1">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileZipSlip.java의 69 줄에 있는 toFile()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>69</LineStart>
<Snippet>      FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());

      ZipFile zip = new ZipFile(uploadedZipFile.toFile());
      Enumeration&lt;? extends ZipEntry&gt; entries = zip.entries();
      while (entries.hasMoreElements()) {</Snippet>
<TargetFunction>java.nio.file.Path.toFile()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>51</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(@RequestParam("uploadedFileZipSlip") MultipartFile file) {
    if (!file.getOriginalFilename().toLowerCase().endsWith(".zip")) {
      return failed(this).feedback("path-traversal-zip-slip.no-zip").build();</Snippet>
<TargetFunction>uploadFileHandler(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F795B5B1EE04FFF779A105E8414FBD1D" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignmentTest.java의 102 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>102</LineStart>
<Snippet>  public void solve() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    // Host DTD on WebWolf site
    String dtd =</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>102</LineStart>
<Snippet>  public void solve() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    // Host DTD on WebWolf site
    String dtd =</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FFE0B8D9EAC81D2B088C008D06503DDF" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 62 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  protected File cleanupAndCreateDirectoryForUser() {
    var uploadDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    if (uploadDirectory.exists()) {
      FileSystemUtils.deleteRecursively(uploadDirectory);</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUpload.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java</FilePath>
<LineStart>27</LineStart>
<Snippet>
  public ProfileUpload(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileUpload(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="EA4BAA6F08FF15063329C0BB76A3DA58" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadBase.java의 96 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadBase.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java</FilePath>
<LineStart>96</LineStart>
<Snippet>  protected byte[] getProfilePictureAsBase64() {
    var profilePictureDirectory =
        new File(this.webGoatHomeDirectory, "/PathTraversal/" + webSession.getUserName());
    var profileDirectoryFiles = profilePictureDirectory.listFiles();
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>42</LineStart>
<Snippet>
  public ProfileZipSlip(
      @Value("${webgoat.server.directory}") String webGoatHomeDirectory, WebSession webSession) {
    super(webGoatHomeDirectory, webSession);
  }</Snippet>
<TargetFunction>ProfileZipSlip(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BC46894665CFEC18A7357779E502F013" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignment.java의 74 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>74</LineStart>
<Snippet>    var fileContents = "WebGoat 8.0 rocks... (" + randomAlphabetic(10) + ")";
    userToFileContents.put(user, fileContents);
    File targetDirectory = new File(webGoatHomeDirectory, "/XXE/" + user.getUsername());
    if (!targetDirectory.exists()) {
      targetDirectory.mkdirs();</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="667DCBF3D0F7FAD5EC69034B703BC25F" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignmentTest.java의 87 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>87</LineStart>
<Snippet>  public void simpleXXEShouldNotWork() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    String content =
        "&lt;?xml version=\"1.0\" standalone=\"yes\" ?&gt;&lt;!DOCTYPE user [&lt;!ENTITY root SYSTEM"</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>87</LineStart>
<Snippet>  public void simpleXXEShouldNotWork() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    String content =
        "&lt;?xml version=\"1.0\" standalone=\"yes\" ?&gt;&lt;!DOCTYPE user [&lt;!ENTITY root SYSTEM"</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C511D47164A052A45DF59BDDE93F429A" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignmentTest.java의 135 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>135</LineStart>
<Snippet>  public void solveOnlyParamReferenceEntityInExternalDTD() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    // Host DTD on WebWolf site
    String dtd =</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java</FilePath>
<LineStart>135</LineStart>
<Snippet>  public void solveOnlyParamReferenceEntityInExternalDTD() throws Exception {
    File targetFile =
        new File(webGoatHomeDirectory, "/XXE/" + webSession.getUserName() + "/secret.txt");
    // Host DTD on WebWolf site
    String dtd =</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="67FE197BCC6A340CB397AACF6F4A6EE7" ruleID="138700B9-C625-4262-9826-C8F3450D6838">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 BlindSendFileAssignment.java의 74 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>74</LineStart>
<Snippet>    var fileContents = "WebGoat 8.0 rocks... (" + randomAlphabetic(10) + ")";
    userToFileContents.put(user, fileContents);
    File targetDirectory = new File(webGoatHomeDirectory, "/XXE/" + user.getUsername());
    if (!targetDirectory.exists()) {
      targetDirectory.mkdirs();</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>UserService.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/users/UserService.java</FilePath>
<LineStart>29</LineStart>
<Snippet>  @Override
  public WebGoatUser loadUserByUsername(String username) throws UsernameNotFoundException {
    WebGoatUser webGoatUser = userRepository.findByUsername(username);
    if (webGoatUser == null) {
      throw new UsernameNotFoundException("User not found");</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="33">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>WebSecurityConfig.java의 86 줄에서 &lt;a href="location://Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###86###28###0"&gt;disable()&lt;/a&gt;에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, "/new_user");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, "http://www.example.com/new_user");
  body = addToPost(body, "attacker";
  body = addToPost(body, "haha");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, "/new_user");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>33</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="EECDCB57ABDA2D41DC802D2361085A04" ruleID="30DFC293-D2B8-463A-9952-257A44B5339C">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>credentials.js의 3 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>credentials.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/insecurelogin/js/credentials.js</FilePath>
<LineStart>3</LineStart>
<Snippet>function submit_secret_credentials() {
    var xhttp = new XMLHttpRequest();
    xhttp['open']('POST', 'InsecureLogin/login', true);
	//sending the request is obfuscated, to descourage js reading
	var _0xb7f9=["\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B","\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C","\x73\x74\x72\x69\x6E\x67\x69\x66\x79","\x73\x65\x6E\x64"];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]]({username:_0xb7f9[0],password:_0xb7f9[1]}))</Snippet>
<TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BA7AFE6D4A7BC28C9963F9F3B54C6BE0" ruleID="2335EF74-F5C5-4BE1-89B6-707D1B78D6B3">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LessonController.js의 147 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LessonController.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/goatApp/controller/LessonController.js</FilePath>
<LineStart>147</LineStart>
<Snippet>                $.ajax({
                    url:'service/restartlesson.mvc',
                    method:'GET'
                }).done(function(lessonLink) {
                    self.loadLesson(self.name);</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8F1910B437D13E18D5D723B0F13592C0" ruleID="E1187028-6481-47EC-B923-5E91EB7178EB">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>WebSecurityConfig.java의 86 줄에서 &lt;a href="location://Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###86###28###0"&gt;disable()&lt;/a&gt;에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java</FilePath>
<LineStart>86</LineStart>
<Snippet>            })
        .logout(logout -&gt; logout.deleteCookies("JSESSIONID").invalidateHttpSession(true))
        .csrf(csrf -&gt; csrf.disable())
        .headers(headers -&gt; headers.disable())
        .exceptionHandling(</Snippet>
<TargetFunction>FunctionCall: disable()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C8BAA8A01F4D74F8BCFFED5EAD14FB3" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>path_traversal.js의 29 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>29</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewFix").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8D43711D3B053D3BF99623CA6B92BF57" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>csrf-review.js의 35 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>csrf-review.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/csrf/js/csrf-review.js</FilePath>
<LineStart>35</LineStart>
<Snippet>    function getChallenges() {
        $("#list").empty();
        $.get('csrf/review', function (result, status) {
            for (var i = 0; i &lt; result.length; i++) {
                var comment = html.replace('USER', result[i].user);</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EA13DAA9FFDD611B291FFEAD05AB6D24" ruleID="30DFC293-D2B8-463A-9952-257A44B5339C">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>text.js의 270 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>text.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/text.js</FilePath>
<LineStart>270</LineStart>
<Snippet>        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers</Snippet>
<TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="929C8B558F230608D9005501BE679097" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>jquery.form.js의 245 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/jquery.form.js</FilePath>
<LineStart>245</LineStart>
<Snippet>        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6EA14BB13805911F4DF76598D8FD73DB" ruleID="30DFC293-D2B8-463A-9952-257A44B5339C">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>quiz.js의 15 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>quiz.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/quiz.js</FilePath>
<LineStart>15</LineStart>
<Snippet>    var client = new XMLHttpRequest();
    var quiz_id = document.getElementById("quiz_id").getAttribute("data-quiz_id");
    client.open('GET', 'lesson_js/questions_' + quiz_id + '.json');
    client.onreadystatechange = function() {
        if (this.readyState == 4 &amp;&amp; this.status == 200) {</Snippet>
<TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7AF79A2E182123F0E8A1F1E7FF37294C" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>goatApp.js의 21 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>goatApp.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/goatApp/goatApp.js</FilePath>
<LineStart>21</LineStart>
<Snippet>            initApp: function () {
                var locale = localStorage.getItem('locale') || 'en';
                $.getJSON('service/labels.mvc', function(data) {
                    window.polyglot = new Polyglot({phrases: data});//i18n polyglot labels
                    asyncErrorHandler.init();</Snippet>
<TargetFunction>FunctionPointerCall: getJSON()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C19DBFA4B6DA13AD59D27DC557E8C4D6" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>hijackform.html 파일의 3 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>hijackform.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/hijacksession/templates/hijackform.html</FilePath>
<LineStart>3</LineStart>
<Snippet>&lt;div class="row"&gt;
	&lt;div class="col-md-4"&gt;
		&lt;form class="attack-form" accept-charset="UNKNOWN" method="POST"
			action="HijackSession/login"&gt;
			&lt;div style="padding: 20px;" id="password-login"&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="155AFEDD4076DF24A7A417B4F655C02E" ruleID="2335EF74-F5C5-4BE1-89B6-707D1B78D6B3">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>bypass.js의 11 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>bypass.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/authbypass/js/bypass.js</FilePath>
<LineStart>11</LineStart>
<Snippet>    console.warn("on view profile activated")
    webgoat.customjs.jquery.ajax({
        method: "GET",
        url: "IDOR/profile",
        contentType: 'application/json; charset=UTF-8'</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F6AE026590F66DE6BCB75D754A72D34E" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>clientSideFiltering.js의 17 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>17</LineStart>
<Snippet>
function ajaxFunction(userId) {
    $.get("clientSideFiltering/salaries?userId=" + userId, function (result, status) {
        var html = "&lt;table border = '1' width = '90%' align = 'center'";
        html = html + '&lt;tr&gt;';</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2959B630BFAD261E9318DD43EDDC1738" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>clientSideFilteringFree.js의 41 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>clientSideFilteringFree.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js</FilePath>
<LineStart>41</LineStart>
<Snippet>    $(".checkoutCode").on("blur", function () {
        var checkoutCode = $(".checkoutCode").val();
        $.get("clientSideFiltering/challenge-store/coupons/" + checkoutCode, function (result, status) {
            var discount = result.discount;
            if (discount &gt; 0) {</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="929C8B558F230608D9005501BE679096" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>jquery.form.js의 245 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/jquery_form/jquery.form.js</FilePath>
<LineStart>245</LineStart>
<Snippet>        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0701A528EAAE2A5BA30B7FD6266F9036" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>assignment13.js의 43 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>assignment13.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/sqlinjection/js/assignment13.js</FilePath>
<LineStart>43</LineStart>
<Snippet>
function getServers(column) {
    $.get("SqlInjectionMitigations/servers?column=" + column, function (result, status) {
        $("#servers").empty();
        for (var i = 0; i &lt; result.length; i++) {</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="50A06639EB7772D5A255C110E0820C1B" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>GoatUtils.js의 56 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>GoatUtils.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/goatApp/support/GoatUtils.js</FilePath>
<LineStart>56</LineStart>
<Snippet> 
                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $("#lesson_cookies").html(reply);
                    }, "html");</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4E2C7371CCCFC93F2BB6BBA28CCCF3DE" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>path_traversal.js의 13 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>13</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallback = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("preview").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8F1910B437D13E18D5D723B0F13592C1" ruleID="E1187028-6481-47EC-B923-5E91EB7178EB">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>WebSecurityConfig.java의 64 줄에서 &lt;a href="location://Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java###64###28###0"&gt;disable()&lt;/a&gt;에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java</FilePath>
<LineStart>64</LineStart>
<Snippet>              auth.anyRequest().authenticated();
            })
        .csrf(csrf -&gt; csrf.disable())
        .formLogin(
            login -&gt;</Snippet>
<TargetFunction>FunctionCall: disable()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="45BD9D7C7783F2A580D7752F1919D11A" ruleID="30DFC293-D2B8-463A-9952-257A44B5339C">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ace.js의 4157 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>4157</LineStart>
<Snippet>exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {</Snippet>
<TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3527F5DD91FAF3B169A3354249F29F2C" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>challenge8.js의 7 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>7</LineStart>
<Snippet>
function loadVotes() {
    $.get("challenge/8/votes/", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i &lt;= 5; i++) {</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0975B6FFE681C553C928AA3206415535" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>path_traversal.js의 46 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>46</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRemoveUserInput").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B9A34D73BEB81A764B26BCA83BF06EB3" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>stored-xss.js의 35 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>stored-xss.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/xss/js/stored-xss.js</FilePath>
<LineStart>35</LineStart>
<Snippet>    function getChallenges() {
        $("#list").empty();
        $.get('CrossSiteScriptingStored/stored-xss', function (result, status) {
            for (var i = 0; i &lt; result.length; i++) {
                var comment = html.replace('USER', result[i].user);</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7AC94BE1C2E42CE6539F660CA103980A" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>xxe.js의 72 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>xxe.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/xxe/js/xxe.js</FilePath>
<LineStart>72</LineStart>
<Snippet>
function getComments(field) {
    $.get("xxe/comments", function (result, status) {
        $(field).empty();
        for (var i = 0; i &lt; result.length; i++) {</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EBC1959590F4A6A88D5C1241A1D76B52" ruleID="2335EF74-F5C5-4BE1-89B6-707D1B78D6B3">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>GoatRouter.js의 68 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>GoatRouter.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/goatApp/view/GoatRouter.js</FilePath>
<LineStart>68</LineStart>
<Snippet>                console.log('phoneHome invoked');
                webgoat.customjs.jquery.ajax({
                    method: "POST",
                    url: "CrossSiteScripting/phone-home-xss",
                    data: {param1: 42, param2: 24},</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="155AFEDD4076DF24A7A417B4F655C030" ruleID="2335EF74-F5C5-4BE1-89B6-707D1B78D6B3">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>idor.js의 14 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>idor.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/lessontemplate/js/idor.js</FilePath>
<LineStart>14</LineStart>
<Snippet>    console.warn("on view profile activated")
    webgoat.customjs.jquery.ajax({
        method: "GET",
        url: "IDOR/profile",
        contentType: 'application/json; charset=UTF-8'</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="525FB32CE4551ACE423E582CDE3E7168" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>path_traversal.js의 53 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>53</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRetrieval").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3408AEF62EAB4CD3FDDEFA217B5F1843" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>spoofcookieform.html 파일의 3 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>spoofcookieform.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/spoofcookie/templates/spoofcookieform.html</FilePath>
<LineStart>3</LineStart>
<Snippet>&lt;div class="row"&gt;
	&lt;div class="col-md-4"&gt;
		&lt;form class="attack-form" accept-charset="UNKNOWN" method="POST"
			action="SpoofCookie/login"&gt;
			&lt;div style="padding: 20px;" id="password-login"&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="EEE06D34A5BE7F2EB9D6F335FB4E3930" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>path_traversal.js의 59 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>59</LineStart>
<Snippet>
function newRandomPicture() {
    $.get("PathTraversal/random-picture", function (result, status) {
        document.getElementById("randomCatPicture").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AFC587ECB9060D79D73793E5BDA09B6A" ruleID="30DFC293-D2B8-463A-9952-257A44B5339C">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>credentials.js의 3 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>credentials.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/ssrf/js/credentials.js</FilePath>
<LineStart>3</LineStart>
<Snippet>function submit_secret_credentials() {
    var xhttp = new XMLHttpRequest();
    xhttp['open']('POST', '#attack/307/100', true);
	//sending the request is obfuscated, to descourage js reading
	var _0xb7f9=["\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B","\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C","\x73\x74\x72\x69\x6E\x67\x69\x66\x79","\x73\x65\x6E\x64"];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]]({username:_0xb7f9[0],password:_0xb7f9[1]}))</Snippet>
<TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A4A2CCE5E6AE9F369646A9A244143610" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>challenge8.js의 46 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>46</LineStart>
<Snippet>function doVote(stars) {
    $("#voteResultMsg").hide();
    $.get("challenge/8/vote/" + stars, function (result) {
        if (result["error"]) {
            $("#voteResultMsg").addClass('alert-danger alert-dismissable');</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="155AFEDD4076DF24A7A417B4F655C02F" ruleID="2335EF74-F5C5-4BE1-89B6-707D1B78D6B3">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>idor.js의 14 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>idor.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/idor/js/idor.js</FilePath>
<LineStart>14</LineStart>
<Snippet>    console.warn("on view profile activated")
    webgoat.customjs.jquery.ajax({
        method: "GET",
        url: "IDOR/profile",
        contentType: 'application/json; charset=UTF-8'</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8A8C421594BE93B011596EC0C47EE46D" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>jwt-voting.js의 43 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jwt-voting.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/js/jwt-voting.js</FilePath>
<LineStart>43</LineStart>
<Snippet>function getVotings() {
    $("#votesList").empty();
    $.get("JWT/votings", function (result, status) {
        for (var i = 0; i &lt; result.length; i++) {
            var voteTemplate = html.replace('IMAGE_SMALL', result[i].imageSmall);</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="000535B7CA42ECAD3BE1D2CF4F4A7549" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>challenge8.js의 26 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>26</LineStart>
<Snippet>
function average() {
    $.get("challenge/8/votes/average", function (average) {
            for (var i = 1; i &lt;= 5; i++) {
                var number = average["average"];</Snippet>
<TargetFunction>FunctionPointerCall: get()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="30">
                        <groupTitle>Mass Assignment: Insecure Binder Configuration</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>개발을 쉽게 하고 생산성을 증가할 수 있도록, 대부분의 현대적 프레임워크에서는 개체가 바인딩할 클래스 속성과 이름이 일치하는 HTTP 요청 매개 변수로 자동 인스턴스화되고 채워질수 있도록 합니다. 개체의 자동 인스턴스화 및 채우기는 개발 속도를 높이지만 아무런 주의 없이 구현되는 경우 심각한 문제가 발생할 수 있습니다. 바운드 클래스 또는 중첩된 클래스의 모든 속성은 HTTP 요청 매개 변수로 자동 바인딩됩니다. 따라서 악의적인 사용자는 웹 폼 또는 API 계약을 통해 클라이언트에 노출되지 않더라도 바운드 또는 중첩된 클래스에 있는 모든 속성에 값을 할당할 수 있습니다.

예제 1: 다음 컨트롤러 메서드는 추가 구성 없이 Spring MVC를 사용하여 User 또는 Details 클래스에서 모든 속성으로 HTTP 요청 매개 변수를 바인딩합니다.


@RequestMapping(method = RequestMethod.POST)
public String registerUser(@ModelAttribute("user") User user, BindingResult result, SessionStatus status) {
  if (db.save(user).hasErrors()) {
    return "CustomerForm";
  } else {
    status.setComplete();
    return "CustomerSuccess";
  }
}


User 클래스는 다음과 같이 정의됩니다.


public class User {
  private String name;
  private String lastname;
  private int age;
  private Details details;

  // Public Getters and Setters
  ...
}


Details 클래스는 다음과 같이 정의됩니다.


public class Details {
  private boolean is_admin;
  private int id;
  private Date login_date;

  // Public Getters and Setters
  ...
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>자동 모델 바인딩 기능을 제공하는 프레임워크를 사용하는 경우 모델 개체에 바인딩할 속성을 제어하여 공격자가 모델 또는 중첩된 클래스의 다른 비노출 속성을 식별할 수 있더라도 HTTP 요청 매개 변수에서 임의 값을 바인딩할 수 없게 하는 것이 모범 사례입니다.

사용되는 프레임워크에 따라 모델 바인딩 프로세스 제어에는 다양한 방법이 있습니다.

Spring MVC: 

바인딩 프로세스에서 사용할 HTTP 요청 매개 변수와 무시할 매개 변수를 제어할 수 있습니다.

@ModelAttribute 주석이 추가된 매개 변수를 사용하는 Spring MVC 응용 프로그램에서 바인딩할 속성을 제어하도록 바인더를 구성할 수 있습니다. 이를 위해 프레임워크가 Spring Model Binder에 참조를 삽입하도록 메서드에 @InitBinder로 주석을 추가할 수 있습니다. Spring Model Binder는 setAllowedFields 및 setDisallowedFields 메서드로 속성 바인딩 프로세스를 제어하도록 구성할 수 있습니다. BaseCommandController를 확장하는 Spring MVC 응용 프로그램은 Spring Model Binder로 참조를 가져오기 위해 initBinder(HttpServletRequest request, ServletRequestDataBinder binder) 메서드를 오버라이드할 수 있습니다.

예제 2: Spring Model Binder(3.x)가 민감한 속성의 바인딩을 허용하지 않도록 구성되어 있습니다.


final String[] DISALLOWED_FIELDS = new String[]{"details.role", "details.age", "is_admin"};

@InitBinder
public void initBinder(WebDataBinder binder) {
    binder.setDisallowedFields(DISALLOWED_FIELDS);
}


예제 3: Spring Model Binder(2.x)가 민감한 속성의 바인딩을 허용하지 않도록 구성되어 있습니다.


@Override
protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {
    binder.setDisallowedFields(new String[]{"details.role", "details.age", "is_admin"});
}


@RequestBody 주석이 추가된 매개 변수를 사용하는 Spring MVC 응용 프로그램에서 바인딩 프로세스는 HttpMessageConverter 인스턴스에 의해 처리됩니다. 해당 인스턴스는 Jackson 및 JAXB와 같은 라이브러리를 사용하여 HTTP 요청 본문을 Java 개체로 변환합니다. 이러한 라이브러리는 주석을 제공하여 허용되어야 하거나 허용되지 않아야 하는 필드를 제어합니다. 예를 들어, Jackson JSON 라이브러리의 경우 @JsonIgnore 주석을 사용하여 필드가 요청에 바인딩되는 것을 방지할 수 있습니다.

예제 4: 컨트롤러 메서드는 @RequestBody 주석을 사용하여 HTTP 요청을 Employee 클래스의 인스턴스에 바인딩합니다.


    @RequestMapping(value="/add/employee", method=RequestMethod.POST, consumes="text/html")
    public void addEmployee(@RequestBody Employee employee){
        // Do something with the employee object.
    }


응용 프로그램은 기본 Jackson HttpMessageConverter를 사용하여 JSON HTTP 요청을 Employee 클래스에 바인딩합니다. is_admin 민감한 필드의 바인딩을 방지하려면 @JsonIgnore 주석을 사용하십시오.


public class Employee {

  @JsonIgnore
  private boolean is_admin;
  ...

  // Public Getters and Setters
  ...
}


참고: Jackson 및 JAXB 주석을 구성하는 방법에 대한 자세한 내용은 다음 REST 프레임워크 정보를 확인하십시오.

Apache Struts: 

Struts 1 및 2는 관련 공용 세터 접근자가 있는 Actions 또는 ActionForms 속성에만 HTTP 요청 매개 변수를 바인딩합니다. 속성을 해당 요청에 바인딩해서는 안 되는 경우 세터를 비공개로 설정해야 합니다.

예제 5: Struts 프레임워크가 HTTP 요청 매개 변수를 자동으로 바인딩하지 않도록 비공개 세터를 구성합니다.


private String role;
private void setRole(String role)  {
   this.role = role;
}


REST 프레임워크: 

대부분의 REST 프레임워크는 콘텐트 유형이 JSON 또는 XML인 모든 HTTP 요청 본문을 모델 개체에 자동으로 바인딩합니다. JSON 및 XML 프로세싱에 사용되는 라이브러리에 따라 바인딩 프로세스 제어에 다양한 방법이 있습니다. 다음은 JAXB(XML) 및 Jackson(JSON)의 몇 가지 예입니다.

예제 6: Oracle의 JAXB 라이브러리를 사용하는 XML 문서에서 바인딩한 모델은 @XmlAccessorType, @XmlAttribute, @XmlElement 및 @XmlTransient 등의 다양한 주석을 사용하여 바인딩 프로세스를 제어할 수 있습니다. 바인더는 XmlAccessType.NONE 값이 포함된 @XmlAccessorType 주석을 사용한 모델에 주석을 달고 @XmlAttribute 및 @XmlElement 주석을 사용하여 바인딩해야 하는 필드를 선택하여 기본적으로 모든 속성을 바인딩하지 않습니다.


@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class User {
    private String role;
    private String name;
    @XmlAttribute
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }


예제 7: Jackson 라이브러리를 사용하는 JSON 문서에서 바인딩한 모델은 @JsonIgnore, @JsonIgnoreProperties, @JsonIgnoreType 및 @JsonInclude 등의 다양한 주석을 사용하여 바인딩 프로세스를 제어할 수 있습니다. 바인더는 @JsonIgnore 주석으로 주석을 달아 특정 속성을 무시할 수 있습니다.


public class User {

    @JsonIgnore
    private String role;
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }


대량 할당 취약점을 방지하기 위한 다른 접근법은 HTTP 요청 매개 변수가 DTO 개체에 바운딩된 레이어 아키텍처를 사용하는 것입니다. DTO 개체는 해당 목적으로만 사용되며 웹 폼 또는 API 계약에 정의된 속성만 노출하고 나머지 비공개 속성을 정의할 수 있는 도메인 개체에 이러한 DTO 개체를 매핑합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 이 취약점 범주는 문제를 정확하게 발견하기 위해서는 정적 분석의 기능을 넘어서는 응용 프로그램 아키텍처의 이해를 요구하므로 설계 결함으로 분류할 수 있습니다. 따라서 응용 프로그램이 HTTP 요청 바인딩에 특정 DTO 개체를 사용하도록 설계된 경우 속성을 배제하기 위해 바인더를 구성할 필요가 없을 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>30</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3404008C7A32F6E574A55B7BDC5B8D00" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFLogin.java</FilePath>
<LineStart>53</LineStart>
<Snippet>      produces = {"application/json"})
  @ResponseBody
  public AttackResult completed(HttpServletRequest request) {
    String userName = request.getUserPrincipal().getName();
    if (userName.startsWith("csrf")) {</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B6E5B26607DF3BE419FDFB269EC734E1" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HashingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>  @PostMapping("/crypto/hashing")
  @ResponseBody
  public AttackResult completed(
      HttpServletRequest request,
      @RequestParam String answer_pwd1,</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6067E499A21421B9423B664578B368EA" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFFeedback.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java</FilePath>
<LineStart>60</LineStart>
<Snippet>      produces = {"application/json"})
  @ResponseBody
  public AttackResult completed(HttpServletRequest request, @RequestBody String feedback) {
    try {
      objectMapper.enable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES);</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E20312EC59B20E4072C8AE814625DD37" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ForgedReviews.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/ForgedReviews.java</FilePath>
<LineStart>90</LineStart>
<Snippet>  @PostMapping("/csrf/review")
  @ResponseBody
  public AttackResult createNewReview(
      String reviewText, Integer stars, String validateReq, HttpServletRequest request) {
    final String host = (request.getHeader("host") == null) ? "NULL" : request.getHeader("host");</Snippet>
<TargetFunction>Function: createNewReview()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A4CA2E887C6F17A182B831852DD8AB3E" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentForgotPassword.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentForgotPassword.java</FilePath>
<LineStart>69</LineStart>
<Snippet>  @PostMapping("/PasswordReset/ForgotPassword/create-password-reset-link")
  @ResponseBody
  public AttackResult sendPasswordResetLink(
      @RequestParam String email, HttpServletRequest request) {
    String resetLink = UUID.randomUUID().toString();</Snippet>
<TargetFunction>Function: sendPasswordResetLink()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="85B680EBF04FC857A4A460674A67BD27" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>83</LineStart>
<Snippet>  @GetMapping("/PathTraversal/random-picture")
  @ResponseBody
  public ResponseEntity&lt;?&gt; getProfilePicture(HttpServletRequest request) {
    var queryParams = request.getQueryString();
    if (queryParams != null &amp;&amp; (queryParams.contains("..") || queryParams.contains("/"))) {</Snippet>
<TargetFunction>Function: getProfilePicture()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A63B4721211C873F79A2C6AFEBEBFB67" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>120</LineStart>
<Snippet>
  @GetMapping("/JWT/votings/login")
  public void login(@RequestParam("user") String user, HttpServletResponse response) {
    if (validUsers.contains(user)) {
      Claims claims = Jwts.claims().setIssuedAt(Date.from(Instant.now().plus(Duration.ofDays(10))));</Snippet>
<TargetFunction>Function: login()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0BC1E9B47FC4F781006F0C99537902CF" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>114</LineStart>
<Snippet>
  @PostMapping("/PasswordReset/reset/change-password")
  public ModelAndView changePassword(
      @ModelAttribute("form") PasswordChangeForm form, BindingResult bindingResult) {
    ModelAndView modelAndView = new ModelAndView();</Snippet>
<TargetFunction>Function: changePassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="310CDAAE72E8E66F880D701584392EC6" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFGetFlag.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java</FilePath>
<LineStart>49</LineStart>
<Snippet>      method = RequestMethod.POST)
  @ResponseBody
  public Map&lt;String, Object&gt; invoke(HttpServletRequest req) {

    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</Snippet>
<TargetFunction>Function: invoke()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="10CF3D219733FDBB844A3B111AE099E7" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Assignment7.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7.java</FilePath>
<LineStart>74</LineStart>
<Snippet>  @PostMapping("/challenge/7")
  @ResponseBody
  public AttackResult sendPasswordResetLink(@RequestParam String email, HttpServletRequest request)
      throws URISyntaxException {
    if (StringUtils.hasText(email)) {</Snippet>
<TargetFunction>Function: sendPasswordResetLink()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D4A0BC365E6CF745811BC72981B2E667" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HashingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java</FilePath>
<LineStart>67</LineStart>
<Snippet>  @RequestMapping(path = "/crypto/hashing/sha256", produces = MediaType.TEXT_HTML_VALUE)
  @ResponseBody
  public String getSha256(HttpServletRequest request) throws NoSuchAlgorithmException {

    String sha256 = (String) request.getSession().getAttribute("sha256");</Snippet>
<TargetFunction>Function: getSha256()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="867D011D50B85FB3497DD9F614807B63" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>78</LineStart>
<Snippet>
  @GetMapping(path = "/SpoofCookie/cleanup")
  public void cleanup(HttpServletResponse response) {
    Cookie cookie = new Cookie(COOKIE_NAME, "");
    cookie.setMaxAge(0);</Snippet>
<TargetFunction>Function: cleanup()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="95AB2C6F5F2D1811E7485A2765F02586" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DOMCrossSiteScripting.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xss/DOMCrossSiteScripting.java</FilePath>
<LineStart>40</LineStart>
<Snippet>  @PostMapping("/CrossSiteScripting/phone-home-xss")
  @ResponseBody
  public AttackResult completed(
      @RequestParam Integer param1, @RequestParam Integer param2, HttpServletRequest request) {
    UserSessionData userSessionData = getUserSessionData();</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C4E22C7E5A37BDECBBA79326D1300ED5" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  @GetMapping(path = "/crypto/encoding/basic", produces = MediaType.TEXT_HTML_VALUE)
  @ResponseBody
  public String getBasicAuth(HttpServletRequest request) {

    String basicAuth = (String) request.getSession().getAttribute("basicAuth");</Snippet>
<TargetFunction>Function: getBasicAuth()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="920F3674A8FFCB287D32FA432605AC90" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>VerifyAccount.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/authbypass/VerifyAccount.java</FilePath>
<LineStart>61</LineStart>
<Snippet>      produces = {"application/json"})
  @ResponseBody
  public AttackResult completed(
      @RequestParam String userId, @RequestParam String verifyMethod, HttpServletRequest req)
      throws ServletException, IOException {</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CEEC10EEA99B8FE8F5637ABCD95FA5FC" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>64</LineStart>
<Snippet>  @ResponseBody
  @ExceptionHandler(UnsatisfiedServletRequestParameterException.class)
  public AttackResult login(
      @RequestParam String username,
      @RequestParam String password,</Snippet>
<TargetFunction>Function: login()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C465EF00DAC4116071839E52AD6085F1" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Welcome.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/controller/Welcome.java</FilePath>
<LineStart>56</LineStart>
<Snippet>   */
  @GetMapping(path = {"welcome.mvc"})
  public ModelAndView welcome(HttpServletRequest request) {

    // set the welcome attribute</Snippet>
<TargetFunction>Function: welcome()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="002A6D502FB968931A415B737CD14D6D" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SigningAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java</FilePath>
<LineStart>54</LineStart>
<Snippet>  @RequestMapping(path = "/crypto/signing/getprivate", produces = MediaType.TEXT_HTML_VALUE)
  @ResponseBody
  public String getPrivateKey(HttpServletRequest request)
      throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {
</Snippet>
<TargetFunction>Function: getPrivateKey()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C22130115483AFF5D4640F490C7AF59B" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HijackSessionAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignment.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  @PostMapping(path = "/HijackSession/login")
  @ResponseBody
  public AttackResult login(
      @RequestParam String username,
      @RequestParam String password,</Snippet>
<TargetFunction>Function: login()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A4A342F984B512159BD9123BE21C0909" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LandingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java</FilePath>
<LineStart>58</LineStart>
<Snippet>
  @GetMapping("/WebWolf/landing/password-reset")
  public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {
    URI uri = new URI(request.getRequestURL().toString());
    ModelAndView modelAndView = new ModelAndView();</Snippet>
<TargetFunction>Function: openPasswordReset()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0DB73467214500201BE9DFDD25C27D9D" ruleID="66F1C785-3EDF-4CF2-9217-3275D7BC5DB7">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>IDOREditOtherProfile.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/idor/IDOREditOtherProfile.java</FilePath>
<LineStart>55</LineStart>
<Snippet>  @PutMapping(path = "/IDOR/profile/{userId}", consumes = "application/json")
  @ResponseBody
  public AttackResult completed(
      @PathVariable("userId") String userId, @RequestBody UserProfile userSubmittedProfile) {
</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="82BB8D697F115857B713413814A6989F" ruleID="66F1C785-3EDF-4CF2-9217-3275D7BC5DB7">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>MissingFunctionACUsers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java</FilePath>
<LineStart>100</LineStart>
<Snippet>      produces = "application/json")
  @ResponseBody
  public User addUser(@RequestBody User newUser) {
    try {
      userRepository.save(newUser);</Snippet>
<TargetFunction>Function: addUser()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B8C8163DC9C8BAA159570CAB2BE3A350" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Assignment8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge8/Assignment8.java</FilePath>
<LineStart>38</LineStart>
<Snippet>  @GetMapping(value = "/challenge/8/vote/{stars}", produces = MediaType.APPLICATION_JSON_VALUE)
  @ResponseBody
  public ResponseEntity&lt;?&gt; vote(
      @PathVariable(value = "stars") int nrOfStars, HttpServletRequest request) {
    // Simple implementation of VERB Based Authentication</Snippet>
<TargetFunction>Function: vote()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3D6977CFB85A05833C1BABFC9FD9079A" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SigningAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java</FilePath>
<LineStart>69</LineStart>
<Snippet>  @PostMapping("/crypto/signing/verify")
  @ResponseBody
  public AttackResult completed(
      HttpServletRequest request, @RequestParam String modulus, @RequestParam String signature) {
</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0E06F6D958D3CDAB1E5812C06EF30F62" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>RegistrationController.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/users/RegistrationController.java</FilePath>
<LineStart>34</LineStart>
<Snippet>
  @PostMapping("/register.mvc")
  public String registration(
      @ModelAttribute("userForm") @Valid UserForm userForm,
      BindingResult bindingResult,</Snippet>
<TargetFunction>Function: registration()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2BF92E4EC23E37F006EA0E1BFBB2A03B" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HttpBasicsInterceptRequest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/httpproxies/HttpBasicsInterceptRequest.java</FilePath>
<LineStart>43</LineStart>
<Snippet>      method = {RequestMethod.POST, RequestMethod.GET})
  @ResponseBody
  public AttackResult completed(
      @RequestHeader(value = "x-request-intercepted", required = false) Boolean headerValue,
      @RequestParam(value = "changeMe", required = false) String paramValue,</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="374E3329A4FDD3EC3BEE6D9B7C682107" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>61</LineStart>
<Snippet>  @PostMapping("/crypto/encoding/basic-auth")
  @ResponseBody
  public AttackResult completed(
      HttpServletRequest request,
      @RequestParam String answer_user,</Snippet>
<TargetFunction>Function: completed()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="90167752800F6AC109D86E030F94D5A7" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LandingPage.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/LandingPage.java</FilePath>
<LineStart>46</LineStart>
<Snippet>        RequestMethod.PUT
      })
  public Callable&lt;ResponseEntity&lt;?&gt;&gt; ok(HttpServletRequest request) {
    return () -&gt; {
      log.trace("Incoming request for: {}", request.getRequestURL());</Snippet>
<TargetFunction>Function: ok()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8FE0066150AB7625DBE7606AC736E97B" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>StartLesson.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/controller/StartLesson.java</FilePath>
<LineStart>74</LineStart>
<Snippet>      value = {"*.lesson"},
      produces = "text/html")
  public ModelAndView lessonPage(HttpServletRequest request) {
    var model = new ModelAndView("lesson_content");
    var path = request.getRequestURL().toString(); // we now got /a/b/c/AccessControlMatrix.lesson</Snippet>
<TargetFunction>Function: lessonPage()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="10B2138A64FF6EE037F48BAC12959748" ruleID="DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1">
                            <Category>Mass Assignment: Insecure Binder Configuration</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HashingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java</FilePath>
<LineStart>48</LineStart>
<Snippet>  @RequestMapping(path = "/crypto/hashing/md5", produces = MediaType.TEXT_HTML_VALUE)
  @ResponseBody
  public String getMd5(HttpServletRequest request) throws NoSuchAlgorithmException {

    String md5Hash = (String) request.getSession().getAttribute("md5Hash");</Snippet>
<TargetFunction>Function: getMd5()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="27">
                        <groupTitle>SQL Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>LessonConnectionInvocationHandler.java의 27 줄에서 invoke() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>SQL injection 오류는 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스에서 데이터가 프로그램에 입력됩니다.

이런 경우, Fortify Static Code Analyzer는 데이터 소스를 신뢰할 수 있는 것으로 판단하지 않습니다.

2. 데이터를 사용하여 SQL 쿼리를 동적으로 생성합니다.



예제 1: 다음 코드는 지정된 이름과 일치하는 항목을 검색하는 SQL 쿼리를 동적으로 생성하고 실행합니다. 쿼리는 표시되는 항목을 항목 소유자가 현재 인증된 사용자의 이름과 일치하는 항목으로 제한합니다.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '"
				+ userName + "' AND itemname = '"
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
...


쿼리는 다음 코드를 실행하려고 합니다.


	SELECT * FROM items
	WHERE owner = &lt;userName&gt;
	AND itemname = &lt;itemName&gt;;


하지만 상수인 기본 쿼리 문자열과 사용자 입력 문자열을 연결하여 쿼리를 동적으로 생성하기 때문에, 쿼리는 itemName에 작은따옴표가 들어 있지 않은 경우에만 정확하게 동작합니다. 사용자 이름이 wiley인 공격자가 itemName에 문자열 "name' OR 'a'='a"를 입력하면 쿼리는 다음과 같이 생성됩니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';


OR 'a'='a' 조건을 추가하면 where 절이 항상 true로 평가하기 때문에 쿼리는 훨씬 간단한 다음 쿼리와 논리적으로 동일하게 됩니다.


	SELECT * FROM items;


공격자는 이렇게 쿼리를 단순화하여 쿼리가 인증된 사용자가 소유한 항목만 반환해야 한다는 요구 사항을 무시할 수 있습니다. 이제 쿼리는 지정된 소유자와 관계없이 items 테이블에 저장된 모든 항목을 반환합니다.

예제 2: 이 예제는 Example 1에서 생성하여 수행한 쿼리에 또 다른 악성 값이 전달될 때의 결과를 검토합니다. 사용자 이름이 wiley인 공격자가 itemName에 문자열 "name'; DELETE FROM items; --"를 입력하면 쿼리는 다음과 같은 두 개의 쿼리가 됩니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'


Microsoft(R) SQL Server 2000을 포함한 많은 데이터베이스 서버에서 여러 SQL 문을 세미콜론으로 구분하여 한꺼번에 실행하는 것을 허용합니다. 이 공격 문자열은 세미콜론으로 구분한 문에 대한 일괄 실행을 허용하지 않는 Oracle 및 기타 데이터베이스 서버에서는 오류를 일으키지만 일괄 실행을 허용하는 데이터베이스에서는 공격자가 이런 종류의 공격으로 데이터베이스에 대해 임의의 명령을 실행할 수 있습니다.

마지막의 하이픈 쌍(--)을 보겠습니다. 이는 대부분의 데이터베이스 서버에서 해당 문에 대한 나머지 부분을 주석으로 처리하여 실행하지 말라는 의미로 해석됩니다[4]. 이 경우, 이 주석 문자는 수정된 쿼리에서 마지막의 작은따옴표 한쪽을 제거하는 역할을 합니다. 주석을 이런 식으로 사용할 수 없는 데이터베이스에서도 Example 1에서 사용된 것과 유사한 속임수를 사용하면 대부분의 공격이 효과를 거둘 수 있습니다. 공격자가 문자열 "name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a"를 입력하여 다음 세 가지 유효한 문을 만드는 경우입니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';


모바일 환경에서는 SQL Injection과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString("itemName");
        String query = "SELECT * FROM items WHERE owner = '"
                                + userName + "' AND itemname = '"
                                + itemName + "'";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, null);
...


SQL Injection 공격을 방지하는 한 가지 기존의 접근 방식은 공격을 입력값 검증 문제로 처리하고 안전한 값 목록(허용 목록)의 문자만 받거나 악의적일 가능성이 있는 값 목록(거부 목록)을 식별하여 이스케이프 처리하는 것입니다. 허용 목록 검사는 엄격한 입력값 검증 규칙을 이행하는 매우 효율적인 수단이 되기도 하지만, 매개 변수가 있는 SQL 문은 유지 관리가 쉽고 보다 강력한 보안을 제공할 수 있습니다. 대부분의 경우 거부 목록 구현은 SQL Injection 공격 방지의 효과를 떨어뜨리는 허점이 아주 많습니다. 예를 들어, 공격자는 다음과 같이 할 수 있습니다.

- 따옴표로 묶지 않은 필드를 노립니다.
- 이스케이프 처리된 메타 문자를 사용할 필요가 없는 방법을 찾습니다.
- 저장 프로시저(Stored procedure)를 사용하여 삽입된 메타 문자를 숨깁니다.

SQL 쿼리에 입력할 때 수동으로 문자를 이스케이프 처리하는 방법도 있지만 이것으로 SQL injection 공격으로부터 응용 프로그램을 보호할 수는 없습니다.

SQL injection 공격을 다루는 데 주로 제시되는 다른 솔루션은 저장 프로시저(stored procedure)를 사용하는 것입니다. 저장 프로시저(Stored procedure)는 일부 유형의 SQL injection 공격은 막을 수 있지만 다른 많은 유형은 막지 못합니다. 저장 프로시저(Stored procedure)는 일반적으로 매개 변수에 전달되는 SQL 문의 유형을 제한하여 SQL injection 공격을 막습니다. 하지만 이 제약을 피할 수 있는 많은 방법이 있어 수많은 비정상적인 문을 저장 프로시저(Stored procedure)에 전달할 수 있습니다. 되풀이하지만, 저장 프로시저(Stored procedure)는 일부 익스플로이트는 막을 수 있지만 응용 프로그램을 SQL injection 공격에 대해 안전하게 보호할 수는 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>SQL injection 취약점의 원인은 공격자가 SQL 쿼리의 컨텍스트를 변경하여 프로그래머가 데이터로 해석되기를 바라는 값을 명령으로 해석되도록 만들 수 있다는 점입니다. SQL 쿼리를 생성할 때, 프로그래머는 무엇이 명령으로 해석되어야 하고 무엇이 데이터로 해석되어야 하는지 알고 있습니다. 매개 변수가 있는 SQL 문은 데이터 위주의 컨텍스트 변경을 허용하지 않고 거의 모든 SQL injection 공격을 방지하여 이를 이행합니다. 매개 변수가 있는 SQL 문은 일반 SQL 문자열을 사용하여 생성되지만, 사용자가 제공하는 데이터를 포함해야 하는 경우에 이후에 삽입되는 데이터의 자리 표시자인 바인딩 매개 변수를 생성합니다. 바인딩 매개 변수를 사용하면 프로그램이 명령으로 처리해야 할 것과 데이터로 처리해야 할 것을 데이터베이스에 명시적으로 지정할 수 있습니다. 프로그램이 문을 실행할 준비가 되면 각 바인딩 매개 변수에 사용할 런타임 값을 데이터베이스에 지정하여 데이터가 명령으로 해석될 위험을 피할 수 있습니다. 

사용자가 제공하는 문자열을 연결하는 대신 매개 변수가 있는 SQL 문을 사용하도록 다음과 같이 예제 1을 다시 작성할 수 있습니다.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query =
        	"SELECT * FROM items WHERE itemname=? AND owner=?";
	PreparedStatement stmt = conn.prepareStatement(query);
	stmt.setString(1, itemName);
	stmt.setString(2, userName);
	ResultSet results = stmt.execute();
...


Android에 해당하는 코드는 다음과 같습니다.


...
	PasswordAuthentication pa = authenticator.getPasswordAuthentication();
	String userName = pa.getUserName();
	String itemName = this.getIntent().getExtras().getString("itemName");
	String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
	SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
	Cursor c = db.rawQuery(query, new Object[]{itemName, userName});
...


흔히 보고서 생성 코드에서 볼 수 있는 복잡한 시나리오에서는 WHERE 절의 동적 제약 조건 추가와 같이, SQL 문의 명령 구조가 결정되는 사용자 입력이 필요합니다. 그렇다고 이 요구 사항이 사용자 입력을 연결하여 쿼리 문자열을 만드는 것을 정당화할 수는 없습니다. 사용자 입력을 SQL 문 명령 구조에 적용해야 하는 경우 간접 참조를 사용하여 SQL injection 공격을 예방합니다. 즉, SQL 문에 포함시킬 여러 요소에 해당하는 유효한 문자열 집합을 만듭니다. 문을 만들 때 사용자 입력을 사용하여 이 응용 프로그램 제어 값 집합에서 값을 선택합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 이 때, 흔히 저지르는 실수는 사용자가 제어하는 문자열을 연결하여 생성한, 매개 변수가 있는 SQL 문을 사용하는 것입니다. 물론 이렇게 하면 매개 변수가 있는 SQL 문을 사용하는 목적이 무산됩니다. SQL 문을 형성하는 문자열이 응용 프로그램에서 제어하는 상수인지 확신할 수 없는 경우, 문자열이 SQL 문자열로 직접 실행되지 않기 때문에 안전하다고 가정할 수 없습니다. SQL 문에서 사용자 제어 문자열의 모든 사용을 철저하게 조사하고 쿼리의 의미를 수정하는 데 사용되는 일이 없는지 확인해야 합니다.

2. 데이터가 클래스의 공용 비 final 문자열 필드에서 오는 경우 이 데이터는 신뢰할 수 없습니다. 이러한 유형의 필드는 알려지지 않은 소스에 의해 수정될 수 있습니다.

3. SQL Injection 문제는 데이터 흐름 수정 작업 후에도 계속해서 보고될 수 있습니다(우선 순위 값은 감소). Fortify Static Code Analyzer에서 사용자 제어 입력이 SQL 문 구성에 사용되고 있다는 분명한 데이터 흐름 증거가 발견되면 높음/심각 우선 순위의 데이터 흐름 문제가 보고됩니다. Fortify Static Code Analyzer에서 데이터 소스를 결정할 수 없고 소스가 동적으로 변경될 수 있는 경우 낮음/중간 우선 순위의 의미 체계 문제가 보고됩니다. 이 전략은 SQL Injection과 같이 악용의 잠재적 영향이 거짓 긍정 문제를 감사하는 불편함보다 큰 일부 취약성 범주에 채택되었습니다.

4. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>27</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="67D43BA273CF03F2493177A252A49395" ruleID="5870A527-08AF-452C-84B2-7F6C360CA7EF">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Servers.java의 73 줄에서 sort() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>Servers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      try (var statement =
          connection.prepareStatement(
              "select id, hostname, ip, mac, status, description from SERVERS where status &lt;&gt; 'out"
                  + " of order' order by "
                  + column)) {</Snippet>
<TargetFunction>java.sql.Connection.prepareStatement()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Servers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java</FilePath>
<LineStart>67</LineStart>
<Snippet>  @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
  @ResponseBody
  public List&lt;Server&gt; sort(@RequestParam String column) throws Exception {
    List&lt;Server&gt; servers = new ArrayList&lt;&gt;();
</Snippet>
<TargetFunction>sort(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E2A91A2DB501E815808B69C9773BB394" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 78 줄에서 injectableQueryConfidentiality() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>78</LineStart>
<Snippet>                ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
        log(connection, query);
        ResultSet results = statement.executeQuery(query);

        if (results.getStatement() != null) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack8")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryConfidentiality(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A95E4E2C2316D4086848A23257634FE0" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson2.java의 65 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java</FilePath>
<LineStart>65</LineStart>
<Snippet>    try (var connection = dataSource.getConnection()) {
      Statement statement = connection.createStatement(TYPE_SCROLL_INSENSITIVE, CONCUR_READ_ONLY);
      ResultSet results = statement.executeQuery(query);
      StringBuilder output = new StringBuilder();
</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java</FilePath>
<LineStart>58</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack2")
  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A115AB9AF8BB4D2B3C3309EC643177FA" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 78 줄에서 injectableQueryConfidentiality() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>78</LineStart>
<Snippet>                ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
        log(connection, query);
        ResultSet results = statement.executeQuery(query);

        if (results.getStatement() != null) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack8")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryConfidentiality(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="AA6350CFFFB75E79ADDD323BCE2003B4" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionChallenge.java의 69 줄에서 registerNewUser() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>69</LineStart>
<Snippet>            "select userid from sql_challenge_users where userid = '" + username_reg + "'";
        Statement statement = connection.createStatement();
        ResultSet resultSet = statement.executeQuery(checkUserQuery);

        if (resultSet.next()) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>57</LineStart>
<Snippet>  @ResponseBody
  public AttackResult registerNewUser(
      @RequestParam String username_reg,
      @RequestParam String email_reg,
      @RequestParam String password_reg)</Snippet>
<TargetFunction>registerNewUser(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="EDBAAB5108597B4451A27BDFF5AA4B0C" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson5a.java의 67 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>67</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet results = statement.executeQuery(query);

        if ((results != null) &amp;&amp; (results.first())) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>55</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(
      @RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
    return injectableQuery(account + " " + operator + " " + injection);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5732568640D15D8C8500307C1C619EC5" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson5.java의 80 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java</FilePath>
<LineStart>80</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        statement.executeQuery(query);
        if (checkSolution(connection)) {
          return success(this).build();</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java</FilePath>
<LineStart>70</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack5")
  @ResponseBody
  public AttackResult completed(String query) {
    createUser();
    return injectableQuery(query);</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F4D9FB48336E207FE2E2418D6367AD9C" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson4.java의 62 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>62</LineStart>
<Snippet>      try (Statement statement =
          connection.createStatement(TYPE_SCROLL_INSENSITIVE, CONCUR_READ_ONLY)) {
        statement.executeUpdate(query);
        connection.commit();
        ResultSet results = statement.executeQuery("SELECT phone from employees;");</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>54</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack4")
  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9CAECD3FE18F3237CBE89DA0E2EF6539" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 158 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>158</LineStart>
<Snippet>    try {
      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack8")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryConfidentiality(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9EAB8D48586C3E656E1204CEAE97FC5D" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson6a.java의 74 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>74</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        ResultSet results = statement.executeQuery(query);

        if ((results != null) &amp;&amp; results.first()) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlOnlyInputValidationOnKeywords.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java</FilePath>
<LineStart>52</LineStart>
<Snippet>  @ResponseBody
  public AttackResult attack(
      @RequestParam("userid_sql_only_input_validation_on_keywords") String userId) {
    userId = userId.toUpperCase().replace("FROM", "").replace("SELECT", "");
    if (userId.contains(" ")) {</Snippet>
<TargetFunction>attack(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F199C891E7983438FDA83008DC25DE83" ruleID="5870A527-08AF-452C-84B2-7F6C360CA7EF">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson5b.java의 66 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>66</LineStart>
<Snippet>      PreparedStatement query =
          connection.prepareStatement(
              queryString, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);

      int count = 0;</Snippet>
<TargetFunction>java.sql.Connection.prepareStatement()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(
      @RequestParam String userid, @RequestParam String login_count, HttpServletRequest request)
      throws IOException {
    return injectableQuery(login_count, userid);</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="41FF09A9F351D84C373AD5F15729B484" ruleID="4B673A45-9AD5-4CBA-945B-11A3702CDF57">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>JWTHeaderKIDEndpoint.java의 91 줄에서 resolveSigningKeyBytes() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTHeaderKIDEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpoint.java</FilePath>
<LineStart>91</LineStart>
<Snippet>                              connection
                                  .createStatement()
                                  .executeQuery(
                                      "SELECT key FROM jwt_keys WHERE id = '" + kid + "'");
                          while (rs.next()) {</Snippet>
<TargetFunction>executeQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2FCCFCD72BC9F30C2178EBDB9A1CAF02" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 158 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>158</LineStart>
<Snippet>    try {
      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack9")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryIntegrity(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9E74B2D7F1DFBC0DB1F379F6F06755E3" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson6a.java의 74 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>74</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        ResultSet results = statement.executeQuery(query);

        if ((results != null) &amp;&amp; results.first()) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  @PostMapping("/SqlInjectionAdvanced/attack6a")
  @ResponseBody
  public AttackResult completed(@RequestParam(value = "userid_6a") String userId) {
    return injectableQuery(userId);
    // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F15838C8B29F1BFFF806C03B20CDCFC7" ruleID="4B673A45-9AD5-4CBA-945B-11A3702CDF57">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>LessonConnectionInvocationHandler.java의 27 줄에서 invoke() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LessonConnectionInvocationHandler.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/lessons/LessonConnectionInvocationHandler.java</FilePath>
<LineStart>27</LineStart>
<Snippet>    if (authentication != null &amp;&amp; authentication.getPrincipal() instanceof WebGoatUser user) {
      try (var statement = targetConnection.createStatement()) {
        statement.execute("SET SCHEMA \"" + user.getUsername() + "\"");
      }
    }</Snippet>
<TargetFunction>execute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="46BC2D367EBCFDEA0966E114C8607DB8" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson5a.java의 67 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>67</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet results = statement.executeQuery(query);

        if ((results != null) &amp;&amp; (results.first())) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>55</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(
      @RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
    return injectableQuery(account + " " + operator + " " + injection);
  }</Snippet>
<TargetFunction>completed(2)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A4AAB3F4B0AAC9BB5B7D9D572EA71AB3" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson9.java의 76 줄에서 injectableQueryIntegrity() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>76</LineStart>
<Snippet>        Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
        SqlInjectionLesson8.log(connection, query);
        ResultSet results = statement.executeQuery(query);
        var test = results.getRow() != 0;
        if (results.getStatement() != null) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack9")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryIntegrity(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="281AB9A5C90EFF539D82092D9F6AB007" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson9.java의 76 줄에서 injectableQueryIntegrity() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>76</LineStart>
<Snippet>        Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
        SqlInjectionLesson8.log(connection, query);
        ResultSet results = statement.executeQuery(query);
        var test = results.getRow() != 0;
        if (results.getStatement() != null) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack9")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryIntegrity(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F0C8E5A5EB7D1749BA1E248DF7710239" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson3.java의 63 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>63</LineStart>
<Snippet>        Statement checkStatement =
            connection.createStatement(TYPE_SCROLL_INSENSITIVE, CONCUR_READ_ONLY);
        statement.executeUpdate(query);
        ResultSet results =
            checkStatement.executeQuery("SELECT * FROM employees WHERE last_name='Barnett';");</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack3")
  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="80C036C93DD83B2F7E7207DF586D92C1" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 158 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>158</LineStart>
<Snippet>    try {
      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack8")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryConfidentiality(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C279E3338DB7A7B1A0A06A17D4B965EF" ruleID="02A6B1B6-DDFC-4078-A7D7-405DAA9EE672">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>UserService.java의 52 줄에서 createLessonsForUser() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>UserService.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/users/UserService.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
  private void createLessonsForUser(WebGoatUser webGoatUser) {
    jdbcTemplate.execute("CREATE SCHEMA \"" + webGoatUser.getUsername() + "\" authorization dba");
    flywayLessons.apply(webGoatUser.getUsername()).migrate();
  }</Snippet>
<TargetFunction>execute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FBBDDE6C4DB5F6B56E0BB6101ED07D15" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson10.java의 71 줄에서 injectableQueryAvailability() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>71</LineStart>
<Snippet>            connection.createStatement(
                ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
        ResultSet results = statement.executeQuery(query);

        if (results.getStatement() != null) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>58</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack10")
  @ResponseBody
  public AttackResult completed(@RequestParam String action_string) {
    return injectableQueryAvailability(action_string);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="12FBD812EE5474630BFA107DA592E31A" ruleID="5870A527-08AF-452C-84B2-7F6C360CA7EF">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Assignment5.java의 63 줄에서 login() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>Assignment5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java</FilePath>
<LineStart>63</LineStart>
<Snippet>                  + username_login
                  + "' and password = '"
                  + password_login
                  + "'");
      ResultSet resultSet = statement.executeQuery();</Snippet>
<TargetFunction>java.sql.Connection.prepareStatement()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Assignment5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java</FilePath>
<LineStart>50</LineStart>
<Snippet>  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
      return failed(this).feedback("required4").build();</Snippet>
<TargetFunction>login(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="299A26DFCE70BE25D6F4CC8CC7F3DECB" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 158 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>158</LineStart>
<Snippet>    try {
      Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack9")
  @ResponseBody
  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
    return injectableQueryIntegrity(name, auth_tan);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8314159B7C4111BF8FD08A643E68F862" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson5a.java의 67 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>67</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
        ResultSet results = statement.executeQuery(query);

        if ((results != null) &amp;&amp; (results.first())) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java</FilePath>
<LineStart>55</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(
      @RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
    return injectableQuery(account + " " + operator + " " + injection);
  }</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="335B38300BD8C08EC7CA2C4E1343A7B0" ruleID="5870A527-08AF-452C-84B2-7F6C360CA7EF">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Assignment5.java의 63 줄에서 login() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>Assignment5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java</FilePath>
<LineStart>63</LineStart>
<Snippet>                  + username_login
                  + "' and password = '"
                  + password_login
                  + "'");
      ResultSet resultSet = statement.executeQuery();</Snippet>
<TargetFunction>java.sql.Connection.prepareStatement()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Assignment5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java</FilePath>
<LineStart>50</LineStart>
<Snippet>  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
      return failed(this).feedback("required4").build();</Snippet>
<TargetFunction>login(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="AF4D42AECC02E7DB3FE084E346D3287A" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson6a.java의 74 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>74</LineStart>
<Snippet>          connection.createStatement(
              ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {
        ResultSet results = statement.executeQuery(query);

        if ((results != null) &amp;&amp; results.first()) {</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlOnlyInputValidation.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java</FilePath>
<LineStart>47</LineStart>
<Snippet>  @PostMapping("/SqlOnlyInputValidation/attack")
  @ResponseBody
  public AttackResult attack(@RequestParam("userid_sql_only_input_validation") String userId) {
    if (userId.contains(" ")) {
      return failed(this).feedback("SqlOnlyInputValidation-failed").build();</Snippet>
<TargetFunction>attack(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="23">
                        <groupTitle>Password Management: Hardcoded Password</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, "scott", "tiger");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed("guest", "allow");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>23</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="462C8074F175D4FAA17F44C3DCCC5D31" ruleID="7EC36DF4-C7ED-406A-9579-74BB208AEB5B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>147</LineStart>
<Snippet>    ObjectMapper objectMapper = new ObjectMapper();

    var loginJson = Map.of("user", "Jerry", "password", PASSWORD);
    MvcResult result =
        mockMvc</Snippet>
<TargetFunction>FunctionCall: of()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="974335619A467F7F9B56DA3845D1ABED" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>IDORLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/idor/IDORLogin.java</FilePath>
<LineStart>46</LineStart>
<Snippet>
    idorUserInfo.put("tom", new HashMap&lt;String, String&gt;());
    idorUserInfo.get("tom").put("password", "cat");
    idorUserInfo.get("tom").put("id", "2342384");
    idorUserInfo.get("tom").put("color", "yellow");</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="73BB11B367C51576A5F497E90D73610B" ruleID="9C5BD1B5-C296-48d4-B5F5-5D2958661BC4">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>91</LineStart>
<Snippet>  void validLoginWithoutCookieTest() throws Exception {
    String username = "webgoat";
    String password = "webgoat";

    ResultActions result =</Snippet>
<TargetFunction>VariableAccess: password</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="62C71C01EFEA0CD0882A90B11D1A89C9" ruleID="7EC36DF4-C7ED-406A-9579-74BB208AEB5B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SessionManagementIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/SessionManagementIntegrationTest.java</FilePath>
<LineStart>42</LineStart>
<Snippet>    checkAssignment(
        url(HIJACK_LOGIN_CONTEXT_PATH),
        Map.of("username", "webgoat", "password", "webgoat"),
        false);
  }</Snippet>
<TargetFunction>FunctionCall: of()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="14EEAFE363CCE0DDAAC2849F8E17A5C3" ruleID="9C5BD1B5-C296-48d4-B5F5-5D2958661BC4">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java</FilePath>
<LineStart>58</LineStart>
<Snippet>
  protected String getPassword() {
    String password = "dave";
    try (Connection connection = dataSource.getConnection()) {
      String query = "SELECT password FROM user_system_data WHERE user_name = 'dave'";</Snippet>
<TargetFunction>VariableAccess: password</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5254D15994D4835076B12E4A2AEBEDBD" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>GeneralLessonIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/GeneralLessonIntegrationTest.java</FilePath>
<LineStart>109</LineStart>
<Snippet>    params.clear();
    params.put("username", "CaptainJack");
    params.put("password", "BlackPearl");
    checkAssignment(url("InsecureLogin/task"), params, true);
    checkResults("/InsecureLogin/");</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1517895363BE40D488BD049374EE96F4" ruleID="9C5BD1B5-C296-48d4-B5F5-5D2958661BC4">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>UserServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/user/UserServiceTest.java</FilePath>
<LineStart>71</LineStart>
<Snippet>  public void testAddUser() {
    var username = "guest";
    var password = "guest";

    sut.addUser(username, password);</Snippet>
<TargetFunction>VariableAccess: password</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9E3FA410774E0301572C215A297A8F38" ruleID="7EC36DF4-C7ED-406A-9579-74BB208AEB5B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>58</LineStart>
<Snippet>
    // First login to obtain tokens for Jerry
    var loginJson = Map.of("user", "Jerry", "password", PASSWORD);
    MvcResult result =
        mockMvc</Snippet>
<TargetFunction>FunctionCall: of()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="08E464DB4030D169BE8CFDF55BE3CC03" ruleID="7EC36DF4-C7ED-406A-9579-74BB208AEB5B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>172</LineStart>
<Snippet>    ObjectMapper objectMapper = new ObjectMapper();

    var loginJson = Map.of("user", "Jerry", "password", PASSWORD + "wrong");
    mockMvc
        .perform(</Snippet>
<TargetFunction>FunctionCall: of()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5A389FAFC99B8C39EF568BE638A67F07" ruleID="C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SolutionConstants.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/SolutionConstants.java</FilePath>
<LineStart>34</LineStart>
<Snippet>
  // TODO should be random generated when starting the server
  String PASSWORD = "!!webgoat_admin_1234!!";
}</Snippet>
<TargetFunction>FieldAccess: PASSWORD()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="864BA2FB17C54635573C8B5AC8D73F43" ruleID="F9D3C462-8D1E-4457-967F-9F082B973F88">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>InsecureLoginTask.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/insecurelogin/InsecureLoginTask.java</FilePath>
<LineStart>36</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(@RequestParam String username, @RequestParam String password) {
    if ("CaptainJack".equals(username) &amp;&amp; "BlackPearl".equals(password)) {
      return success(this).build();
    }</Snippet>
<TargetFunction>FunctionCall: equals()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="31F43353191ADCEEE7283AE66EDCC99F" ruleID="7EC36DF4-C7ED-406A-9579-74BB208AEB5B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>185</LineStart>
<Snippet>    ObjectMapper objectMapper = new ObjectMapper();

    var loginJson = Map.of("user", "Tom", "password", PASSWORD);
    mockMvc
        .perform(</Snippet>
<TargetFunction>FunctionCall: of()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="817AD0623F9246EDCB0ED24C2F124E92" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>IDORIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/IDORIntegrationTest.java</FilePath>
<LineStart>40</LineStart>
<Snippet>    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
    params.put("username", "tom");
    params.put("password", "cat");

    checkAssignment(url("IDOR/login"), params, true);</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="118412442D22D5B6238C7EED91DDC3AC" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>IDORLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/idor/IDORLogin.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
    idorUserInfo.put("bill", new HashMap&lt;String, String&gt;());
    idorUserInfo.get("bill").put("password", "buffalo");
    idorUserInfo.get("bill").put("id", "2342388");
    idorUserInfo.get("bill").put("color", "brown");</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F87DC75D61E21719332C16F6E7A88D5C" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>GeneralLessonIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/GeneralLessonIntegrationTest.java</FilePath>
<LineStart>119</LineStart>
<Snippet>    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
    params.clear();
    params.put("password", "ajnaeliclm^&amp;&amp;@kjn.");
    checkAssignment(url("SecurePasswords/assignment"), params, true);
    checkResults("SecurePasswords/");</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CC5962654F1B386AA820183318367164" ruleID="F9D3C462-8D1E-4457-967F-9F082B973F88">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>77</LineStart>
<Snippet>    String password = (String) json.get("password");

    if ("Jerry".equalsIgnoreCase(user) &amp;&amp; PASSWORD.equals(password)) {
      return ok(createNewTokens(user));
    }</Snippet>
<TargetFunction>FunctionCall: equals()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BE0E0E7FD09E16F40FCAAC1B2BF7069F" ruleID="9C5BD1B5-C296-48d4-B5F5-5D2958661BC4">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>UserServiceTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/user/UserServiceTest.java</FilePath>
<LineStart>49</LineStart>
<Snippet>  public void testLoadUserByUsername() {
    var username = "guest";
    var password = "123";
    WebGoatUser user = new WebGoatUser(username, password);
    when(mockUserRepository.findByUsername(username)).thenReturn(user);</Snippet>
<TargetFunction>VariableAccess: password</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F5631D831FB1F31A7FBA0618F96F4824" ruleID="7EC36DF4-C7ED-406A-9579-74BB208AEB5B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>PasswordResetLessonIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/PasswordResetLessonIntegrationTest.java</FilePath>
<LineStart>76</LineStart>
<Snippet>    checkAssignment(
        url("PasswordReset/reset/login"),
        Map.of("email", "tom@webgoat-cloud.org", "password", "123456"),
        true);
  }</Snippet>
<TargetFunction>FunctionCall: of()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EFD47ADFA94475F15FBE582A7C8D4178" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>199</LineStart>
<Snippet>    Map&lt;String, Object&gt; loginJson = new HashMap&lt;&gt;();
    loginJson.put("user", "Jerry");
    loginJson.put("password", PASSWORD);
    MvcResult result =
        mockMvc</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="29FF9EC250A65E78FFAF022F815A1479" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/CSRFIntegrationTest.java</FilePath>
<LineStart>212</LineStart>
<Snippet>    params.clear();
    params.put("username", "csrf-" + this.getUser());
    params.put("password", "password");

    // login and get the new cookie</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1A9FBA783AE5967CECAC76C20C2EEE9" ruleID="A79E289A-14D7-4dfd-8E34-F249133A69FE">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>jwt-refresh.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/js/jwt-refresh.js</FilePath>
<LineStart>10</LineStart>
<Snippet>        url: 'JWT/refresh/login',
        contentType: "application/json",
        data: JSON.stringify({user: user, password: "bm5nhSkxCXZkKRy4"})
    }).success(
        function (response) {</Snippet>
<TargetFunction>FieldAccess: password()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="200E9BF31D755418DAAD51C597A2F0D6" ruleID="60A3A244-EAE2-415D-A054-EDFF20D3E7AA">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>228</LineStart>
<Snippet>    Map&lt;String, Object&gt; loginJson = new HashMap&lt;&gt;();
    loginJson.put("user", "Jerry");
    loginJson.put("password", PASSWORD);
    MvcResult result =
        mockMvc</Snippet>
<TargetFunction>FunctionCall: put()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="36B1107F97CE968D3229BA608938C9FD" ruleID="C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>61</LineStart>
<Snippet>public class JWTRefreshEndpoint extends AssignmentEndpoint {

  public static final String PASSWORD = "bm5nhSkxCXZkKRy4";
  private static final String JWT_PASSWORD = "bm5n3SkxCX4kKRy4";
  private static final List&lt;String&gt; validRefreshTokens = new ArrayList&lt;&gt;();</Snippet>
<TargetFunction>FieldAccess: PASSWORD()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>System Information Leak: Internal</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>VulnerableTaskHolder.java의 readObject() 함수는 72 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>내부 정보는 인쇄나 로깅을 통해 시스템 데이터 또는 디버그 정보를 로컬 파일이나 콘솔, 화면으로 전송할 때 누출됩니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다.

예제 2: 다음 코드는 Android 플랫폼에서 catch된 예외의 스택 추적을 기록합니다.

...
try {
  ...
} catch (Exception e) {
    Log.e(TAG, Log.getStackTraceString(e));
}
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, "접근 거부" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>21</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D2B09386B55F327F3A7A7E852B14AD6C" ruleID="A2B6B2CF-FCAA-4632-825F-D6C48C52246E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 ProfileUploadRetrieval() 함수는 48 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>48</LineStart>
<Snippet>  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();
  }
</Snippet>
<TargetFunction>java.io.File.mkdirs()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FB53F1A9B594BB88E6C0C9F3419C7412" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson9.java의 injectableQueryIntegrity() 함수는 87 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>87</LineStart>
<Snippet>        }
      } catch (SQLException e) {
        System.err.println(e.getMessage());
        return failed(this)
            .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>87</LineStart>
<Snippet>        }
      } catch (SQLException e) {
        System.err.println(e.getMessage());
        return failed(this)
            .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="426BBA09D97AC9727822E70C67364C74" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 함수는 81 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>      Files.writeString(new File(targetDirectory, "secret.txt").toPath(), fileContents, UTF_8);
    } catch (IOException e) {
      log.error("Unable to write 'secret.txt' to '{}", targetDirectory);
    }
  }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  public BlindSendFileAssignment(
      @Value("${webgoat.user.directory}") String webGoatHomeDirectory, CommentsCache comments) {
    this.webGoatHomeDirectory = webGoatHomeDirectory;
    this.comments = comments;</Snippet>
<TargetFunction>BlindSendFileAssignment(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="011440C36FBFC5ECBAC42724AE4A1818" ruleID="A2B6B2CF-FCAA-4632-825F-D6C48C52246E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 함수는 76 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>76</LineStart>
<Snippet>    File targetDirectory = new File(webGoatHomeDirectory, "/XXE/" + user.getUsername());
    if (!targetDirectory.exists()) {
      targetDirectory.mkdirs();
    }
    try {</Snippet>
<TargetFunction>java.io.File.mkdirs()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  public BlindSendFileAssignment(
      @Value("${webgoat.user.directory}") String webGoatHomeDirectory, CommentsCache comments) {
    this.webGoatHomeDirectory = webGoatHomeDirectory;
    this.comments = comments;</Snippet>
<TargetFunction>BlindSendFileAssignment(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F7BB69097973E19A8835204A03540C40" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>CryptoUtilTest.java의 testSigningAssignment() 함수는 28 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoUtilTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cryptography/CryptoUtilTest.java</FilePath>
<LineStart>28</LineStart>
<Snippet>      assertTrue(CryptoUtil.verifyAssignment(modulus, signature, keyPair.getPublic()));
    } catch (Exception e) {
      log.error("signing failed", e);
      ;
      fail();</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CryptoUtilTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cryptography/CryptoUtilTest.java</FilePath>
<LineStart>28</LineStart>
<Snippet>      assertTrue(CryptoUtil.verifyAssignment(modulus, signature, keyPair.getPublic()));
    } catch (Exception e) {
      log.error("signing failed", e);
      ;
      fail();</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0163B3FB1A0662E57E51EF57D93348B6" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Salaries.java의 invoke() 함수는 108 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>108</LineStart>
<Snippet>      log.error("Unable to parse xml", e);
    } catch (IOException e) {
      log.error("Unable to read employees.xml at location: '{}'", d);
    }
    return json;</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>77</LineStart>
<Snippet>  public List&lt;Map&lt;String, Object&gt;&gt; invoke() {
    NodeList nodes = null;
    File d = new File(webGoatHomeDirectory, "ClientSideFiltering/employees.xml");
    XPathFactory factory = XPathFactory.newInstance();
    XPath path = factory.newXPath();</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="478828474694FB3714E756C9ADA707EA" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>VulnerableTaskHolder.java의 readObject() 함수는 72 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableTaskHolder.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java</FilePath>
<LineStart>72</LineStart>
<Snippet>        }
      } catch (IOException e) {
        log.error("IO Exception", e);
      }
    }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>VulnerableTaskHolder.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java</FilePath>
<LineStart>72</LineStart>
<Snippet>        }
      } catch (IOException e) {
        log.error("IO Exception", e);
      }
    }</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="58FFE65B1753205D1A03ACFCFA758A6E" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 getProfilePicture() 함수는 111 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>111</LineStart>
<Snippet>                  .getBytes());
    } catch (IOException | URISyntaxException e) {
      log.error("Image not found", e);
    }
</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>111</LineStart>
<Snippet>                  .getBytes());
    } catch (IOException | URISyntaxException e) {
      log.error("Image not found", e);
    }
</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FE7A26E94FA31AFB448B3007C02F4717" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson13.java의 completed() 함수는 70 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java</FilePath>
<LineStart>70</LineStart>
<Snippet>      return failed(this).build();
    } catch (SQLException e) {
      log.error("Failed", e);
      return (failed(this).build());
    }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson13.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java</FilePath>
<LineStart>70</LineStart>
<Snippet>      return failed(this).build();
    } catch (SQLException e) {
      log.error("Failed", e);
      return (failed(this).build());
    }</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0EE8F8E2C995EF964E360D59637AD183" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MD5.java의 main() 함수는 51 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MD5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java</FilePath>
<LineStart>51</LineStart>
<Snippet>          System.out.println(MD5.getHashString(new File(element)) + " " + element);
        } catch (IOException x) {
          System.err.println(x.getMessage());
        }
      }</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MD5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java</FilePath>
<LineStart>51</LineStart>
<Snippet>          System.out.println(MD5.getHashString(new File(element)) + " " + element);
        } catch (IOException x) {
          System.err.println(x.getMessage());
        }
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E14215FFE9B2BE8C058CAF98F186EE6E" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson10.java의 tableExists() 함수는 123 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>123</LineStart>
<Snippet>        return false;
      } else {
        System.err.println(e.getMessage());
        return false;
      }</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>123</LineStart>
<Snippet>        return false;
      } else {
        System.err.println(e.getMessage());
        return false;
      }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="14FED641766CF20EC2A352ED6F5B9A2C" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>StartWebGoat.java의 printStartUpMessage() 함수는 58 줄의 warn()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. warn()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>StartWebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/server/StartWebGoat.java</FilePath>
<LineStart>58</LineStart>
<Snippet>    log.warn(
        "Please browse to " + "{} to start using WebGoat...",
        sslEnabled ? url.replace("http", "https") : url);
  }
}</Snippet>
<TargetFunction>org.slf4j.Logger.warn()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>StartWebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/server/StartWebGoat.java</FilePath>
<LineStart>53</LineStart>
<Snippet>
  private static void printStartUpMessage(ApplicationContext webGoatContext) {
    var url = webGoatContext.getEnvironment().getProperty("webgoat.url");
    var sslEnabled =
        webGoatContext.getEnvironment().getProperty("server.ssl.enabled", Boolean.class);</Snippet>
<TargetFunction>org.springframework.core.env.PropertyResolver.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="2EF7E4FFF2E149AB75FD9461CBDC430A" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson8.java의 log() 함수는 160 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>160</LineStart>
<Snippet>      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());
    }
  }</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>160</LineStart>
<Snippet>      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());
    }
  }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="352BB674010552821C3AAB2F7074B2D2" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Requests.java의 toJsonString() 함수는 101 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Requests.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java</FilePath>
<LineStart>101</LineStart>
<Snippet>      return objectMapper.writeValueAsString(t);
    } catch (JsonProcessingException e) {
      log.error("Unable to create json", e);
    }
    return "No request(s) found";</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Requests.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java</FilePath>
<LineStart>101</LineStart>
<Snippet>      return objectMapper.writeValueAsString(t);
    } catch (JsonProcessingException e) {
      log.error("Unable to create json", e);
    }
    return "No request(s) found";</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8815C0D46B5F2C1C36E6182EABBECAA0" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 initAssignment() 함수는 59 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>59</LineStart>
<Snippet>        FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + ".jpg")));
      } catch (Exception e) {
        log.error("Unable to copy pictures" + e.getMessage());
      }
    }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>59</LineStart>
<Snippet>        FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + ".jpg")));
      } catch (Exception e) {
        log.error("Unable to copy pictures" + e.getMessage());
      }
    }</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="91C093A2B1504CAB5278B5BF40EBA2CE" ruleID="A2B6B2CF-FCAA-4632-825F-D6C48C52246E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MvcConfiguration.java의 createDirectory() 함수는 72 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MvcConfiguration.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java</FilePath>
<LineStart>72</LineStart>
<Snippet>    File file = new File(fileLocation);
    if (!file.exists()) {
      file.mkdirs();
    }
  }</Snippet>
<TargetFunction>java.io.File.mkdirs()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MvcConfiguration.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java</FilePath>
<LineStart>70</LineStart>
<Snippet>  @PostConstruct
  public void createDirectory() {
    File file = new File(fileLocation);
    if (!file.exists()) {
      file.mkdirs();</Snippet>
<TargetFunction>Read this.fileLocation()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1104C100A135F4F6414529D158F0EFB9" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>CryptoUtil.java의 signMessage() 함수는 72 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>72</LineStart>
<Snippet>      log.info("signe the signature with result: {}", signature);
    } catch (Exception e) {
      log.error("Signature signing failed", e);
    }
</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>72</LineStart>
<Snippet>      log.info("signe the signature with result: {}", signature);
    } catch (Exception e) {
      log.error("Signature signing failed", e);
    }
</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="856A5E671B54CF4512325C44774D9FEB" ruleID="79DB2AD7-A162-4148-BF74-46704F1DA5D4">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>PluginMessages.java의 refreshProperties() 함수는 68 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>PluginMessages.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/i18n/PluginMessages.java</FilePath>
<LineStart>68</LineStart>
<Snippet>      }
    } catch (IOException e) {
      logger.error("Unable to read plugin message", e);
    }
</Snippet>
<TargetFunction>org.apache.commons.logging.Log.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>PluginMessages.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/i18n/PluginMessages.java</FilePath>
<LineStart>68</LineStart>
<Snippet>      }
    } catch (IOException e) {
      logger.error("Unable to read plugin message", e);
    }
</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="79C0253D4538B21A6D60F7E600C64FB2" ruleID="A2B6B2CF-FCAA-4632-825F-D6C48C52246E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Salaries.java의 copyFiles() 함수는 62 줄의 mkdir()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdir()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>62</LineStart>
<Snippet>    File targetDirectory = new File(webGoatHomeDirectory, "/ClientSideFiltering");
    if (!targetDirectory.exists()) {
      targetDirectory.mkdir();
    }
    try {</Snippet>
<TargetFunction>java.io.File.mkdir()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>60</LineStart>
<Snippet>  public void copyFiles() {
    ClassPathResource classPathResource = new ClassPathResource("lessons/employees.xml");
    File targetDirectory = new File(webGoatHomeDirectory, "/ClientSideFiltering");
    if (!targetDirectory.exists()) {
      targetDirectory.mkdir();</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7F657B5AAC91B7B29A65E6A044135B85" ruleID="B227CB65-6F20-4472-BBB7-13E157F32F6E">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>CryptoUtil.java의 verifyMessage() 함수는 101 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>101</LineStart>
<Snippet>      log.info("Verified the signature with result: {}", result);
    } catch (Exception e) {
      log.error("Signature verification failed", e);
    }
</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>101</LineStart>
<Snippet>      log.info("Verified the signature with result: {}", result);
    } catch (Exception e) {
      log.error("Signature verification failed", e);
    }
</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FB53F1A9B594BB88E6C0C9F3419C7413" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson9.java의 injectableQueryIntegrity() 함수는 96 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>96</LineStart>
<Snippet>
    } catch (Exception e) {
      System.err.println(e.getMessage());
      return failed(this)
          .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>96</LineStart>
<Snippet>
    } catch (Exception e) {
      System.err.println(e.getMessage());
      return failed(this)
          .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>Credential Management: Hardcoded API Credentials</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>사용자 이름, 암호, API 키, API 기밀 및 API 토큰을 포함한 자격 증명을 하드코드하지 마십시오. 하드코드된 자격 증명은 모든 프로젝트 개발자에게 표시될 뿐만 아니라 업데이트하기가 매우 어렵습니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 자격 증명을 변경할 수 없습니다. 자격 증명이 손상되면 조직은 보안과 시스템 가용성 중 한 가지를 선택할 수밖에 없습니다.
        </Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>API 자격 증명이 런타임 환경에서만 사용할 수 있는 구성 파일 또는 환경 변수에서 로드되는지 확인하십시오.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>17</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CA54FDAC932BCD4A3B489F528404E4EE" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>logs.txt</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/images/logs.txt</FilePath>
<LineStart>2</LineStart>
<Snippet>
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] "GET /JWT/refresh/checkout?token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q HTTP/1.1" 401 242 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0" "-"
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] "POST /JWT/refresh/moveToCheckout HTTP/1.1" 200 12783 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0" "-"
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] "POST /JWT/refresh/login HTTP/1.1" 200 212 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0" "-"</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="2C1E6349742921204919004CD524D4AA" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTTokenTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/jwt/JWTTokenTest.java</FilePath>
<LineStart>55</LineStart>
<Snippet>    var token =
        JWTToken.decode(
            "eyJhbGciOiJIUzI1NiJ9.eyJ0ZXsdfdfsaasfddfasN0IjoidGVzdCJ9.KOobRHDYyaesV_doOk11XXGKSONwzllraAaqqM4VFE4",
            "");
</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="3C154FBEA12586A084F6DCEB4E28506D" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWT.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/html/JWT.html</FilePath>
<LineStart>388</LineStart>
<Snippet>        &lt;form class="attack-form" accept-charset="UNKNOWN"
              method="POST"
              action="JWT/kid/delete?token=eyJ0eXAiOiJKV1QiLCJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.CgZ27DzgVW8gzc0n6izOU638uUCi6UhiOJKYzoEZGE8"&gt;
            &lt;div class="container-fluid"&gt;
                &lt;div id="toast"&gt;&lt;/div&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="5DBAE29491A43198D37C134142E9962C" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTHeaderKIDEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpointTest.java</FilePath>
<LineStart>24</LineStart>
<Snippet>
  private static final String TOKEN_JERRY =
      "eyJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTNTEyIn0.eyJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImVtYWlsIjoiamVycnlAd2ViZ29hdC5jb20iLCJ1c2VybmFtZSI6IkplcnJ5In0.xBc5FFwaOcuxjdr_VJ16n8Jb7vScuaZulNTl66F2MWF1aBe47QsUosvbjWGORNcMPiPNwnMu1Yb0WZVNrp2ZXA";

  @BeforeEach</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="9BA635D40B3E0D829DE2E173790C8F15" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>goat.robot</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/robot/goat.robot</FilePath>
<LineStart>116</LineStart>
<Snippet>  Click Element  token
  Wait Until Element Is Enabled  token  5s
  Input Text     token  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
  Click Element  secretKey
  Input Text     secretKey  none</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="9AD2CC3BE2901750AC4C3B8686DF6E8E" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWT_libraries.adoc</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/documentation/JWT_libraries.adoc</FilePath>
<LineStart>40</LineStart>
<Snippet>[source]
----
var token = " eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.NFvYpuwbF6YWbPyaNAGEPw9wbhiQSovvSrD89B8K7Ng";

Jwts.parser().setSigningKey("test").parseClaimsJws(token);</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="38D8E52205AFEE98973E3228AA853161" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>133</LineStart>
<Snippet>  void checkoutWitRandomTokenShouldFail() throws Exception {
    String accessTokenTom =
        "eyJhbGciOiJIUzUxMiJ9.eyJpLXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q";
    mockMvc
        .perform(</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="0BC0679042E9C29E4DA86A1750E9941A" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWT_decode.adoc</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/documentation/JWT_decode.adoc</FilePath>
<LineStart>8</LineStart>
<Snippet>[source]
----
eyJhbGciOiJIUzI1NiJ9.ew0KICAiYXV0aG9yaXRpZXMiIDogWyAiUk9MRV9BRE1JTiIsICJST0xFX1VTRVIiIF0sDQogICJjbGllbnRfaWQiIDogIm15LWNsaWVudC13aXRoLXNlY3JldCIsDQogICJleHAiIDogMTYwNzA5OTYwOCwNCiAgImp0aSIgOiAiOWJjOTJhNDQtMGIxYS00YzVlLWJlNzAtZGE1MjA3NWI5YTg0IiwNCiAgInNjb3BlIiA6IFsgInJlYWQiLCAid3JpdGUiIF0sDQogICJ1c2VyX25hbWUiIDogInVzZXIiDQp9.9lYaULTuoIDJ86-zKDSntJQyHPpJ2mZAbnWRfel99iI
----
</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="65FC73115C3E56638423FF82FA2D9F14" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>121</LineStart>
<Snippet>  void checkoutWithTomsTokenFromAccessLogShouldFail() throws Exception {
    String accessTokenTom =
        "eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q";
    mockMvc
        .perform(</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="964B6489427B42AD93C00CD160F424D6" ruleID="C4BAD16D-847F-47D1-9B09-1B4E8FC9C2E4">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>test.yml</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.github/workflows/test.yml</FilePath>
<LineStart>66</LineStart>
<Snippet>                uses: joonvena/robotframework-reporter-action@v2.2
                with:
                    gh_access_token: ${{ secrets.GITHUB_TOKEN }}
                    report_path: 'robotreport'</Snippet>
<TargetFunction>ConfigPair()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5649974588038E6A3FFD647DDC13F5F2" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWT_signing_solution.adoc</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/documentation/JWT_signing_solution.adoc</FilePath>
<LineStart>35</LineStart>
<Snippet>GET http://localhost:8080/WebGoat/JWT/votings/login?user=Tom HTTP/1.1

access_token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE2MDgxMjg1NjYsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.rTSX6PSXqUoGUvQQDBiqX0re2BSt7s2-X6FPf34Qly9SMpqIUSP8jykedJbjOBNlM3_CTjgk1SvUv48Pz8zIzA
----
</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="27F84DAA62F1313025F6124DBE66E787" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWT.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/html/JWT.html</FilePath>
<LineStart>322</LineStart>
<Snippet>        &lt;form class="attack-form" accept-charset="UNKNOWN"
              method="POST"
              action="JWT/final/delete?token=eyJ0eXAiOiJKV1QiLCJqa3UiOiJodHRwczovL2NvZ25pdG8taWRwLnVzLWVhc3QtMS5hbWF6b25hd3MuY29tL3dlYmdvYXQvLndlbGwta25vd24vandrcy5qc29uIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.SabvRaYSCW7xI0ueca19TL1e66cJIJaxRiydK2G5lgFMIbL5gQQjE6022HEha9HcprqFXyHbtXrQWRXAp6Gjaf5zs8LUMBMARWjEr8TS43ihguarmLLmvBCoqjiZY39o4EcEjEH9xAoyIYR_Trh7kXn6JVU-8MM76l9IOcYIJ9c8LqT1ERNmbCqtI4PP0tdqCy99nHhqlxSCVXaGDF0jMHV5kjCDSHNYib9riy9xZ63Sztify-bwPqRvxmaShPYtG4BBM_wOGlg-BYTTuws-6yISMfTB5U1WBDwLr6dLU123TGO26wCVBgTKbA0KKG94-ToOcneWLOTEacEfQQOlIQ"&gt;
            &lt;div class="container-fluid"&gt;
                &lt;div id="toast"&gt;&lt;/div&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="BF83EC97A754E794EAC224927C2B54A0" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWT_libraries.adoc</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/documentation/JWT_libraries.adoc</FilePath>
<LineStart>28</LineStart>
<Snippet>[source]
----
var token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.NFvYpuwbF6YWbPyaNAGEPw9wbhiQSovvSrD89B8K7Ng";

Jwts.parser().setSigningKey("test").parseClaimsJws(token);</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="5322363F1B915DDF3E0C8704F6548F7C" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTRefreshEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java</FilePath>
<LineStart>75</LineStart>
<Snippet>    // token of Jerry
    String accessTokenTom =
        "eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q";
    Map&lt;String, Object&gt; refreshJson = new HashMap&lt;&gt;();
    refreshJson.put("refresh_token", refreshToken);</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="8EC6E0BCC135AC54DD0FAB390A383443" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTTokenTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/jwt/JWTTokenTest.java</FilePath>
<LineStart>30</LineStart>
<Snippet>    assertThat(token.getEncoded())
        .isEqualTo(
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoidGVzdCJ9.axNp9BkswwK_YRF2URJ5P1UejQNYZbK4qYcMnkusg6I");
  }
</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="F89CF6F3F568BBA7A3D271A5D8EF9C35" ruleID="6D984A17-AB12-483D-99B8-93B7F7D4A242">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>WebGoatLabels.properties</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/i18n/WebGoatLabels.properties</FilePath>
<LineStart>22</LineStart>
<Snippet>jwt-refresh-hint2=The token from the access log is no longer valid, can you find a way to refresh it?
jwt-refresh-hint3=The endpoint for refreshing a token is 'JWT/refresh/newToken'
jwt-refresh-hint4=Use the found access token in the Authorization: Bearer header and use your own refresh token
jwt-refresh-not-tom=User is not Tom but {0}, please try again
jwt-refresh-alg-none=Nicely found! You solved the assignment with 'alg: none' can you also solve it by using the refresh token?</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="44BA4A620EC494D0F77384CA6E0401FA" ruleID="5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C">
                            <Category>Credential Management: Hardcoded API Credentials</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>JWTTokenTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/webwolf/jwt/JWTTokenTest.java</FilePath>
<LineStart>44</LineStart>
<Snippet>    var token =
        JWTToken.decode(
            "eyJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoidGVzdCJ9.KOobRHDYyaesV_doOk11XXGKSONwzllraAaqqM4VFE4",
            "test");
</Snippet>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>Insecure Randomness</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Insecure Randomness 오류는 보안이 중요한 상황에서 예측 가능한 값을 생성할 수 있는 함수를 난수 발생원으로 사용할 때 발생합니다.

컴퓨터는 결정론을 사용하는 시스템이기 때문에 진정한 무작위성을 구현할 수 없습니다. PRNG(의사 난수 발생기)는 시드로부터 이후의 값을 계산하는 알고리즘을 사용하여 무작위성에 최대한 접근합니다.

PRNG는 두 가지 종류가 있는데 통계적 PRNG 및 암호화 PRNG입니다. 통계적 PRNG는 유용한 통계적 속성을 제공하지만 출력을 쉽게 예측할 수 있고 재생하기 쉬운 숫자 스트림을 만들기 때문에 보안이 예측할 수 없는 값을 생성하는 방식에 의존하는 경우 사용하기 부적합합니다. 암호화 PRNG는 예측하기 어려운 출력을 생성하여 이 문제를 해결합니다. 암호화 값이 안전하려면 공격자가 생성된 무작위 값과 실제적인 무작위 값을 구분하는 것이 불가능하거나 아주 어려워야 합니다. 일반적으로 PRNG 알고리즘이 안전한 암호화로 알려져 있지 않은 경우에는 통계적 PRNG를 가리키는 것일 수 있는데, 이 PRNG는 보안이 중요한 상황일 때 사용해서는 안 됩니다. 이 경우 통계적 PRNG를 사용하면 추측하기 쉬운 임시 암호, 예측 가능한 암호화 키, 세션 하이재킹, DNS 스푸핑 등의 심각한 취약점을 유발할 수 있습니다.

예제: 다음 코드는 통계적 PRNG를 사용하여 구입 후 일정 기간 동안 활성 상태를 유지하는 영수증의 URL을 작성합니다.


String GenerateReceiptURL(String baseUrl) {
    Random ranGen = new Random();
    ranGen.setSeed((new Date()).getTime());
    return (baseUrl + ranGen.nextInt(400000000) + ".html");
}


이 코드는 Random.nextInt() 함수를 사용하여 생성되는 영수증 페이지에 대한 "고유한" ID를 생성합니다. Random.nextInt()은 통계적 PRNG이므로 생성되는 문자열을 공격자가 쉽게 추축할 수 있습니다. 영수증 시스템의 기본 설계에도 오류가 있지만 암호화 PRNG와 같이 예측 가능한 영수증 ID를 생성하지 않는 난수 발생기를 사용했다면 훨씬 안전했을 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>가장 보안이 민감한 사안에 무작위성을 적용하는 것처럼, 예측 불가능성이 필수적일 때 암호화 PRNG를 사용합니다. 선택한 PRNG에 관계없이 항상 알고리즘의 시드를 생성하기에 충분한 엔트로피가 있는 값을 사용합니다. (현재 시간과 같은 값은 미미한 엔트로피 수준만 제공하므로 사용하지 마십시오.)

Java 언어는 java.security.SecureRandom에 암호화 PRNG를 제공합니다. java.security의 다른 알고리즘 기반 클래스와 마찬가지로 SecureRandom도 특정 알고리즘 집합에 구현과 관계 없는 래퍼를 제공합니다. SecureRandom.getInstance()를 사용하여 SecureRandom 개체의 인스턴스를 요청함으로써 알고리즘의 특정 구현을 요청할 수 있습니다. 알고리즘을 사용할 수 있는 경우 알고리즘은 SecureRandom 개체로 제공됩니다. 알고리즘을 사용할 수 없거나 특정 구현을 지정하지 않은 경우, 시스템이 선택한 SecureRandom 구현이 제공됩니다. 

Sun은 SHA1PRNG라는 Java 배포판을 사용하여 단일 SecureRandom 구현을 제공하는데 그 계산 과정을 다음과 같이 설명합니다.

"매 연산마다 1씩 증가하는 64비트 카운터와 연결된 실제 무작위 시드 값에 대해 SHA-1 해시를 계산합니다. 160비트 SHA-1 출력부터 64비트만 사용됩니다[1]." 

하지만 Sun의 SHA1PRNG 알고리즘 구현에 대한 구체적인 내용은 상세하게 설명되어 있지 않고 구현에 사용한 엔트로피 소스가 불확실하며, 따라서 출력의 실제 무작위성이 어떤 수준인지도 불확실합니다. 웹 상에 Sun 구현에 대한 추측이 난무하지만 알고리즘의 암호화가 강력하고 보안에 민감한 상황에서 안전하게 사용할 수 있다는 주장을 반박할 만한 증거는 없습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>17</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="311E53334A43BDF9889C9C7A134E82E1" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextDouble()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HijackSessionAuthenticationProvider.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/hijacksession/cas/HijackSessionAuthenticationProvider.java</FilePath>
<LineStart>79</LineStart>
<Snippet>
  protected void authorizedUserAutoLogin() {
    if (!PROBABILITY_DOUBLE_PREDICATE.test(ThreadLocalRandom.current().nextDouble())) {
      Authentication authentication = AUTHENTICATION_SUPPLIER.get();
      authentication.setAuthenticated(true);</Snippet>
<TargetFunction>nextDouble()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="44C455FC640488F1E4FFD59BD512FC14" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>PasswordResetLink.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java</FilePath>
<LineStart>25</LineStart>
<Snippet>    char[] a = inputString.toCharArray();
    for (int i = 0; i &lt; a.length; i++) {
      int j = random.nextInt(a.length);
      char temp = a[i];
      a[i] = a[j];</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5F347BBC18574D08CA53545E56B2F74C" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFGetFlag.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java</FilePath>
<LineStart>60</LineStart>
<Snippet>      if ("true".equals(req.getParameter("csrf"))) {
        Random random = new Random();
        userSessionData.setValue("csrf-get-success", random.nextInt(65536));
        response.put("success", true);
        response.put("message", pluginMessages.getMessage("csrf-get-null-referer.success"));</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0435906D7B4AE6B8ED9674812EC22E07" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HashingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java</FilePath>
<LineStart>71</LineStart>
<Snippet>    String sha256 = (String) request.getSession().getAttribute("sha256");
    if (sha256 == null) {
      String secret = SECRETS[new Random().nextInt(SECRETS.length)];
      sha256 = getHash(secret, "SHA-256");
      request.getSession().setAttribute("sha256Hash", sha256);</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2D54C8FA8F2F247459CA5178C92847E3" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTSecretKeyEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  };
  public static final String JWT_SECRET =
      TextCodec.BASE64.encode(SECRETS[new Random().nextInt(SECRETS.length)]);
  private static final String WEBGOAT_USER = "WebGoat";
  private static final List&lt;String&gt; expectedClaims =</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5F347BBC18574D08CA53545E56B2F74B" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFGetFlag.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java</FilePath>
<LineStart>66</LineStart>
<Snippet>      } else {
        Random random = new Random();
        userSessionData.setValue("csrf-get-success", random.nextInt(65536));
        response.put("success", true);
        response.put("message", pluginMessages.getMessage("csrf-get-other-referer.success"));</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CDFD178287A8DC40970C84EE19CD89BF" ruleID="DBB5D0ED-E29D-4E81-8F21-43672B2C677E">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>randomAlphabetic()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JWTRefreshEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java</FilePath>
<LineStart>92</LineStart>
<Snippet>            .compact();
    Map&lt;String, Object&gt; tokenJson = new HashMap&lt;&gt;();
    String refreshToken = RandomStringUtils.randomAlphabetic(20);
    validRefreshTokens.add(refreshToken);
    tokenJson.put("access_token", token);</Snippet>
<TargetFunction>randomAlphabetic()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E52EC2750EEF5848BA05B7F4DBB62A4A" ruleID="DBB5D0ED-E29D-4E81-8F21-43672B2C677E">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>randomAlphabetic()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EncDec.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/encoders/EncDec.java</FilePath>
<LineStart>40</LineStart>
<Snippet>  // PoC: weak encoding method

  private static final String SALT = RandomStringUtils.randomAlphabetic(10);

  private EncDec() {}</Snippet>
<TargetFunction>randomAlphabetic()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DF5DCE38C267401489234D76FF11C207" ruleID="919BF191-6443-4239-BBFF-A7A31C108032">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>random()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HttpBasics.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/httpbasics/html/HttpBasics.html</FilePath>
<LineStart>59</LineStart>
<Snippet>					    // a namespace has been assigned for it, but you can roll your own if you prefer
					    webgoat.customjs.assignRandomVal = function () {
							var x = Math.floor((Math.random() * 100) + 1);
							document.getElementById("magic_num").value = x;
						};</Snippet>
<TargetFunction>FunctionPointerCall: random()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DAC4D23B147E71AA4BE012918D1DA902" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ImageServlet.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge1/ImageServlet.java</FilePath>
<LineStart>17</LineStart>
<Snippet>public class ImageServlet {

  public static final int PINCODE = new Random().nextInt(10000);

  @RequestMapping(</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="95B2FA35EA1802C3633C30D4317ABDE3" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HashingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java</FilePath>
<LineStart>53</LineStart>
<Snippet>    if (md5Hash == null) {

      String secret = SECRETS[new Random().nextInt(SECRETS.length)];

      MessageDigest md = MessageDigest.getInstance("MD5");</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C9718E95F889CDF7061713F2628CAA36" ruleID="919BF191-6443-4239-BBFF-A7A31C108032">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>random()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ChromeDevTools.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html</FilePath>
<LineStart>53</LineStart>
<Snippet>                // a namespace has been assigned for it, but you can roll your own if you prefer
                document.getElementById("btn").addEventListener("click", function() {
                    document.getElementById("networkNum").value = Math.random() * 100;
                    document.getElementById("networkNumCopy").value = document.getElementById("networkNum").value;
                });</Snippet>
<TargetFunction>FunctionPointerCall: random()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5F347BBC18574D08CA53545E56B2F74A" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CSRFGetFlag.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java</FilePath>
<LineStart>77</LineStart>
<Snippet>    } else {
      Random random = new Random();
      userSessionData.setValue("csrf-get-success", random.nextInt(65536));
      response.put("success", true);
      response.put("message", pluginMessages.getMessage("csrf-get-other-referer.success"));</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="32E05C25A96FE0E2A029A254356816C5" ruleID="07991774-F86A-4A10-B7D9-666AF337F943">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>92</LineStart>
<Snippet>      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");

      if (catPicture.getName().toLowerCase().contains("path-traversal-secret.jpg")) {</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="385F2C255E18EF3905BE8BBDE62055EA" ruleID="DBB5D0ED-E29D-4E81-8F21-43672B2C677E">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>randomAlphabetic()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>72</LineStart>
<Snippet>
  private void createSecretFileWithRandomContents(WebGoatUser user) {
    var fileContents = "WebGoat 8.0 rocks... (" + randomAlphabetic(10) + ")";
    userToFileContents.put(user, fileContents);
    File targetDirectory = new File(webGoatHomeDirectory, "/XXE/" + user.getUsername());</Snippet>
<TargetFunction>randomAlphabetic()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="80243207D6F1DE1DC47E04A8B201F48F" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>52</LineStart>
<Snippet>    if (basicAuth == null) {
      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute("basicAuth", basicAuth);</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6A20FBE577F9345766EBA3EE6E90730B" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>nextLong()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>HijackSessionAuthenticationProvider.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/hijacksession/cas/HijackSessionAuthenticationProvider.java</FilePath>
<LineStart>48</LineStart>
<Snippet>
  private Queue&lt;String&gt; sessions = new LinkedList&lt;&gt;();
  private static long id = new Random().nextLong() &amp; Long.MAX_VALUE;
  protected static final int MAX_SESSIONS = 50;
</Snippet>
<TargetFunction>nextLong()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Cookie Security: HTTPOnly not Set</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie("emailCookie", email);
// Missing a call to: cookie.setHttpOnly(true);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie("emailCookie", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>16</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="DA2455A00875DFD257B543A621AA22E7" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 CSRFFeedbackTest.java의 69 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CSRFFeedbackTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/csrf/CSRFFeedbackTest.java</FilePath>
<LineStart>69</LineStart>
<Snippet>            post("/csrf/feedback/message")
                .contentType(MediaType.TEXT_PLAIN)
                .cookie(new Cookie("JSESSIONID", "test"))
                .header("host", "localhost:8080")
                .header("referer", "webgoat.org")</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="547BB70FFC72E6617473F047C6922A3C" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 70 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>70</LineStart>
<Snippet>            MockMvcRequestBuilders.post("/JWT/votings")
                .contentType(MediaType.APPLICATION_JSON)
                .cookie(new Cookie("access_token", token)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.lessonCompleted", is(true)));</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="506740A345DBA629BF340D15EE535698" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 218 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>218</LineStart>
<Snippet>        .perform(
            MockMvcRequestBuilders.post("/JWT/votings/Admin lost password")
                .cookie(new Cookie("access_token", "")))
        .andExpect(status().isUnauthorized());
  }</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5E2F30E22746819C63E8A4B75F268AD2" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpoint.java의 135 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>135</LineStart>
<Snippet>      response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    } else {
      Cookie cookie = new Cookie("access_token", "");
      response.addCookie(cookie);
      response.setStatus(HttpStatus.UNAUTHORIZED.value());</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A0095B311375027387CD9D5B7C9EEF39" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpoint.java의 130 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>130</LineStart>
<Snippet>              .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, JWT_PASSWORD)
              .compact();
      Cookie cookie = new Cookie("access_token", token);
      response.addCookie(cookie);
      response.setStatus(HttpStatus.OK.value());</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7712D1A4FBC7F0751CFF26AF3FA1E3AA" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 88 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>88</LineStart>
<Snippet>            MockMvcRequestBuilders.post("/JWT/votings")
                .contentType(MediaType.APPLICATION_JSON)
                .cookie(new Cookie("access_token", token)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.lessonCompleted", is(true)));</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0A2EB17CD0F1641CC8FD59A680971E8F" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 253 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>253</LineStart>
<Snippet>    mockMvc
        .perform(
            MockMvcRequestBuilders.get("/JWT/votings").cookie(new Cookie("access_token", token)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$[0].numberOfVotes").doesNotExist())</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="568F0A855C32F66D6A1C2FB0E3F7D9F0" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HijackSessionAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignment.java</FilePath>
<LineStart>86</LineStart>
<Snippet>
  private void setCookie(HttpServletResponse response, String cookieValue) {
    Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
    cookie.setPath("/WebGoat");
    cookie.setSecure(true);</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E4419F1C4C7AF2D05DD45E42C93E2D38" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 160 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>160</LineStart>
<Snippet>        .perform(
            MockMvcRequestBuilders.get("/JWT/votings")
                .cookie(new Cookie("access_token", "abcd.efgh.ijkl")))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$[0].numberOfVotes").doesNotExist())</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="237590F1825F3B5FCDBD84F623543C64" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 SpoofCookieAssignmentTest.java의 74 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>74</LineStart>
<Snippet>  @DisplayName("Lesson completed")
  void success() throws Exception {
    Cookie cookie = new Cookie(COOKIE_NAME, "NjI2MTcwNGI3YTQxNGE1OTU2NzQ2ZDZmNzQ=");

    ResultActions result =</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="67310C4FCD85020E1952C32E2FD6E86B" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 SpoofCookieAssignmentTest.java의 113 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>113</LineStart>
<Snippet>          + "3.- Valid cookie with not known username sent ")
  void cookieLoginNotSolvedFlow(String cookieValue) throws Exception {
    Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
    mockMvc
        .perform(</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D05AEB1CE29804228F907ABB3FD733A8" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 SpoofCookieAssignment.java의 95 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>95</LineStart>
<Snippet>    if (!authPassword.isBlank() &amp;&amp; authPassword.equals(password)) {
      String newCookieValue = EncDec.encode(lowerCasedUsername);
      Cookie newCookie = new Cookie(COOKIE_NAME, newCookieValue);
      newCookie.setPath("/WebGoat");
      newCookie.setSecure(true);</Snippet>
<TargetFunction>newCookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B6D33CB815F96662150A519AF6681415" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 HijackSessionAssignmentTest.java의 83 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HijackSessionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignmentTest.java</FilePath>
<LineStart>83</LineStart>
<Snippet>    ReflectionTestUtils.setField(assignment, "provider", providerMock);

    Cookie cookie = new Cookie(COOKIE_NAME, "value");

    ResultActions result =</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="88B3BE69C7E89E4851EAE8E098FA7F15" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 SpoofCookieAssignment.java의 79 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>79</LineStart>
<Snippet>  @GetMapping(path = "/SpoofCookie/cleanup")
  public void cleanup(HttpServletResponse response) {
    Cookie cookie = new Cookie(COOKIE_NAME, "");
    cookie.setMaxAge(0);
    response.addCookie(cookie);</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3774926D66A4DE5452A0073B1D850FC7" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 128 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>128</LineStart>
<Snippet>  public void guestShouldNotSeeNumberOfVotes() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get("/JWT/votings").cookie(new Cookie("access_token", "")))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$[0].numberOfVotes").doesNotExist())</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4D6F974987384012D0587876D28FC965" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>프로그램은 JWTVotesEndpointTest.java의 236 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>236</LineStart>
<Snippet>        .perform(
            MockMvcRequestBuilders.post("/JWT/votings/Admin lost password")
                .cookie(new Cookie("access_token", token)))
        .andExpect(status().isUnauthorized());
  }</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Cross-Site Scripting: DOM</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>challenge8.js의 lambda() 메서드가 18 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. DOM-based XSS의 경우, URL 매개 변수 또는 브라우저 내 다른 값에서 데이터를 읽어들이며 클라이언트 쪽 코드를 사용하여 페이지에 다시 씁니다. Reflected XSS의 경우 신뢰할 수 없는 소스는 일반적으로 웹 요청이지만, Persisted(Stored 라고도 함) XSS의 경우에는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다. DOM-based XSS의 경우, 피해자의 브라우저가 HTML 페이지를 구문 분석할 때마다 악성 콘텐트가 DOM(Document Object Model) 생성의 일부로 실행됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.

예제 1: 다음 JavaScript 코드 세그먼트는 URL에서 직원 ID인 eid를 읽고 사용자에게 표시합니다.


&lt;SCRIPT&gt;
var pos=document.URL.indexOf("eid=")+4;
document.write(document.URL.substring(pos,document.URL.length));
&lt;/SCRIPT&gt;



예제 2: 다음의 HTML 형식을 고려해 보십시오.


  &lt;div id="myDiv"&gt;
    Employee ID: &lt;input type="text" id="eid"&gt;&lt;br&gt;
    ...
    &lt;button&gt;Show results&lt;/button&gt;
  &lt;/div&gt;
  &lt;div id="resultsDiv"&gt;
    ...
  &lt;/div&gt;


다음 jQuery 코드 세그먼트는 HTML 형식에서 직원 ID를 읽고 사용자에게 표시합니다.


  $(document).ready(function(){
    $("#myDiv").on("click", "button", function(){
      var eid = $("#eid").val();
      $("resultsDiv").append(eid);
      ...
    });
  });


이러한 코드 예제는 ID가 eid인 텍스트 입력에서 직원 ID에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

예제 3: 다음 코드는 React 응용 프로그램 내의 DOM-based XSS 예제를 보여 줍니다.


let element = JSON.parse(getUntrustedInput());
ReactDOM.render(&lt;App&gt;
    {element}
&lt;/App&gt;);


Example 3에서 공격자가 getUntrustedInput()에서 파생된 전체 JSON을 제어할 수 있는 경우 React가 element를 구성 요소로 렌더링하도록 만들 수 있기 때문에 일반적인 Cross-Site Scripting 공격인 자체 제어 값으로 dangerouslySetInnerHTML을 이용하여 개체를 전달할 수 있습니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 하지만 자신의 컴퓨터에서 악의적인 코드가 실행되도록 입력을 제공하는 이유가 있을까요? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어들여 데이터가 동적 콘텐트에 포함됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- "&lt;"는 태그가 시작되는 표시이기 때문에 특수합니다

- "&amp;"는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "&gt;"는 일부 브라우저에서 페이지 작성자가 여는 "&lt;"를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- "&amp;"는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- "&amp;"는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- "%" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, "%"는 "%68%65%6C%6C%6F"와 같은 입력이 웹 페이지에 나타날 때 "hello"가 되는 경우 필터링해야 합니다.


&lt;SCRIPT&gt; &lt;/SCRIPT&gt;의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표(")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 "&lt;"가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저(특히 Internet Explorer 6 및 7 그 외 다른 브라우저들)는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 룰팩은 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값으로 Fortify는 Cross-Site Scripting, Poor Validation 취약점을 보고할 수 있습니다.

3. React 이전 버전은 전체 구성 요소를 제어하여 cross-site scripting 공격에 더 취약합니다. 최신 버전은 Symbols를 사용하여 React 구성 요소를 식별하므로 익스플로이트를 방지하지만 Internet Explorer 모든 버전과 같이 Symbol을 지원(기본적으로 또는 polyfills를 통해)하지 않는 이전 브라우저는 여전히 취약합니다. 다른 Cross-Site Scripting 공격 유형은 모든 브라우저 및 React 버전에 유효합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>16</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3D8081EA79972992DF4D740A7973C27F" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>csrf-review.js의 lambda() 메서드가 41 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>csrf-review.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/csrf/js/csrf-review.js</FilePath>
<LineStart>41</LineStart>
<Snippet>                comment = comment.replace('COMMENT', result[i].text);
                comment = comment.replace('STARS', result[i].stars)
                $("#list").append(comment);
            }
</Snippet>
<TargetFunction>~JS_Generic.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>csrf-review.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/csrf/js/csrf-review.js</FilePath>
<LineStart>35</LineStart>
<Snippet>    function getChallenges() {
        $("#list").empty();
        $.get('csrf/review', function (result, status) {
            for (var i = 0; i &lt; result.length; i++) {
                var comment = html.replace('USER', result[i].user);</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A889C22BD33750C63023B4C71B239338" ruleID="EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js의 lambda() 메서드가 14 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>14</LineStart>
<Snippet>webgoat.customjs.profileUploadCallback = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("preview").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>13</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallback = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("preview").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5FA2450CD3CF0C6025C4756997863167" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>GoatUtils.js의 lambda() 메서드가 57 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>GoatUtils.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/goatApp/support/GoatUtils.js</FilePath>
<LineStart>57</LineStart>
<Snippet>                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $("#lesson_cookies").html(reply);
                    }, "html");
                },</Snippet>
<TargetFunction>~JS_Generic.html()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>GoatUtils.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/goatApp/support/GoatUtils.js</FilePath>
<LineStart>56</LineStart>
<Snippet> 
                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $("#lesson_cookies").html(reply);
                    }, "html");</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="86D6531C6F6737839E0CD291D7D3E3FC" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>challenge8.js의 lambda() 메서드가 18 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>18</LineStart>
<Snippet>                var progressBar = $('#progressBar' + i);
                progressBar.width(Math.round(percent) * 2 + '%');
                $("#nrOfVotes" + i).html(votes[i]);

            }</Snippet>
<TargetFunction>~JS_Generic.html()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>7</LineStart>
<Snippet>
function loadVotes() {
    $.get("challenge/8/votes/", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i &lt;= 5; i++) {</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="DACB0F537F0673E55AF1E553A109324C" ruleID="EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>clientSideFiltering.js의 lambda() 메서드가 38 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>38</LineStart>
<Snippet>
        var newdiv = document.createElement("div");
        newdiv.innerHTML = html;
        var container = document.getElementById("hiddenEmployeeRecords");
        container.appendChild(newdiv);</Snippet>
<TargetFunction>Assignment to newdiv.innerHTML()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>17</LineStart>
<Snippet>
function ajaxFunction(userId) {
    $.get("clientSideFiltering/salaries?userId=" + userId, function (result, status) {
        var html = "&lt;table border = '1' width = '90%' align = 'center'";
        html = html + '&lt;tr&gt;';</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3D8081EA79972992DF4D740A7973C280" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>stored-xss.js의 lambda() 메서드가 40 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>stored-xss.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/xss/js/stored-xss.js</FilePath>
<LineStart>40</LineStart>
<Snippet>                comment = comment.replace('DATETIME', result[i].dateTime);
                comment = comment.replace('COMMENT', result[i].text);
                $("#list").append(comment);
            }
</Snippet>
<TargetFunction>~JS_Generic.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>stored-xss.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/xss/js/stored-xss.js</FilePath>
<LineStart>35</LineStart>
<Snippet>    function getChallenges() {
        $("#list").empty();
        $.get('CrossSiteScriptingStored/stored-xss', function (result, status) {
            for (var i = 0; i &lt; result.length; i++) {
                var comment = html.replace('USER', result[i].user);</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="2DEFEDB80221B9F0475DB0C5722F80AD" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>xxe.js의 lambda() 메서드가 78 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>xxe.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/xxe/js/xxe.js</FilePath>
<LineStart>78</LineStart>
<Snippet>            comment = comment.replace('DATETIME', result[i].dateTime);
            comment = comment.replace('COMMENT', result[i].text);
            $(field).append(comment);
        }
</Snippet>
<TargetFunction>~JS_Generic.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>xxe.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/xxe/js/xxe.js</FilePath>
<LineStart>72</LineStart>
<Snippet>
function getComments(field) {
    $.get("xxe/comments", function (result, status) {
        $(field).empty();
        for (var i = 0; i &lt; result.length; i++) {</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C2A5EBDFCA387E4BA09B4AE84F34133C" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>challenge8.js의 lambda() 메서드가 52 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>52</LineStart>
<Snippet>            $("#voteResultMsg").addClass('alert-success alert-dismissable');
        }
        $("#voteResultMsg").html(result["message"]);
        $("#voteResultMsg").show();
    })</Snippet>
<TargetFunction>~JS_Generic.html()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>challenge8.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/challenges/js/challenge8.js</FilePath>
<LineStart>46</LineStart>
<Snippet>function doVote(stars) {
    $("#voteResultMsg").hide();
    $.get("challenge/8/vote/" + stars, function (result) {
        if (result["error"]) {
            $("#voteResultMsg").addClass('alert-danger alert-dismissable');</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="36F3C2F37249E8226AD81102D2BA54EB" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>jwt-voting.js의 lambda() 메서드가 63 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>jwt-voting.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/js/jwt-voting.js</FilePath>
<LineStart>63</LineStart>
<Snippet>            voteTemplate = voteTemplate.replace(/HIDDEN_VIEW_RATING/g, hidden);

            $("#votesList").append(voteTemplate);
        }
    })</Snippet>
<TargetFunction>~JS_Generic.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>jwt-voting.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/jwt/js/jwt-voting.js</FilePath>
<LineStart>43</LineStart>
<Snippet>function getVotings() {
    $("#votesList").empty();
    $.get("JWT/votings", function (result, status) {
        for (var i = 0; i &lt; result.length; i++) {
            var voteTemplate = html.replace('IMAGE_SMALL', result[i].imageSmall);</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="680B672B9A46E2388E2BA006ACEC2587" ruleID="EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js의 lambda() 메서드가 30 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>30</LineStart>
<Snippet>webgoat.customjs.profileUploadCallbackFix = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewFix").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>29</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewFix").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="156F1B6AFE8BFD06D3792422222C837F" ruleID="EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js의 lambda() 메서드가 47 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>47</LineStart>
<Snippet>webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRemoveUserInput").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>46</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRemoveUserInput").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1F9243720929DE42C32777C86DE4A660" ruleID="EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js의 lambda() 메서드가 60 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>60</LineStart>
<Snippet>function newRandomPicture() {
    $.get("PathTraversal/random-picture", function (result, status) {
        document.getElementById("randomCatPicture").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>59</LineStart>
<Snippet>
function newRandomPicture() {
    $.get("PathTraversal/random-picture", function (result, status) {
        document.getElementById("randomCatPicture").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F54D787DF80ACAF4CC63549EFED3A2E0" ruleID="43F16EB5-A3E5-4A50-B1AB-B6CB5BE10F010">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>jquery.form.js의 fileUploadXhr() 메서드가 346 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/jquery_form/jquery.form.js</FilePath>
<LineStart>346</LineStart>
<Snippet>            }
        };
        return $.ajax(s);
    }
</Snippet>
<TargetFunction>~JS_Generic.ajax()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/jquery_form/jquery.form.js</FilePath>
<LineStart>115</LineStart>
<Snippet>
    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)</Snippet>
<TargetFunction>Read window.location()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3FD1E744F7E387DC19BE49AA97B3C159" ruleID="EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js의 lambda() 메서드가 54 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>54</LineStart>
<Snippet>webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRetrieval").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>53</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRetrieval").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="016B849F15785802F74FD08FE29D2BB9" ruleID="D23845BE-28FC-4A70-BE22-3BB3A26746750">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>assignment13.js의 lambda() 메서드가 57 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>assignment13.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/sqlinjection/js/assignment13.js</FilePath>
<LineStart>57</LineStart>
<Snippet>            server = server.replace('MAC', result[i].mac);
            server = server.replace('DESCRIPTION', result[i].description);
            $("#servers").append(server);
        }
</Snippet>
<TargetFunction>~JS_Generic.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>assignment13.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/sqlinjection/js/assignment13.js</FilePath>
<LineStart>43</LineStart>
<Snippet>
function getServers(column) {
    $.get("SqlInjectionMitigations/servers?column=" + column, function (result, status) {
        $("#servers").empty();
        for (var i = 0; i &lt; result.length; i++) {</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F54D787DF80ACAF4CC63549EFED3A2E1" ruleID="43F16EB5-A3E5-4A50-B1AB-B6CB5BE10F010">
                            <Category>Cross-Site Scripting: DOM</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>jquery.form.js의 fileUploadXhr() 메서드가 346 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/jquery.form.js</FilePath>
<LineStart>346</LineStart>
<Snippet>            }
        };
        return $.ajax(s);
    }
</Snippet>
<TargetFunction>~JS_Generic.ajax()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/jquery.form.js</FilePath>
<LineStart>115</LineStart>
<Snippet>
    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)</Snippet>
<TargetFunction>Read window.location()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="14">
                        <groupTitle>Cookie Security: Cookie not Sent Over SSL</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie("emailCookie", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie("emailCookie", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>14</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7D1C42B42138B342C742BA313852FAAB" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>    Cookie cookie = new Cookie(COOKIE_NAME, "");
    cookie.setMaxAge(0);
    response.addCookie(cookie);
  }
</Snippet>
<TargetFunction>addCookie(cookie)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D0C77ADC1B784C1BEC7A91998DC23CB2" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>160</LineStart>
<Snippet>        .perform(
            MockMvcRequestBuilders.get("/JWT/votings")
                .cookie(new Cookie("access_token", "abcd.efgh.ijkl")))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$[0].numberOfVotes").doesNotExist())</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6949F4984AC4F02B68AE5BF04C91D282" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>218</LineStart>
<Snippet>        .perform(
            MockMvcRequestBuilders.post("/JWT/votings/Admin lost password")
                .cookie(new Cookie("access_token", "")))
        .andExpect(status().isUnauthorized());
  }</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F0FF74228572D0942D579D66F72C63BE" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>128</LineStart>
<Snippet>  public void guestShouldNotSeeNumberOfVotes() throws Exception {
    mockMvc
        .perform(MockMvcRequestBuilders.get("/JWT/votings").cookie(new Cookie("access_token", "")))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$[0].numberOfVotes").doesNotExist())</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1748426A911D4F679353C2C8A2ED314" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>113</LineStart>
<Snippet>          + "3.- Valid cookie with not known username sent ")
  void cookieLoginNotSolvedFlow(String cookieValue) throws Exception {
    Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
    mockMvc
        .perform(</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A89D2774B1877CC59B167DA5BD163591" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>131</LineStart>
<Snippet>              .compact();
      Cookie cookie = new Cookie("access_token", token);
      response.addCookie(cookie);
      response.setStatus(HttpStatus.OK.value());
      response.setContentType(MediaType.APPLICATION_JSON_VALUE);</Snippet>
<TargetFunction>addCookie(cookie)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D84951E33E076514153D195B31FE451E" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HijackSessionAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignmentTest.java</FilePath>
<LineStart>83</LineStart>
<Snippet>    ReflectionTestUtils.setField(assignment, "provider", providerMock);

    Cookie cookie = new Cookie(COOKIE_NAME, "value");

    ResultActions result =</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="78D3023BB1B5AC36E7D015715015F53A" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>70</LineStart>
<Snippet>            MockMvcRequestBuilders.post("/JWT/votings")
                .contentType(MediaType.APPLICATION_JSON)
                .cookie(new Cookie("access_token", token)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.lessonCompleted", is(true)));</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="113B6AD4A668298EAEC71DC04E10348A" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>253</LineStart>
<Snippet>    mockMvc
        .perform(
            MockMvcRequestBuilders.get("/JWT/votings").cookie(new Cookie("access_token", token)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$[0].numberOfVotes").doesNotExist())</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="75FBC615409AC3F30B57FCD31A62A11A" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>236</LineStart>
<Snippet>        .perform(
            MockMvcRequestBuilders.post("/JWT/votings/Admin lost password")
                .cookie(new Cookie("access_token", token)))
        .andExpect(status().isUnauthorized());
  }</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="68D56F2445381F0E32D291E3FBEAF827" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CSRFFeedbackTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/csrf/CSRFFeedbackTest.java</FilePath>
<LineStart>69</LineStart>
<Snippet>            post("/csrf/feedback/message")
                .contentType(MediaType.TEXT_PLAIN)
                .cookie(new Cookie("JSESSIONID", "test"))
                .header("host", "localhost:8080")
                .header("referer", "webgoat.org")</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="78F862303F0A053C64B8A4C3FB92646D" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpointTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java</FilePath>
<LineStart>88</LineStart>
<Snippet>            MockMvcRequestBuilders.post("/JWT/votings")
                .contentType(MediaType.APPLICATION_JSON)
                .cookie(new Cookie("access_token", token)))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.lessonCompleted", is(true)));</Snippet>
<TargetFunction>new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="73BB77A33A96B5DA68C714C76EFF64B3" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SpoofCookieAssignmentTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java</FilePath>
<LineStart>74</LineStart>
<Snippet>  @DisplayName("Lesson completed")
  void success() throws Exception {
    Cookie cookie = new Cookie(COOKIE_NAME, "NjI2MTcwNGI3YTQxNGE1OTU2NzQ2ZDZmNzQ=");

    ResultActions result =</Snippet>
<TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A89D2774B1877CC59B167DA5BD163592" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTVotesEndpoint.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java</FilePath>
<LineStart>136</LineStart>
<Snippet>    } else {
      Cookie cookie = new Cookie("access_token", "");
      response.addCookie(cookie);
      response.setStatus(HttpStatus.UNAUTHORIZED.value());
      response.setContentType(MediaType.APPLICATION_JSON_VALUE);</Snippet>
<TargetFunction>addCookie(cookie)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println("hello world");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 "운용 전" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info("hello world");
  ...
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>10</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="6F7791AB8C62746F4D5FEDEC90614C17" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>188</LineStart>
<Snippet>          .getString(ESCAPE_JSON_PATH_CHAR + key + ESCAPE_JSON_PATH_CHAR)
          .equals(propsLang.get(key))) {
        System.out.println(
            "key: " + key + " in (" + lang + ") has incorrect translation in label service");
        System.out.println(</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="62F86F2F8137D833B577D020F9DBAE60" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>192</LineStart>
<Snippet>        System.out.println(
            "actual:" + jsonPath.getString(ESCAPE_JSON_PATH_CHAR + key + ESCAPE_JSON_PATH_CHAR));
        System.out.println("expected: " + propsLang.getProperty(key));
        System.out.println();
        Assertions.fail();</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C50CAE221F5766FF6BE7A3844D2AA685" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>96</LineStart>
<Snippet>
    } catch (Exception e) {
      System.err.println(e.getMessage());
      return failed(this)
          .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="81217D1C8E35A28EA138EB878F585133" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>190</LineStart>
<Snippet>        System.out.println(
            "key: " + key + " in (" + lang + ") has incorrect translation in label service");
        System.out.println(
            "actual:" + jsonPath.getString(ESCAPE_JSON_PATH_CHAR + key + ESCAPE_JSON_PATH_CHAR));
        System.out.println("expected: " + propsLang.getProperty(key));</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="411644EDC6701B894A157BC26D4AA38B" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>193</LineStart>
<Snippet>            "actual:" + jsonPath.getString(ESCAPE_JSON_PATH_CHAR + key + ESCAPE_JSON_PATH_CHAR));
        System.out.println("expected: " + propsLang.getProperty(key));
        System.out.println();
        Assertions.fail();
      }</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E7B7C21CD4008AAAC3DBE74F2860F137" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProgressRaceConditionIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/ProgressRaceConditionIntegrationTest.java</FilePath>
<LineStart>53</LineStart>
<Snippet>                })
            .count();
    System.err.println("counted status 500: " + countStatusCode500);
    Assertions.assertThat(countStatusCode500)
        .isLessThanOrEqualTo((NUMBER_OF_CALLS - (NUMBER_OF_CALLS / NUMBER_OF_PARALLEL_THREADS)));</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="58CE9816677EE72826BCEC9499E2C9B2" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson8.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java</FilePath>
<LineStart>160</LineStart>
<Snippet>      statement.executeUpdate(logQuery);
    } catch (SQLException e) {
      System.err.println(e.getMessage());
    }
  }</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C50CAE221F5766FF6BE7A3844D2AA684" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson9.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java</FilePath>
<LineStart>87</LineStart>
<Snippet>        }
      } catch (SQLException e) {
        System.err.println(e.getMessage());
        return failed(this)
            .output("&lt;br&gt;&lt;span class='feedback-negative'&gt;" + e.getMessage() + "&lt;/span&gt;")</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5C7FBE7ACFCD999EFBD41C8B534FCC64" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>182</LineStart>
<Snippet>    for (String key : propsLang.stringPropertyNames()) {
      if (!propsDefault.containsKey(key)) {
        System.err.println("key: " + key + " in (" + lang + ") is missing from default properties");
        Assertions.fail();
      }</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="96A478F4925CFE19357D40F157F55A1E" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java</FilePath>
<LineStart>123</LineStart>
<Snippet>        return false;
      } else {
        System.err.println(e.getMessage());
        return false;
      }</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Open Redirect</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>ProfileUploadRetrieval.java 파일은 102 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    &lt;%
        ...
        String strDest = request.getParameter("dest");
        pageContext.forward(strDest);
        ...
    %&gt;


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D"

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    &lt;%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter("dest"));
            if((strDest &gt;= 0) &amp;&amp; (strDest &lt;= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %&gt;


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.

2. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>9</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9BE0CE2347F66806C7B28A2349FCC653" ruleID="6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA">
                            <Category>Open Redirect</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java 파일은 106 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>106</LineStart>
<Snippet>      }
      return ResponseEntity.status(HttpStatus.NOT_FOUND)
          .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.HeadersBuilder.location()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F9BB79F6688F5F08EEE1B925A53E7EB4" ruleID="C71A9777-B31F-4A80-ADED-0868DAE5CF760">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js 파일은 14 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>14</LineStart>
<Snippet>webgoat.customjs.profileUploadCallback = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("preview").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>13</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallback = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("preview").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7ED0D54EAD4C6C34B9DFE3553BFF8EF6" ruleID="C71A9777-B31F-4A80-ADED-0868DAE5CF760">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js 파일은 60 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>60</LineStart>
<Snippet>function newRandomPicture() {
    $.get("PathTraversal/random-picture", function (result, status) {
        document.getElementById("randomCatPicture").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>59</LineStart>
<Snippet>
function newRandomPicture() {
    $.get("PathTraversal/random-picture", function (result, status) {
        document.getElementById("randomCatPicture").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8CBD1AB0ECC7A07CC56E2018A088C1AC" ruleID="C71A9777-B31F-4A80-ADED-0868DAE5CF760">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js 파일은 47 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>47</LineStart>
<Snippet>webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRemoveUserInput").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>46</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRemoveUserInput").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4C4373D55FADDB086706AD2549A27853" ruleID="6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java 파일은 106 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>106</LineStart>
<Snippet>      }
      return ResponseEntity.status(HttpStatus.NOT_FOUND)
          .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.HeadersBuilder.location()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>90</LineStart>
<Snippet>    }
    try {
      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");</Snippet>
<TargetFunction>jakarta.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="963BE056C82388D8ACD280BEA6461285" ruleID="6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA">
                            <Category>Open Redirect</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java 파일은 102 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>102</LineStart>
<Snippet>        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
            .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
            .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
      }</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.HeadersBuilder.location()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="850AAFD007E3AE63447E77148354ACCF" ruleID="C71A9777-B31F-4A80-ADED-0868DAE5CF760">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js 파일은 30 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>30</LineStart>
<Snippet>webgoat.customjs.profileUploadCallbackFix = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewFix").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>29</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewFix").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C0D6B66EED312C47C976F1FD7D5DFDEB" ruleID="6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java 파일은 102 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>102</LineStart>
<Snippet>        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
            .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
            .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
      }</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.HeadersBuilder.location()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>90</LineStart>
<Snippet>    }
    try {
      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");</Snippet>
<TargetFunction>jakarta.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5677A21185D4B327CFA0E200E97A5085" ruleID="C71A9777-B31F-4A80-ADED-0868DAE5CF760">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>path_traversal.js 파일은 54 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>54</LineStart>
<Snippet>webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRetrieval").src = "data:image/png;base64," + result;
    });
}</Snippet>
<TargetFunction>Assignment to src()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>path_traversal.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/pathtraversal/js/path_traversal.js</FilePath>
<LineStart>53</LineStart>
<Snippet>
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get("PathTraversal/profile-picture", function (result, status) {
        document.getElementById("previewRetrieval").src = "data:image/png;base64," + result;
    });</Snippet>
<TargetFunction>lambda(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>WebWolfRedirect.java의 openWebWolf() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>신뢰의 경계는 프로그램으로 그어 놓은 선으로 생각할 수 있습니다. 선의 이쪽에서는 데이터를 신뢰하지 않습니다. 선의 반대편에서는 데이터를 신뢰할 수 있다고 간주합니다. 검증 로직을 사용하는 목적은 데이터가 신뢰의 경계를 안전하게 건너는 것 즉, 신뢰할 수 없는 데이터에서 신뢰할 수 있는 데이터로 이동하는 것을 허용하기 위해서입니다.

Trust boundary violation은 신뢰할 수 있는 것과 신뢰할 수 없는 것 사이의 경계를 프로그램이 흐릴 때 발생합니다. 이런 실수를 범하는 가장 흔한 방식은 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 같은 데이터 구조체에 혼합하는 것입니다. 



예제: 다음 Java 코드는 HTTP 요청을 받아 사용자가 인증되었는지 확인하기 전에 usrname 매개 변수를 HTTP 세션 개체에 저장합니다.


usrname = request.getParameter("usrname");
if (session.getAttribute(ATTR_USR) != null) {
    session.setAttribute(ATTR_USR, usrname);
}


잘 설계되고 유지 관리되는 신뢰 경계가 없으면 프로그래머는 어떤 데이터가 확인 작업을 거치고 거치지 않았는지에 대한 추적을 놓칠 수밖에 없습니다. 이런 혼란은 결국 일부 데이터를 확인하지 않고 사용하는 실수로 이어집니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>응용 프로그램에 분명한 신뢰 경계를 정의하십시오. 같은 데이터 구조체를 사용하여 신뢰할 수 있는 데이터를 한 컨텍스트에, 신뢰할 수 없는 데이터를 다른 컨텍스트에 보관해서는 안 됩니다. 데이터가 신뢰의 경계를 이동할 수 있는 방법의 수를 최소화합니다.

Trust boundary violation은 처리하기 전에 일련의 사용자 상호 작용을 거쳐 입력을 생성해야 하는 경우에 발생합니다. 모든 데이터가 도착할 때까지는 입력값 검증을 완료할 수 없습니다. 이런 경우, 신뢰 경계를 유지하는 것이 중요합니다. 신뢰할 수 없는 단일 데이터 구조체에 신뢰할 수 없는 데이터를 보관하여 확인한 다음 신뢰할 수 있는 위치로 이동해야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 확인되지 않은 데이터를 신뢰할 수 있는 것으로 가정하는 "증거가 명백한" 상황을 찾을 필요가 없습니다. 신뢰 경계를 분명하게 긋고 지키지 않으면 검증 오류를 피할 수 없습니다. 익스플로이트 시나리오를 검색하는 데 시간을 허비하기보다 프로그래머에게 명확한 신뢰 경계를 작성하도록 가르치는 데 집중해야 합니다.

2. 대부분의 프로그램에는 응용 프로그램의 의미로 정의되는 신뢰 경계가 있습니다. 사용자 입력이 신뢰 경계를 넘는 다른 경우를 검사하기 위해 사용자 지정 규칙을 작성하는 것도 고려해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>9</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9551B79681AA2391074FD33DC1F648EF" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LandingAssignment.java의 openPasswordReset() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LandingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java</FilePath>
<LineStart>62</LineStart>
<Snippet>    ModelAndView modelAndView = new ModelAndView();
    modelAndView.addObject(
        "webwolfLandingPageUrl", landingPageUrl.replace("//landing", "/landing"));
    modelAndView.addObject("uniqueCode", StringUtils.reverse(getWebSession().getUserName()));
</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LandingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java</FilePath>
<LineStart>62</LineStart>
<Snippet>    ModelAndView modelAndView = new ModelAndView();
    modelAndView.addObject(
        "webwolfLandingPageUrl", landingPageUrl.replace("//landing", "/landing"));
    modelAndView.addObject("uniqueCode", StringUtils.reverse(getWebSession().getUserName()));
</Snippet>
<TargetFunction>Read this.landingPageUrl()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CE1F014741E4BB5648D72069BEE882D1" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LandingAssignment.java의 openPasswordReset() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LandingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java</FilePath>
<LineStart>63</LineStart>
<Snippet>    modelAndView.addObject(
        "webwolfLandingPageUrl", landingPageUrl.replace("//landing", "/landing"));
    modelAndView.addObject("uniqueCode", StringUtils.reverse(getWebSession().getUserName()));

    modelAndView.setViewName("lessons/webwolfintroduction/templates/webwolfPasswordReset.html");</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7A2AD9F91A66399E36200113690B2992" ruleID="D15D5B27-53F4-4F78-8DF4-2AB924496A3F">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ResetLinkAssignment.java의 resetPassword() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>103</LineStart>
<Snippet>      PasswordChangeForm form = new PasswordChangeForm();
      form.setResetLink(link);
      model.addAttribute("form", form);
      modelAndView.addObject("form", form);
      modelAndView.setViewName(</Snippet>
<TargetFunction>org.springframework.ui.Model.addAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>98</LineStart>
<Snippet>
  @GetMapping("/PasswordReset/reset/reset-password/{link}")
  public ModelAndView resetPassword(@PathVariable(value = "link") String link, Model model) {
    ModelAndView modelAndView = new ModelAndView();
    if (ResetLinkAssignment.resetLinks.contains(link)) {</Snippet>
<TargetFunction>resetPassword(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1A8B09546B6E9509652C26AD4255AD2D" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MailboxController.java의 mail() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MailboxController.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/mailbox/MailboxController.java</FilePath>
<LineStart>51</LineStart>
<Snippet>    if (emails != null &amp;&amp; !emails.isEmpty()) {
      modelAndView.addObject("total", emails.size());
      modelAndView.addObject("emails", emails);
    }
    modelAndView.setViewName("mailbox");</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MailboxController.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/mailbox/MailboxController.java</FilePath>
<LineStart>48</LineStart>
<Snippet>    String username = (null != authentication) ? authentication.getName() : "anonymous";
    ModelAndView modelAndView = new ModelAndView();
    List&lt;Email&gt; emails = mailboxRepository.findByRecipientOrderByTimeDesc(username);
    if (emails != null &amp;&amp; !emails.isEmpty()) {
      modelAndView.addObject("total", emails.size());</Snippet>
<TargetFunction>org.owasp.webgoat.webwolf.mailbox.MailboxRepository.findByRecipientOrderByTimeDesc()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9924AA30226C163F1760FFCBD3856102" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Requests.java의 get() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Requests.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java</FilePath>
<LineStart>72</LineStart>
<Snippet>            .map(t -&gt; new Tracert(t.getTimestamp(), path(t), toJsonString(t)))
            .toList();
    model.addObject("traces", traces);

    return model;</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Requests.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java</FilePath>
<LineStart>47</LineStart>
<Snippet> */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = "/requests")</Snippet>
<TargetFunction>Requests(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="63A9C4C9750CF172334B4D00100A8FFE" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Requests.java의 get() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Requests.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java</FilePath>
<LineStart>72</LineStart>
<Snippet>            .map(t -&gt; new Tracert(t.getTimestamp(), path(t), toJsonString(t)))
            .toList();
    model.addObject("traces", traces);

    return model;</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Requests.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java</FilePath>
<LineStart>47</LineStart>
<Snippet> */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = "/requests")</Snippet>
<TargetFunction>Requests(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E3E76919680C80CE721A046CAE278010" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MissingFunctionACUsers.java의 listUsers() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MissingFunctionACUsers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java</FilePath>
<LineStart>64</LineStart>
<Snippet>      displayUsers.add(new DisplayUser(user, PASSWORD_SALT_SIMPLE));
    }
    model.addObject("allUsers", displayUsers);

    return model;</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MissingAccessControlUserRepository.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java</FilePath>
<LineStart>24</LineStart>
<Snippet>
  public List&lt;User&gt; findAllUsers() {
    return jdbcTemplate.query("select username, password, admin from access_control_users", mapper);
  }
</Snippet>
<TargetFunction>org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F94E7EF0E3C204FBA40C41764C0093DA" ruleID="80137882-8F75-45DA-A3FF-C83A4E1981B1">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ResetLinkAssignment.java의 resetPassword() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>104</LineStart>
<Snippet>      form.setResetLink(link);
      model.addAttribute("form", form);
      modelAndView.addObject("form", form);
      modelAndView.setViewName(
          VIEW_FORMATTER.formatted("password_reset")); // Display html page for changing password</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.addObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>98</LineStart>
<Snippet>
  @GetMapping("/PasswordReset/reset/reset-password/{link}")
  public ModelAndView resetPassword(@PathVariable(value = "link") String link, Model model) {
    ModelAndView modelAndView = new ModelAndView();
    if (ResetLinkAssignment.resetLinks.contains(link)) {</Snippet>
<TargetFunction>resetPassword(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B892F437DBC6E6E52F1069E21A93E137" ruleID="65BC1586-E429-4EA1-86CA-51FB4B32D667">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>WebWolfRedirect.java의 openWebWolf() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebWolfRedirect.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java</FilePath>
<LineStart>19</LineStart>
<Snippet>    var url = applicationContext.getEnvironment().getProperty("webwolf.url");

    return new ModelAndView("redirect:" + url + "/home");
  }
}</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.ModelAndView()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebWolfRedirect.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java</FilePath>
<LineStart>17</LineStart>
<Snippet>  @GetMapping("/WebWolf")
  public ModelAndView openWebWolf() {
    var url = applicationContext.getEnvironment().getProperty("webwolf.url");

    return new ModelAndView("redirect:" + url + "/home");</Snippet>
<TargetFunction>org.springframework.core.env.PropertyResolver.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Access Control: Database</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>적절한 access control 없이 UserValidator.java의 validate() 메서드는 공격자가 제어하는 기본 키를 포함하는 27 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>데이터베이스 Access control 오류는 다음 경우에 발생합니다.

1.	신뢰할 수 없는 소스에서 데이터가 프로그램에 입력됩니다.


2.	데이터는 SQL 쿼리에서 기본 키의 값을 지정하는 데 사용됩니다.



예제 1: 다음 코드는 메타 문자를 이스케이프 처리하고 SQL injection 취약성을 예방하는 매개 변수가 있는 SQL 문을 사용하여 지정한 ID [1]에 일치하는 송장을 검색하는 SQL 쿼리를 생성하여 실행합니다. ID는 현재 인증된 사용자와 관련이 있는 모든 송장 목록에서 선택합니다.


...
id = Integer.decode(request.getParameter("invoiceID"));
String query = "SELECT * FROM invoices WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setInt(1, id);
ResultSet results = stmt.execute();
...



문제는 개발자가 id의 가능한 모든 값을 고려할 수 없다는 점입니다. 인터페이스에서 현재 사용자의 송장 ID 목록을 생성하더라도 공격자는 이 인터페이스를 무시하고 원하는 송장을 요청할 수 있습니다. 이 예제의 코드가 사용자가 요청한 송장에 접근할 수 있는 권한이 있는지 확인하지 않기 때문에 현재 사용자의 송장이 아닌 송장도 모두 표시합니다.

모바일 환경에서는 데이터베이스 Access control 오류와 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.


예제 2: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String id = this.getIntent().getExtras().getString("invoiceID");
        String query = "SELECT * FROM invoices WHERE id = ?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{id});
...


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Access Control은 표현 계층에 의존하여 사용자가 전송한 값을 제한하기보다는 응용 프로그램 및 데이터베이스 계층에서 처리해야 합니다. 어떤 경우에도 사용자가 해당 권한 없이 데이터베이스의 행을 검색하거나 수정하는 것을 허용해서는 안 됩니다. 데이터베이스에 접근하는 모든 쿼리는 이 정책을 따라야 하는데 이는 현재 인증된 사용자 이름을 쿼리에 포함하기만 하면 구현할 수 있습니다. 


예제 3: 다음 코드는 Example 1과 같은 기능을 구현하지만 송장이 현재 인증된 사용자에게 속하는지 확인하기 위한 추가 제약 조건을 부과합니다.


...
userName = ctx.getAuthenticatedUserName();
id = Integer.decode(request.getParameter("invoiceID"));
String query =
        "SELECT * FROM invoices WHERE id = ? AND user = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setInt(1, id);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...



Android에 해당하는 코드는 다음과 같습니다.


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String id = this.getIntent().getExtras().getString("invoiceID");
        String query = "SELECT * FROM invoices WHERE id = ? AND user = ?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{id, userName});
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="78D79E403BDBE07F3BD264BD0580ADA9" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionChallenge.java의 registerNewUser() 메서드는 공격자가 제어하는 기본 키를 포함하는 82 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>82</LineStart>
<Snippet>          preparedStatement.setString(1, username_reg);
          preparedStatement.setString(2, email_reg);
          preparedStatement.setString(3, password_reg);
          preparedStatement.execute();
          attackResult = success(this).feedback("user.created").feedbackArgs(username_reg).build();</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>59</LineStart>
<Snippet>      @RequestParam String username_reg,
      @RequestParam String email_reg,
      @RequestParam String password_reg)
      throws Exception {
    AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);</Snippet>
<TargetFunction>registerNewUser(2)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="87FE0E2A4E81E33E835542D4B734FC46" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionChallengeLogin.java의 login() 메서드는 공격자가 제어하는 기본 키를 포함하는 58 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallengeLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java</FilePath>
<LineStart>58</LineStart>
<Snippet>          connection.prepareStatement(
              "select password from sql_challenge_users where userid = ? and password = ?");
      statement.setString(1, username_login);
      statement.setString(2, password_login);
      var resultSet = statement.executeQuery();</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionChallengeLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    try (var connection = dataSource.getConnection()) {
      var statement =</Snippet>
<TargetFunction>login(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C9C0BF806ADD65AD9E511076560730CB" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionChallenge.java의 registerNewUser() 메서드는 공격자가 제어하는 기본 키를 포함하는 81 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>81</LineStart>
<Snippet>              connection.prepareStatement("INSERT INTO sql_challenge_users VALUES (?, ?, ?)");
          preparedStatement.setString(1, username_reg);
          preparedStatement.setString(2, email_reg);
          preparedStatement.setString(3, password_reg);
          preparedStatement.execute();</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>58</LineStart>
<Snippet>  public AttackResult registerNewUser(
      @RequestParam String username_reg,
      @RequestParam String email_reg,
      @RequestParam String password_reg)
      throws Exception {</Snippet>
<TargetFunction>registerNewUser(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4CD9946DDA17EFB4514516D6450229B2" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionLesson13.java의 completed() 메서드는 공격자가 제어하는 기본 키를 포함하는 62 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson13.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java</FilePath>
<LineStart>62</LineStart>
<Snippet>        PreparedStatement preparedStatement =
            connection.prepareStatement("select ip from servers where ip = ? and hostname = ?")) {
      preparedStatement.setString(1, ip);
      preparedStatement.setString(2, "webgoat-prd");
      ResultSet resultSet = preparedStatement.executeQuery();</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson13.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java</FilePath>
<LineStart>58</LineStart>
<Snippet>  @PostMapping("/SqlInjectionMitigations/attack12a")
  @ResponseBody
  public AttackResult completed(@RequestParam String ip) {
    try (Connection connection = dataSource.getConnection();
        PreparedStatement preparedStatement =</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A8DFCE125FCB4ECE37865FD804FD9CF3" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionLesson5b.java의 injectableQuery() 메서드는 공격자가 제어하는 기본 키를 포함하는 82 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>82</LineStart>
<Snippet>      }

      query.setInt(1, count);
      // String query = "SELECT * FROM user_data WHERE Login_Count = " + login_count + " and userid
      // = " + accountName, ;</Snippet>
<TargetFunction>java.sql.PreparedStatement.setInt()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson5b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(
      @RequestParam String userid, @RequestParam String login_count, HttpServletRequest request)
      throws IOException {
    return injectableQuery(login_count, userid);</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4BC169646D09490A78AB5E8A500EB381" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionChallengeLogin.java의 login() 메서드는 공격자가 제어하는 기본 키를 포함하는 59 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallengeLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java</FilePath>
<LineStart>59</LineStart>
<Snippet>              "select password from sql_challenge_users where userid = ? and password = ?");
      statement.setString(1, username_login);
      statement.setString(2, password_login);
      var resultSet = statement.executeQuery();
</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionChallengeLogin.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  @ResponseBody
  public AttackResult login(
      @RequestParam String username_login, @RequestParam String password_login) throws Exception {
    try (var connection = dataSource.getConnection()) {
      var statement =</Snippet>
<TargetFunction>login(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="6C429881B37DFD82778C1F0BA56B725F" ruleID="7E257BA2-628C-4BF8-AB9F-19DA68E8964F0">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 UserValidator.java의 validate() 메서드는 공격자가 제어하는 기본 키를 포함하는 27 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>UserValidator.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/users/UserValidator.java</FilePath>
<LineStart>27</LineStart>
<Snippet>    UserForm userForm = (UserForm) o;

    if (userRepository.findByUsername(userForm.getUsername()) != null) {
      errors.rejectValue("username", "username.duplicate");
    }</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RegistrationController.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/users/RegistrationController.java</FilePath>
<LineStart>35</LineStart>
<Snippet>  @PostMapping("/register.mvc")
  public String registration(
      @ModelAttribute("userForm") @Valid UserForm userForm,
      BindingResult bindingResult,
      HttpServletRequest request)</Snippet>
<TargetFunction>registration(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8424E6E59CA0A6A55BE70871888E021B" ruleID="A53E6ED8-2131-4F10-B320-4158B7238CFA">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>적절한 access control 없이 SqlInjectionChallenge.java의 registerNewUser() 메서드는 공격자가 제어하는 기본 키를 포함하는 80 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>80</LineStart>
<Snippet>          PreparedStatement preparedStatement =
              connection.prepareStatement("INSERT INTO sql_challenge_users VALUES (?, ?, ?)");
          preparedStatement.setString(1, username_reg);
          preparedStatement.setString(2, email_reg);
          preparedStatement.setString(3, password_reg);</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionChallenge.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java</FilePath>
<LineStart>57</LineStart>
<Snippet>  @ResponseBody
  public AttackResult registerNewUser(
      @RequestParam String username_reg,
      @RequestParam String email_reg,
      @RequestParam String password_reg)</Snippet>
<TargetFunction>registerNewUser(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Resource Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>공격자는 MavenWrapperDownloader.java의 108 줄에 있는 URL()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Resource injection 이슈는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 시스템 리소스에 접근할 때 사용하는 ID를 지정할 수 있습니다.

예를 들어 공격자는 네트워크 리소스에 연결할 때 사용할 포트 번호를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램은 공격자에게 민감한 정보를 제 3의 서버에 전달하는 능력을 부여합니다.



참고: 사용자가 파일 시스템에 저장된 리소스의 위치를 조작할 수 있는 Resource Injection은 경로 조작이라는 별도의 범주로 보고됩니다. 이 취약점에 대한 자세한 내용은 Path Manipulation 설명을 참조하십시오.

예제 1: 다음 코드는 HTTP 요청에서 읽은 포트 번호를 사용하여 소켓을 생성합니다.


String remotePort = request.getParameter("remotePort");
...
ServerSocket srvr = new ServerSocket(remotePort);
Socket skt = srvr.accept();
...


모바일 환경에서는 Resource Injection과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 2: 다음 코드는 Android 인텐트에서 읽은 URL을 사용하여 WebView에서 페이지를 로드합니다.


...
	WebView webview = new WebView(this);
	setContentView(webview);
        String url = this.getIntent().getExtras().getString("url");
	webview.loadUrl(url);
...


사용자 입력이 적용되는 리소스는 콘텐트가 위험할 수 있음을 나타냅니다. 예를 들어, 마침표, 슬래시 및 백슬래시 등의 특수 문자가 포함된 데이터는 file system과 상호 작용하는 메서드에 사용하면 위험합니다. 마찬가지로 URL 및 URI가 포함된 데이터도 원격 연결을 설정하는 함수에 사용하면 위험합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Resource injection 공격을 예방하는 최선의 방법은 다음 간접 참조를 사용하는 것입니다. 즉, 사용자가 지정할 수 있는 올바른 리소스 이름 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이 접근 방식을 사용하면 사용자가 제공하는 입력은 리소스 이름을 지정하는 데 직접 사용되지 않습니다. 

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="ECE527D15B7BF616744330FCA3ED5064" ruleID="8F3B2393-5D1E-4860-A96F-0F6E0274923F">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadRetrieval.java의 106 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>106</LineStart>
<Snippet>      }
      return ResponseEntity.status(HttpStatus.NOT_FOUND)
          .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())</Snippet>
<TargetFunction>java.net.URI.URI()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>90</LineStart>
<Snippet>    }
    try {
      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");</Snippet>
<TargetFunction>jakarta.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="ECE527D15B7BF616744330FCA3ED5063" ruleID="8F3B2393-5D1E-4860-A96F-0F6E0274923F">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadRetrieval.java의 102 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>102</LineStart>
<Snippet>        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
            .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
            .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
      }</Snippet>
<TargetFunction>java.net.URI.URI()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>90</LineStart>
<Snippet>    }
    try {
      var id = request.getParameter("id");
      var catPicture =
          new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + ".jpg");</Snippet>
<TargetFunction>jakarta.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="DBC5851984DD5F18E9B515DA136B5372" ruleID="2DEE27D8-C41F-48FC-8B40-FA60B403AEAE">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 SSRFTask2.java의 51 줄에 있는 URL()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTask2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java</FilePath>
<LineStart>51</LineStart>
<Snippet>    if (url.matches("http://ifconfig\\.pro")) {
      String html;
      try (InputStream in = new URL(url).openStream()) {
        html =
            new String(in.readAllBytes(), StandardCharsets.UTF_8)</Snippet>
<TargetFunction>java.net.URL.URL()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSRFTask2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java</FilePath>
<LineStart>44</LineStart>
<Snippet>  @PostMapping("/SSRF/task2")
  @ResponseBody
  public AttackResult completed(@RequestParam String url) {
    return furBall(url);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B0B0614294D0FD1F5D1369365CAC184D" ruleID="2DEE27D8-C41F-48FC-8B40-FA60B403AEAE">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 MavenWrapperDownloader.java의 108 줄에 있는 URL()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>108</LineStart>
<Snippet>            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());</Snippet>
<TargetFunction>java.net.URL.URL()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>62</LineStart>
<Snippet>                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {</Snippet>
<TargetFunction>java.util.Properties.load()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4C7FA25C3E9DAB901524C9049A201EA9" ruleID="8F3B2393-5D1E-4860-A96F-0F6E0274923F">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadRetrieval.java의 102 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>102</LineStart>
<Snippet>        return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
            .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
            .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
      }</Snippet>
<TargetFunction>java.net.URI.URI()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1C8B8C673657FCA71FAA7BD981BDC0E4" ruleID="8F3B2393-5D1E-4860-A96F-0F6E0274923F">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 Assignment7.java의 79 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment7.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7.java</FilePath>
<LineStart>79</LineStart>
<Snippet>      String username = email.substring(0, email.indexOf("@"));
      if (StringUtils.hasText(username)) {
        URI uri = new URI(request.getRequestURL().toString());
        Email mail =
            Email.builder()</Snippet>
<TargetFunction>java.net.URI.URI()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Assignment7.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7.java</FilePath>
<LineStart>79</LineStart>
<Snippet>      String username = email.substring(0, email.indexOf("@"));
      if (StringUtils.hasText(username)) {
        URI uri = new URI(request.getRequestURL().toString());
        Email mail =
            Email.builder()</Snippet>
<TargetFunction>jakarta.servlet.http.HttpServletRequest.getRequestURL()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7DE83FC822F415D0A23A2A6C2634FD44" ruleID="8F3B2393-5D1E-4860-A96F-0F6E0274923F">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 LandingAssignment.java의 59 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LandingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @GetMapping("/WebWolf/landing/password-reset")
  public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {
    URI uri = new URI(request.getRequestURL().toString());
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.addObject(</Snippet>
<TargetFunction>java.net.URI.URI()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LandingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java</FilePath>
<LineStart>59</LineStart>
<Snippet>  @GetMapping("/WebWolf/landing/password-reset")
  public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {
    URI uri = new URI(request.getRequestURL().toString());
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.addObject(</Snippet>
<TargetFunction>jakarta.servlet.http.HttpServletRequest.getRequestURL()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4C7FA25C3E9DAB901524C9049A201EAA" ruleID="8F3B2393-5D1E-4860-A96F-0F6E0274923F">
                            <Category>Resource Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자는 ProfileUploadRetrieval.java의 106 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>106</LineStart>
<Snippet>      }
      return ResponseEntity.status(HttpStatus.NOT_FOUND)
          .location(new URI("/PathTraversal/random-picture?id=" + catPicture.getName()))
          .body(
              StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles())</Snippet>
<TargetFunction>java.net.URI.URI()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>46</LineStart>
<Snippet>  private final File catPicturesDirectory;

  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();</Snippet>
<TargetFunction>ProfileUploadRetrieval(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>System Information Leak</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 "표준 오류" 또는 "표준 출력"에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 "syslog" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = "NfcActivity";
private static final String DATA_SPLITTER = "__:DATA:__";
private static final String MIME_TYPE = "application/my.applications.mimetype";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, "접근 거부" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.

3. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3D8E3F1E6D855B390D358B7620CDD2E5" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson10b.java의 getJavaFileContentsAsString() 함수는 130 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson10b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson10b.java</FilePath>
<LineStart>130</LineStart>
<Snippet>      javaFileObject = new JavaObjectFromString("TestClass.java", javaFileContents.toString());
    } catch (Exception exception) {
      exception.printStackTrace();
    }
    return javaFileObject;</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BB8E8F3A3EC6AE905B20C5A51164BA7C" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>92</LineStart>
<Snippet>        } catch (Throwable e) {
            System.out.println("- Error downloading");
            e.printStackTrace();
            System.exit(1);
        }</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E7271EB4A485D55EBF78079536C6D7C3" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>CryptoIntegrationTest.java의 runTests() 함수는 39 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java</FilePath>
<LineStart>39</LineStart>
<Snippet>      checkAssignmentSigning();
    } catch (Exception e) {
      e.printStackTrace();
      fail();
    }</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2BB04F6C58A5EFE4E81CCA9783CDE8EE" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson6b.java의 getPassword() 함수는 75 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java</FilePath>
<LineStart>75</LineStart>
<Snippet>      }
    } catch (Exception e) {
      e.printStackTrace();
      // do nothing
    }</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E7271EB4A485D55EBF78079536C6D7C4" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>CryptoIntegrationTest.java의 runTests() 함수는 32 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java</FilePath>
<LineStart>32</LineStart>
<Snippet>      checkAssignment4();
    } catch (NoSuchAlgorithmException e) {
      e.printStackTrace();
      fail();
    }</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="78CE75F00CF67099296BB555F15EB100" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SSRFTask1.java의 stealTheCheese() 함수는 62 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SSRFTask1.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask1.java</FilePath>
<LineStart>62</LineStart>
<Snippet>      }
    } catch (Exception e) {
      e.printStackTrace();
      return failed(this).output(e.getMessage()).build();
    }</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="27A7434215CF56F0786D8A51D756C8EA" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LabelAndHintIntegrationTest.java의 getProperties() 함수는 171 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>171</LineStart>
<Snippet>      prop.load(input);
    } catch (Exception e) {
      e.printStackTrace();
    }
    return prop;</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EAEE204E6CE4B766CEE4C59FD4106F3B" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SqlInjectionLesson6b.java의 getPassword() 함수는 71 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6b.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java</FilePath>
<LineStart>71</LineStart>
<Snippet>        }
      } catch (SQLException sqle) {
        sqle.printStackTrace();
        // do nothing
      }</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Password Management: Password in Comment</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>암호를 하드코드하는 것은 좋은 방법이 아닙니다. 주석 안에 자세한 암호 정보를 저장하는 것은 암호를 하드코드하는 것과 마찬가지입니다. 모든 프로젝트 개발자에게 암호가 표시될 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 암호가 외부로 유출되어 소프트웨어 패치 없이는 암호를 보호하거나 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제: 다음 주석은 데이터베이스에 연결할 기본 암호를 지정합니다.


...
// Default username for database connection is "scott"
// Default password for database connection is "tiger"
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>7</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="174C76B2D346E7A84A213F5A0E1309E8" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson6a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java</FilePath>
<LineStart>58</LineStart>
<Snippet>  public AttackResult completed(@RequestParam(value = "userid_6a") String userId) {
    return injectableQuery(userId);
    // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from
    // user_system_data --
  }</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0001975526E6118B9552413F279D2CE2" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurePasswordsAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java</FilePath>
<LineStart>80</LineStart>
<Snippet>      output.append("&lt;b&gt;Warning: &lt;/b&gt;" + strength.getFeedback().getWarning() + "&lt;/br&gt;");
    // possible feedback: https://github.com/dropbox/zxcvbn/blob/master/src/feedback.coffee
    // maybe ask user to try also weak passwords to see and understand feedback?
    if (strength.getFeedback().getSuggestions().size() != 0) {
      output.append("&lt;b&gt;Suggestions:&lt;/b&gt;&lt;/br&gt;&lt;ul&gt;");</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FA1668F9C81061945FC2B459758FEFCB" ruleID="9DC93E75-BA94-4FA1-A177-ED1201EB29BC">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/jquery_form/jquery.form.js</FilePath>
<LineStart>931</LineStart>
<Snippet>};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F37427E77DF6D3DB885A16B84CC6D0A6" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentForgotPassword.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentForgotPassword.java</FilePath>
<LineStart>39</LineStart>
<Snippet>import org.springframework.web.client.RestTemplate;

/**
 * Part of the password reset assignment. Used to send the e-mail.
 *</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FA1668F9C81061945FC2B459758FEFCC" ruleID="9DC93E75-BA94-4FA1-A177-ED1201EB29BC">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/jquery.form.js</FilePath>
<LineStart>931</LineStart>
<Snippet>};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="908F0DD2143EB89DCAE785BF0B98160D" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>106</LineStart>
<Snippet>      modelAndView.addObject("form", form);
      modelAndView.setViewName(
          VIEW_FORMATTER.formatted("password_reset")); // Display html page for changing password
    } else {
      modelAndView.setViewName(VIEW_FORMATTER.formatted("password_link_not_found"));</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D3F57E8DE6980CFD3CF0712B164E9B88" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java</FilePath>
<LineStart>71</LineStart>
<Snippet>      """
          Hi, you requested a password reset link, please use this &lt;a target='_blank'
           href='http://%s/WebGoat/PasswordReset/reset/reset-password/%s'&gt;link&lt;/a&gt; to reset your
           password.
</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Privacy Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Privacy violation은 다음 경우에 발생합니다.

1. 사용자 개인 정보가 프로그램에 입력됩니다.

2. 데이터는 콘솔, file system 또는 네트워크와 같은 외부 위치에 작성됩니다.


예제 1: 다음 코드에는 데이터베이스에 추가되는 레코드를 로그 파일의 콘텐트에 저장하여 추적하는 로깅 명령문이 있습니다.


pass = getPassword();
...
dbmsLog.println(id+":"+pass+":"+type+":"+tstamp);


Example 1의 코드는 일반 텍스트 암호를 파일 시스템에 기록합니다. 많은 개발자가 파일 시스템을 안전한 데이터 저장소로 신뢰하지만 무조건 신뢰해서는 안 됩니다. 특히 개인 정보가 관련된 경우가 대표적입니다.

개인 정보는 다음의 두 가지 이유 때문에 모바일 환경에서 크게 대두되는 문제 중 하나입니다. 그중 하나는 장치 분실 가능성이 훨씬 더 높다는 점이고, 다른 하나는 모바일 응용 프로그램 사이에서 프로세스 간 통신이 이뤄진다는 점입니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다. 모바일 응용 프로그램 사이에 진행되는 프로세스 간 통신에 민감한 정보를 포함해서는 안 됩니다.

예제 2: 다음 코드는 Android WebView 저장소에서 지정된 사이트의 사용자 이름과 암호를 읽은 다음 등록된 모든 수신자에게 브로드캐스트합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction("SEND_CREDENTIALS");
    i.putExtra("username", username);
    i.putExtra("password", password);
    view.getContext().sendBroadcast(i);
  }
});
...


이 예는 몇 가지 문제를 보여줍니다. 첫째, WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 사용자가 루팅된 장치나 에뮬레이터를 사용하는 경우 지정된 사이트에 저장된 암호를 읽을 수 있습니다. 둘째, 일반 텍스트 자격 증명은 등록된 모든 수신자에게 브로드캐스트되어 SEND_CREDENTIALS 작업을 통해 인텐트를 수신 대기하도록 등록된 모든 수신자가 메시지를 수신합니다. 이 경우 수정 방법으로 권한을 사용하지 않는 것이 좋지만, 브로드캐스트는 수신자 수를 제한하는 권한으로도 보호되지 않습니다.

개인 정보는 다음과 같은 다양한 방식으로 프로그램에 입력됩니다.

- 암호 또는 개인 정보의 형태로 사용자가 직접 입력

- 응용 프로그램이 데이터베이스 또는 기타 데이터 저장소에서 접근

- 협력업체 또는 타사를 통해 간접적으로

일반적으로 모바일 환경에서 이 개인 정보는 암호, SSN 및 기타 일반 개인 정보에 따라 다음 사항을 포함합니다.

- 위치

- 휴대폰 번호

- 일련번호 및 장치 ID

- 네트워크 연산자 정보

- 보이스메일 정보


개인 정보로 명명되지 않은 데이터도 상황에 따라 개인 정보로 해석될 수 있습니다. 예를 들어, 학생 ID 번호는 명시적이고 공개적으로 각 학생의 개인 정보에 매핑되지 않기 때문에 보통 개인 정보로 간주하지 않습니다. 하지만 학교에서 학생의 주민 등록 번호를 기반으로 ID 번호를 생성하는 경우 ID 번호는 개인 정보로 간주해야 합니다.

보안 및 개인 정보 문제는 서로 상충하는 것처럼 보일 때가 있습니다. 보안 관점에서 보면 이후에 비정상적인 활동을 식별할 수 있도록 모든 중요한 작업을 기록해야 합니다. 하지만 개인 정보가 관련된 경우 이 방법은 위험이 따릅니다.

개인 정보를 위험하게 처리하는 방법은 여러 가지가 있겠지만 공통적인 위험은 잘못된 신뢰에서 비롯됩니다. 프로그래머는 프로그램이 실행되는 운영 환경을 신뢰하기 때문에 개인 정보를 파일 시스템, 레지스트리 또는 기타 로컬로 제어되는 리소스에 저장해도 무방하다고 생각합니다. 하지만 특정 리소스에 대한 액세스가 제한되어 있는 경우에도 액세스 권한을 가진 개인을 신뢰할 수 있다고 보장할 수 없습니다. 일례로, 2004년, AOL의 한 비양심적인 직원이 해외 도박 웹 사이트를 대상으로 영업하는 스패머에게 약 9천 2백만 개의 고객 전자 메일 주소를 팔았습니다[1].

이런 대형 익스플로이트 사건에 대응하여 개인 정보 수집 및 관리에 대한 규제가 점점 엄격해지고 있습니다. 조직의 위치, 업종 및 취급하는 개인 정보의 속성에 따라 조직은 다음의 연방 정부 및 주 정부의 규제를 하나 이상 준수할 의무가 있습니다.

- 세이프 하버 협정(Safe Harbor Privacy Framework)[3]

- GLBA(Gramm-Leach Bliley Act)[4]

- HIPAA(Health Insurance Portability and Accountability Act)[5]

- California SB-1386 [6]

이런 규제에도 불구하고 privacy violation은 우려할 만한 빈도로 계속 발생하고 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>보안과 개인 정보가 충돌할 경우, 보통 개인 정보에 더 높은 우선 순위를 부여해야 합니다. 이를 따르면서 필요한 보안 정보도 유지하기 위해 프로그램을 종료하기 전에 모든 개인 정보를 정리(cleanse)합니다.

훌륭한 개인 정보 관리를 위해서는 내부 개인 정보 지침을 작성하여 엄격하게 준수해야 합니다. 지침에는 응용 프로그램이 개인 정보 데이터를 처리하는 방식을 구체적으로 기술해야 합니다. 조직이 연방법 또는 주법에 따라 규제를 받는 경우, 개인 정보 지침이 법적 요구 사항을 만족하도록 합니다. 조직이 규제를 받지 않는 경우에도 개인 정보를 보호해야 합니다. 그렇지 않으면 고객의 신뢰를 잃을 위험이 있습니다.

개인 정보에 관한 최선의 정책은 노출을 최소화하는 것입니다. 업무 수행에 반드시 필요한 경우를 제외하고 응용 프로그램, 프로세스 및 직원에게 개인 정보에 대한 접근 권한을 부여해서는 안 됩니다. 필요 이상의 권한으로 작업을 수행할 수 없다는 최소 권한 원칙과 함께 개인 정보에 대한 접근을 최소한의 그룹으로 제한하는 것이 좋습니다.

모바일 응용 프로그램이 장치에서 실행되는 다른 응용 프로그램에 민감한 데이터를 전달하지 않도록 합니다. 개인 정보를 저장해야 하는 경우에는 항상 암호화해야 합니다. Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 따라서 암호화된 데이터베이스에 자격 증명을 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.

예제 4: 다음 코드는 Android WebView 저장소에서 지정된 사이트의 사용자 이름과 암호를 읽은 다음 이를 등록된 모든 수신자로 브로드캐스트하는 대신, 동일한 응용 프로그램 내의 다른 부분만 브로드캐스트를 볼 수 있도록 내부적으로만 브로드캐스트합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction("SEND_CREDENTIALS");
    i.putExtra("username", username);
    i.putExtra("password", password);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
  }
});
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Privacy Violation에 대비한 철저한 감사의 일환으로 사용자 지정 규칙을 작성하여 프로그램에 입력되는 개인 정보 또는 기타 민감한 정보의 모든 출처를 식별하도록 합니다. 개인 정보 출처 대부분은 자동으로 식별할 수 없습니다. 사용자 지정 규칙이 없으면 privacy violation 검사는 상당히 불완전할 것입니다.

2. Fortify Java Annotations FortifyPassword, FortifyNotPassword, FortifyPrivate 및 FortifyNotPrivate를 사용하여 암호 및 개인 정보를 나타내는 필드 및 변수를 표시할 수 있습니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>7</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9FE7635289F1960D5327A6F4312523EF" ruleID="C4FCEF97-FF0A-4683-8B29-5B0E5AEE65570">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>clientSideFiltering.js 파일은 38 줄의 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우가 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>38</LineStart>
<Snippet>
        var newdiv = document.createElement("div");
        newdiv.innerHTML = html;
        var container = document.getElementById("hiddenEmployeeRecords");
        container.appendChild(newdiv);</Snippet>
<TargetFunction>Assignment to newdiv.innerHTML()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>31</LineStart>
<Snippet>            html = html + '&lt;td&gt;' + result[i].FirstName + '&lt;/td&gt;';
            html = html + '&lt;td&gt;' + result[i].LastName + '&lt;/td&gt;';
            html = html + '&lt;td&gt;' + result[i].SSN + '&lt;/td&gt;';
            html = html + '&lt;td&gt;' + result[i].Salary + '&lt;/td&gt;';
            html = html + '&lt;/tr&gt;';</Snippet>
<TargetFunction>Read SSN()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="327A61D07BCA5E76E2F8918566E8F495" ruleID="31546B66-03D9-48A3-A1B8-0DF151C9DA2B0">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>56</LineStart>
<Snippet>      request.getSession().setAttribute("basicAuth", basicAuth);
    }
    return "Authorization: Basic ".concat(basicAuth);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>41</LineStart>
<Snippet>
  public static String getBasicAuth(String username, String password) {
    return Base64.getEncoder().encodeToString(username.concat(":").concat(password).getBytes());
  }
</Snippet>
<TargetFunction>Read password()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3444F2328A8B41AE6A759D9990B36DF2" ruleID="31546B66-03D9-48A3-A1B8-0DF151C9DA2B0">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>SecurePasswordsAssignment.java의 completed() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SecurePasswordsAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java</FilePath>
<LineStart>90</LineStart>
<Snippet>
    if (strength.getScore() &gt;= 4)
      return success(this).feedback("securepassword-success").output(output.toString()).build();
    else return failed(this).feedback("securepassword-failed").output(output.toString()).build();
  }</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SecurePasswordsAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java</FilePath>
<LineStart>50</LineStart>
<Snippet>
    output.append("&lt;b&gt;Your Password: *******&lt;/b&gt;&lt;/br&gt;");
    output.append("&lt;b&gt;Length: &lt;/b&gt;" + password.length() + "&lt;/br&gt;");
    output.append(
        "&lt;b&gt;Estimated guesses needed to crack your password: &lt;/b&gt;"</Snippet>
<TargetFunction>Read password()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="327A61D07BCA5E76E2F8918566E8F496" ruleID="31546B66-03D9-48A3-A1B8-0DF151C9DA2B0">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>56</LineStart>
<Snippet>      request.getSession().setAttribute("basicAuth", basicAuth);
    }
    return "Authorization: Basic ".concat(basicAuth);
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EncodingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java</FilePath>
<LineStart>53</LineStart>
<Snippet>      String password =
          HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
      basicAuth = getBasicAuth(username, password);
      request.getSession().setAttribute("basicAuth", basicAuth);
    }</Snippet>
<TargetFunction>Read password()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="432CCB0CB50E1827E48DAEB31F1D05A6" ruleID="31546B66-03D9-48A3-A1B8-0DF151C9DA2B0">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>SecurePasswordsAssignment.java의 completed() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SecurePasswordsAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java</FilePath>
<LineStart>91</LineStart>
<Snippet>    if (strength.getScore() &gt;= 4)
      return success(this).feedback("securepassword-success").output(output.toString()).build();
    else return failed(this).feedback("securepassword-failed").output(output.toString()).build();
  }
</Snippet>
<TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SecurePasswordsAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java</FilePath>
<LineStart>50</LineStart>
<Snippet>
    output.append("&lt;b&gt;Your Password: *******&lt;/b&gt;&lt;/br&gt;");
    output.append("&lt;b&gt;Length: &lt;/b&gt;" + password.length() + "&lt;/br&gt;");
    output.append(
        "&lt;b&gt;Estimated guesses needed to crack your password: &lt;/b&gt;"</Snippet>
<TargetFunction>Read password()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A2235C48B1F31D614FB7FF0C10EF2E71" ruleID="31546B66-03D9-48A3-A1B8-0DF151C9DA2B0">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>SigningAssignment.java의 getPrivateKey() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SigningAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java</FilePath>
<LineStart>64</LineStart>
<Snippet>      request.getSession().setAttribute("keyPair", keyPair);
    }
    return privateKey;
  }
</Snippet>
<TargetFunction>Return privateKey()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SigningAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java</FilePath>
<LineStart>64</LineStart>
<Snippet>      request.getSession().setAttribute("keyPair", keyPair);
    }
    return privateKey;
  }
</Snippet>
<TargetFunction>Read privateKey()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7096CF2041D404F4C0A8B1C9AEA614B4" ruleID="BAADF2C8-89C1-415D-BAA0-7FA62199BC83">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>LogBleedingTask.java의 generatePassword() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>LogBleedingTask.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java</FilePath>
<LineStart>50</LineStart>
<Snippet>    log.info(
        "Password for admin: {}",
        Base64.getEncoder().encodeToString(password.getBytes(StandardCharsets.UTF_8)));
  }
</Snippet>
<TargetFunction>org.slf4j.Logger.info()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LogBleedingTask.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java</FilePath>
<LineStart>50</LineStart>
<Snippet>    log.info(
        "Password for admin: {}",
        Base64.getEncoder().encodeToString(password.getBytes(StandardCharsets.UTF_8)));
  }
</Snippet>
<TargetFunction>Read this.password()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Log Forging</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Salaries.java의 invoke() 메서드는 확인되지 않은 사용자 입력을 108 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Log forging 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스에서 데이터가 응용 프로그램에 입력됩니다. 

2. 응용 프로그램 또는 시스템 로그 파일에 데이터가 작성됩니다. 

응용 프로그램은 일반적으로 차후 검토, 통계 수집 또는 디버깅을 위해 로그 파일을 사용하여 이벤트나 트랙잭션의 기록을 저장합니다. 로그 파일 검토 작업은 응용 프로그램의 성격에 따라 필요할 때 수동으로 수행할 수도 있고 자동으로 중요한 이벤트나 추세 정보의 로그를 발췌하는 도구를 사용하여 자동으로 수행할 수도 있습니다.

공격자가 응용 프로그램에 데이터를 공급하고 이후에 문자 그대로 응용 프로그램에 대한 로그가 작성되면 로그 파일 해석이 방해를 받거나 잘못될 수 있습니다. 가장 가벼운 공격은 공격자가 응용 프로그램에 해당 문자가 포함된 입력을 제공하는 방식으로 로그 파일에 가짜 항목을 삽입하는 것입니다. 로그 파일을 자동으로 처리하는 경우 공격자는 파일의 형식을 손상시키거나 잘못된 문자를 삽입하여 파일을 사용할 수 없게 만들 수 있습니다. 보다 효과적인 공격은 로그 파일 통계를 왜곡하는 것입니다. 왜곡 또는 다른 방식으로 손상된 로그 파일을 사용하여 공격자의 공격 루트를 은폐하거나 심지어 악의적인 행위에 제 3자를 끌어들일 수도 있습니다[1]. 최악의 경우는 공격자가 코드나 다른 명령을 로그 파일에 삽입하고 로그 처리 유틸리티의 취약점을 이용하는 것입니다[2].

예제 1: 다음 웹 응용 프로그램 코드는 요청 개체에서 정수 값을 읽으려고 합니다. 값을 정수로 구문 분석할 수 없으면 문제점을 나타내는 오류 메시지와 함께 입력을 기록합니다.


...
	String val = request.getParameter("val");
	try {
  		int value = Integer.parseInt(val);
	}
	catch (NumberFormatException nfe) {
  		log.info("Failed to parse val = " + val);
	}
...


사용자가 val에 문자열 "twenty-one"을 전송하면 다음 항목이 기록됩니다.


INFO: Failed to parse val=twenty-one


그러나, 공격자가 "twenty-one%0a%0aINFO:+User+logged+out%3dbadguy" 문자열을 전송하는 경우 다음 항목이 기록됩니다.


INFO: Failed to parse val=twenty-one

INFO: User logged out=badguy


공격자가 같은 메커니즘을 사용하여 임의의 로그 항목을 삽입할 수 있다는 것은 말할 필요도 없습니다.

모바일 환경에서는 Log forging과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 2: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
	String val = this.getIntent().getExtras().getString("val");
	try {
		int value = Integer.parseInt();
	}
	catch (NumberFormatException nfe) {
		Log.e(TAG, "Failed to parse val = " + val);
        }
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>간접 참조로 log forging 공격을 예방하십시오. 기록해야 하는 각 이벤트에 해당하는 올바른 로그 항목 집합을 만들어 이 집합의 항목만 기록합니다. 사용자의 시스템 로그아웃과 같은 동적 콘텐트를 캡처하려면 항상 사용자가 제공하는 데이터가 아닌 서버에서 제어하는 값을 사용하십시오. 이렇게 하면 사용자가 제공하는 입력은 로그 항목에 직접 사용되지 않습니다. 

다음과 같이 NumberFormatException에 해당하는 사전 정의된 로그 항목을 사용하도록 예제 1을 다시 작성할 수 있습니다.


...
	public static final String NFE = "Failed to parse val. The input is required to be an integer value."
...
	String val = request.getParameter("val");
        try {
                int value = Integer.parseInt(val);
        }
        catch (NumberFormatException nfe) {
                log.info(NFE);
        }
..


Android에 해당하는 코드는 다음과 같습니다.


...
	public static final String NFE = "Failed to parse val. The input is required to be an integer value."
...
        String val = this.getIntent().getExtras().getString("val");
        try {
                int value = Integer.parseInt();
        }
        catch (NumberFormatException nfe) {
                Log.e(TAG, NFE);
        }
...


경우에 따라 올바른 로그 항목 집합이 너무 크거나 복잡하기 때문에 이 접근 방식은 실용적이지 못합니다. 이런 상황에서 개발자는 흔히 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자 목록은 금방 불완전해지거나 최신 상태를 유지하기 어렵습니다. 효율적인 접근 방식은 로그 항목에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다. 대부분의 log forging 공격에서 핵심이 되는 문자는 '\n'(줄 바꿈) 문자로 이 문자는 로그 항목 허용 목록에 포함해서는 안 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 많은 로깅 작업이 개발 및 테스트 도중 프로그램 디버깅의 목적을 위해서만 만들어집니다. 경험에 따르면 우연이든, 의도적이든 운영 과정에서 디버깅을 사용하게 됩니다. 단지 프로그래머가 "운영에 디버깅을 사용할 계획이 없다"고 말한다고 해서 log forging 취약점을 간과해서는 안 됩니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="960DC0BBFA4CA80AB81A19179ECCD1AE" ruleID="9667C493-BADE-4668-87D9-BF3CCA799FD9">
                            <Category>Log Forging</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Salaries.java의 invoke() 메서드는 확인되지 않은 사용자 입력을 108 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>108</LineStart>
<Snippet>      log.error("Unable to parse xml", e);
    } catch (IOException e) {
      log.error("Unable to read employees.xml at location: '{}'", d);
    }
    return json;</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>77</LineStart>
<Snippet>  public List&lt;Map&lt;String, Object&gt;&gt; invoke() {
    NodeList nodes = null;
    File d = new File(webGoatHomeDirectory, "ClientSideFiltering/employees.xml");
    XPathFactory factory = XPathFactory.newInstance();
    XPath path = factory.newXPath();</Snippet>
<TargetFunction>Read this.webGoatHomeDirectory()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0911B479D71CAF46F2D548215839D773" ruleID="9667C493-BADE-4668-87D9-BF3CCA799FD9">
                            <Category>Log Forging</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 메서드는 확인되지 않은 사용자 입력을 81 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>      Files.writeString(new File(targetDirectory, "secret.txt").toPath(), fileContents, UTF_8);
    } catch (IOException e) {
      log.error("Unable to write 'secret.txt' to '{}", targetDirectory);
    }
  }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>UserService.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/users/UserService.java</FilePath>
<LineStart>29</LineStart>
<Snippet>  @Override
  public WebGoatUser loadUserByUsername(String username) throws UsernameNotFoundException {
    WebGoatUser webGoatUser = userRepository.findByUsername(username);
    if (webGoatUser == null) {
      throw new UsernameNotFoundException("User not found");</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D9B373B988ADAC5B6E40344046285849" ruleID="9667C493-BADE-4668-87D9-BF3CCA799FD9">
                            <Category>Log Forging</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>StartWebGoat.java의 printStartUpMessage() 메서드는 확인되지 않은 사용자 입력을 58 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>StartWebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/server/StartWebGoat.java</FilePath>
<LineStart>58</LineStart>
<Snippet>    log.warn(
        "Please browse to " + "{} to start using WebGoat...",
        sslEnabled ? url.replace("http", "https") : url);
  }
}</Snippet>
<TargetFunction>org.slf4j.Logger.warn()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>StartWebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/server/StartWebGoat.java</FilePath>
<LineStart>53</LineStart>
<Snippet>
  private static void printStartUpMessage(ApplicationContext webGoatContext) {
    var url = webGoatContext.getEnvironment().getProperty("webgoat.url");
    var sslEnabled =
        webGoatContext.getEnvironment().getProperty("server.ssl.enabled", Boolean.class);</Snippet>
<TargetFunction>org.springframework.core.env.PropertyResolver.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="43A2013E6BA261DDC14DA079B3946A9B" ruleID="9667C493-BADE-4668-87D9-BF3CCA799FD9">
                            <Category>Log Forging</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 메서드는 확인되지 않은 사용자 입력을 81 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>      Files.writeString(new File(targetDirectory, "secret.txt").toPath(), fileContents, UTF_8);
    } catch (IOException e) {
      log.error("Unable to write 'secret.txt' to '{}", targetDirectory);
    }
  }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>66</LineStart>
<Snippet>
  public BlindSendFileAssignment(
      @Value("${webgoat.user.directory}") String webGoatHomeDirectory, CommentsCache comments) {
    this.webGoatHomeDirectory = webGoatHomeDirectory;
    this.comments = comments;</Snippet>
<TargetFunction>BlindSendFileAssignment(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="07AC5EAEF61786AA76760F0827A25E8B" ruleID="9667C493-BADE-4668-87D9-BF3CCA799FD9">
                            <Category>Log Forging</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SigningAssignment.java의 completed() 메서드는 확인되지 않은 사용자 입력을 81 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>SigningAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>    if (!DatatypeConverter.printHexBinary(rsaPubKey.getModulus().toByteArray())
        .equals(tempModulus.toUpperCase())) {
      log.warn("modulus {} incorrect", modulus);
      return failed(this).feedback("crypto-signing.modulusnotok").build();
    }</Snippet>
<TargetFunction>org.slf4j.Logger.warn()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SigningAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java</FilePath>
<LineStart>70</LineStart>
<Snippet>  @ResponseBody
  public AttackResult completed(
      HttpServletRequest request, @RequestParam String modulus, @RequestParam String signature) {

    String tempModulus =</Snippet>
<TargetFunction>completed(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="EFA8FD4E86469F6B124753A3EE6DA2DD" ruleID="9667C493-BADE-4668-87D9-BF3CCA799FD9">
                            <Category>Log Forging</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 메서드는 확인되지 않은 사용자 입력을 81 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>81</LineStart>
<Snippet>      Files.writeString(new File(targetDirectory, "secret.txt").toPath(), fileContents, UTF_8);
    } catch (IOException e) {
      log.error("Unable to write 'secret.txt' to '{}", targetDirectory);
    }
  }</Snippet>
<TargetFunction>org.slf4j.Logger.error()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebGoat.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      webGoatUser = (WebGoatUser) principal;
    } else if (principal instanceof DefaultOAuth2User) {
      webGoatUser = userRepository.findByUsername(((DefaultOAuth2User) principal).getName());
    }
    return new WebSession(webGoatUser);</Snippet>
<TargetFunction>org.owasp.webgoat.container.users.UserRepository.findByUsername()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>CryptoIntegrationTest.java 줄 38의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>여러 catch 블록은 반복적이지만 Exception 같은 높은 수준의 클래스를 catch하여 catch 블록을 "압축"하면 특수 처리가 필요하거나 프로그램의 이 시점에서 catch되지 않아야 하는 예외 사항을 숨길 수 있습니다. 지나치게 광범위한 예외 사항을 catch하면 Java의 형식화된 예외 사항을 사용하는 의미가 사라지고 특히 프로그램이 커져서 새로운 형식의 예외 사항이 발생하기 시작하면 위험해질 수 있습니다. 새 예외 형식에는 주의를 기울이지 않기 때문입니다.

예제: 다음 발췌된 코드는 세 가지 형식의 예외 사항을 동일한 방식으로 처리합니다.


  try {
    doExchange();
  }
  catch (IOException e) {
    logger.error("doExchange failed", e);
  }
  catch (InvocationTargetException e) {
    logger.error("doExchange failed", e);
  }
  catch (SQLException e) {
    logger.error("doExchange failed", e);
  }


언뜻 보기에 다음과 같이 예외 사항을 하나의 catch 블록으로 처리하는 것이 바람직한 것처럼 보입니다.


  try {
    doExchange();
  }
  catch (Exception e) {
    logger.error("doExchange failed", e);
  }


하지만 doExchange()가 수정되어 다른 방식으로 처리해야 하는 새로운 형식의 예외 사항이 발생하면 광범위한 catch 블록 때문에 컴파일러가 문제를 지적할 수 없습니다. 뿐만 아니라, 새 catch 블록은 ClassCastException 및 NullPointerException과 같이 RuntimeException에서 파생된 예외 사항도 처리하는데 이는 프로그래머의 의도와 반대되는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>아주 높은 수준의 프로그램이나 스레드를 제외하고는 Exception, Throwable, Error 또는 RuntimeException 같은 광범위한 예외 클래스를 catch하지 마십시오.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Secure Coding Rulepacks는 해당 catch 블록이 즉시 새 예외 사항을 발생시키면 overly broad catch 블록에 플래그를 지정하지 않습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="AFDA16C3FA043F2F2CA2D9D39BEB9029" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>DisplayUser.java 줄 48의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DisplayUser.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/DisplayUser.java</FilePath>
<LineStart>48</LineStart>
<Snippet>    try {
      this.userHash = genUserHash(user.getUsername(), user.getPassword(), passwordSalt);
    } catch (Exception ex) {
      this.userHash = "Error generating user hash";
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A6208848E2D0AC4F3DF41B1B94D28E46" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CryptoUtil.java 줄 100의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>100</LineStart>
<Snippet>
      log.info("Verified the signature with result: {}", result);
    } catch (Exception e) {
      log.error("Signature verification failed", e);
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B715A86DFAEDAA66BA877179B3DFB8D2" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CryptoIntegrationTest.java 줄 38의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java</FilePath>
<LineStart>38</LineStart>
<Snippet>    try {
      checkAssignmentSigning();
    } catch (Exception e) {
      e.printStackTrace();
      fail();</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D0A6C074A97BD4940ADC81363A0E60D5" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CryptoUtilTest.java 줄 27의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoUtilTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/cryptography/CryptoUtilTest.java</FilePath>
<LineStart>27</LineStart>
<Snippet>      log.debug("public exponent {}", rsaPubKey.getPublicExponent());
      assertTrue(CryptoUtil.verifyAssignment(modulus, signature, keyPair.getPublic()));
    } catch (Exception e) {
      log.error("signing failed", e);
      ;</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1D170D877C368E3B86D6159A5821701" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>LabelAndHintIntegrationTest.java 줄 170의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LabelAndHintIntegrationTest.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java</FilePath>
<LineStart>170</LineStart>
<Snippet>      // load a properties file
      prop.load(input);
    } catch (Exception e) {
      e.printStackTrace();
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="14E870FA34F47D925E2494961DA57801" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>CryptoUtil.java 줄 71의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>71</LineStart>
<Snippet>
      log.info("signe the signature with result: {}", signature);
    } catch (Exception e) {
      log.error("Signature signing failed", e);
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Often Misused: File Upload</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>ProfileUpload.java의 36 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping("/test")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CABD92AA7667D948A7AA3D73EAE960F7" ruleID="FB974E35-2FF9-4BE6-9E52-11494EA1F186">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>ProfileUploadFix.java의 36 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>ProfileUploadFix.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java</FilePath>
<LineStart>36</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFileFix") MultipartFile file,
      @RequestParam(value = "fullNameFix", required = false) String fullName) {</Snippet>
<TargetFunction>Function: uploadFileHandler()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5AB130F0AF03CCE0DD576276CF785969" ruleID="FB974E35-2FF9-4BE6-9E52-11494EA1F186">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>ProfileUploadRemoveUserInput.java의 34 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>ProfileUploadRemoveUserInput.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java</FilePath>
<LineStart>34</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFileRemoveUserInput") MultipartFile file) {
    return super.execute(file, file.getOriginalFilename());</Snippet>
<TargetFunction>Function: uploadFileHandler()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F56190D3FC447DC50448CEE94BD84535" ruleID="FB974E35-2FF9-4BE6-9E52-11494EA1F186">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>ProfileUpload.java의 36 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>ProfileUpload.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java</FilePath>
<LineStart>36</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(
      @RequestParam("uploadedFile") MultipartFile file,
      @RequestParam(value = "fullName", required = false) String fullName) {</Snippet>
<TargetFunction>Function: uploadFileHandler()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B07509599A3EC94B7B1656D108248E24" ruleID="FB974E35-2FF9-4BE6-9E52-11494EA1F186">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>ProfileZipSlip.java의 60 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>60</LineStart>
<Snippet>
  @SneakyThrows
  private AttackResult processZipUpload(MultipartFile file) {
    var tmpZipDirectory = Files.createTempDirectory(getWebSession().getUserName());
    cleanupAndCreateDirectoryForUser();</Snippet>
<TargetFunction>Function: processZipUpload()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EA7BC98C2530B8674DF42C330C295D20" ruleID="FB974E35-2FF9-4BE6-9E52-11494EA1F186">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>ProfileZipSlip.java의 51 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>51</LineStart>
<Snippet>      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult uploadFileHandler(@RequestParam("uploadedFileZipSlip") MultipartFile file) {
    if (!file.getOriginalFilename().toLowerCase().endsWith(".zip")) {
      return failed(this).feedback("path-traversal-zip-slip.no-zip").build();</Snippet>
<TargetFunction>Function: uploadFileHandler()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Race Condition</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>ace.js의 2776 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>개발자는 Node.js를 사용하여 IO 차단 이벤트에 콜백을 할당할 수 있습니다. 콜백은 비동기로 실행되므로 기본 응용 프로그램이 IO에 의해 차단되지 않기 때문에 이렇게 하면 성능이 개선됩니다. 그러나 콜백 외부의 항목을 실행하려면 콜백 내의 코드가 먼저 실행되어야 하는 경우에는 race condition이 발생할 수 있습니다. 

예제 1: 다음 코드에서는 authentication을 위해 데이터베이스를 기준으로 사용자를 확인합니다.

 
...
var authenticated = true; 
...
database_connect.query('SELECT * FROM users WHERE name == ? AND password = ? LIMIT 1', userNameFromUser, passwordFromUser, function(err, results){
  if (!err &amp;&amp; results.length &gt; 0){
    authenticated = true;
  }else{
    authenticated = false;
  }
});

if (authenticated){
  //do something privileged stuff
  authenticatedActions();
}else{
  sendUnathenticatedMessage();
}


이 예제에서는 로그인용 사용자 자격 증명을 확인하기 위해 백엔드 데이터베이스를 호출하며, 자격 증명이 확인되면 변수를 true로 설정하고 확인되지 않으면 false로 설정합니다. 하지만 콜백은 IO에 의해 차단되므로 비동기로 실행되며 if (authenticated) 확인 후에 실행될 수 있습니다. 기본값은 true이기 때문에 사용자가 실제로 인증되었는지 여부와 관계없이 if 문이 실행됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Node.js 응용 프로그램을 만들 때는 IO 차단 이벤트와 관련 콜백이 수행하는 기능을 철저하게 확인해야 합니다. 일련의 콜백을 특정 순서로 호출해야 할 수도 있고 특정 콜백이 실행되어야 접근 가능한 코드도 있기 때문입니다.

예제 2: 다음 코드는 Example 1의 race condition을 해결합니다.


...
database_connect.query('SELECT * FROM users WHERE name == ? AND password = ? LIMIT 1', userNameFromUser, passwordFromUser, function(err, results){
  if (!err &amp;&amp; results.length &gt; 0){
    // do privileged stuff
    authenticatedActions();
  }else{
    sendUnauthenticatedMessage();
  }
});
...


이 코드는 간단한 예제이며 실제 시나리오는 훨씬 더 복잡할 수 있기 때문에 해당 상황을 해결하려면 코드베이스를 보다 광범위하게 리팩터링해야 할 수도 있습니다. 이러한 문제를 해결할 수 있는 간단한 방법은 promises를 활용하는 API를 사용하는 것입니다. 이러한 API는 비동기 작업의 최종 결과를 나타내며, 성공 시의 콜백과 실패 시의 콜백을 각각 지정할 수 있기 때문입니다. 이 코드를 자주 사용해야 하는 경우에는 authentication에 대해 promise를 반환하는 API를 만드는 것이 좋습니다. 그러면 개발자가 작성해야 하는 코드를 다음과 같이 간소화할 수 있습니다.


promiseAuthentication()
.then(authenticatedActions, sendUnauthenticatedMessage);


이 경우 코드는 항상 명확하게 정의된 순서로 실행되므로 코드를 보다 쉽게 파악하고 race condition을 방지할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="164D7609B14457235788ACCB474E0C90" ruleID="632C0055-B853-4E37-B49F-720C6448B1C7">
                            <Category>Race Condition</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>ace.js의 2776 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>2776</LineStart>
<Snippet>    };
    
    host.on("beforeEndOperation", function() {
        if (host.curOp &amp;&amp; host.curOp.command.name == "insertstring")
            return;</Snippet>
<TargetFunction>FunctionPointerCall: on()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E0E208C322655C5063C2F0EEEB389210" ruleID="13AB60F3-C548-4915-875C-C55AE3AB503F">
                            <Category>Race Condition</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>ace.js의 9957 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>9957</LineStart>
<Snippet>
        this.doc = doc;
        doc.on("change", this.$onChange);

        if (this.bgTokenizer)</Snippet>
<TargetFunction>FunctionPointerCall: on()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8A8DC814346908F307F4BA4CA7200AFA" ruleID="26934CC2-10F4-42D4-AABA-72D9F5EFD23F">
                            <Category>Race Condition</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>ace.js의 2776 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>2776</LineStart>
<Snippet>    };
    
    host.on("beforeEndOperation", function() {
        if (host.curOp &amp;&amp; host.curOp.command.name == "insertstring")
            return;</Snippet>
<TargetFunction>FunctionPointerCall: on()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E88853896836645F036A65503730AD26" ruleID="632C0055-B853-4E37-B49F-720C6448B1C7">
                            <Category>Race Condition</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>ace.js의 21601 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>21601</LineStart>
<Snippet>    if (oldNode) env.textarea = oldNode;
    event.addListener(window, "resize", env.onResize);
    editor.on("destroy", function() {
        event.removeListener(window, "resize", env.onResize);
        env.editor.container.env = null; // prevent memory leak on old ie</Snippet>
<TargetFunction>FunctionPointerCall: on()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E3D1B2DA21BE3F497D29256CEAC914C6" ruleID="632C0055-B853-4E37-B49F-720C6448B1C7">
                            <Category>Race Condition</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>ace.js의 13240 줄에서 on()에 대한 호출은 race condition을 발생시킬 수 있는 콜백을 설정합니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>13240</LineStart>
<Snippet>    
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
    
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);</Snippet>
<TargetFunction>FunctionPointerCall: on()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Denial of Service: StringBuilder</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>SqlInjectionLesson2.java의 줄 71에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>기본 백업 문자 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 사용자 제어 데이터를 추가하면 응용 프로그램이 사용자의 데이터에 맞게 기본 배열의 크기를 조정하는 동안 대량의 힙 메모리를 소비하게 될 수 있습니다. 데이터가 StringBuilder 또는 StringBuffer 인스턴스에 추가되면 인스턴스는 백업 문자 배열에 데이터를 저장할 충분한 여유 공간이 있는지를 확인합니다. 데이터가 맞지 않는 경우 StringBuilder 또는 StringBuffer 인스턴스는 이전 배열 크기의 두 배 이상의 크기로 새 배열을 생성하지만 가비지가 수집되기 전까지 힙에 이전 배열이 남아 있습니다. 공격자는 이 구현 세부 정보를 사용하여 Denial of Service (DoS) 공격을 실행할 수 있습니다.

예제 1: 기본 생성자로 초기화된 StringBuilder 인스턴스에 사용자 제어 데이터가 추가됩니다. 

    ...
    StringBuilder sb = new StringBuilder();
    final String lineSeparator = System.lineSeparator();
    String[] labels = request.getParameterValues("label");
    for (String label : labels) {
        sb.append(label).append(lineSeparator);
    }
    ...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>백업 배열의 크기가 조정되는 횟수를 줄이기 위해 예상되는 추가 데이터 크기의 초기 용량으로 StringBuilder 또는 StringBuffer를 초기화합니다. StringBuilder 또는 StringBuffer 인스턴스에 추가하기 전에 데이터의 크기를 확인하십시오.

예제 2: 초기 용량 생성자로 초기화된 StringBuilder 인스턴스에 사용자 제어 데이터가 추가됩니다. 추가 전에 데이터 길이를 검사하여 초기 StringBuilder 용량이 초과되지 않는지 확인합니다. 이는 백업 배열의 크기 조정을 방지하기 위한 것입니다.

    ...
    private final int BUFFER_CAPACITY = 5200;
    StringBuilder sb = new StringBuilder(BUFFER_CAPACITY);
    ...
    final String lineSeparator = System.lineSeparator();
    String[] labels = request.getParameterValues("label");
    for (String label : labels) {
        if (label.length() + lineSeparator.length() + sb.length() &lt;= sb.capacity()) {
            sb.append(label).append(lineSeparator);
        } else {
            // Handle error
        }
    }
    ...


예제 3: 사용자 제어 데이터는 초기 용량 생성자로 초기화된 StringBuffer 인스턴스에 추가되고 문자열 길이와 데이터 항목 수를 확인하여 StringBuffer에 추가할 수 있는 데이터 양을 제한합니다.

    ...
    private final int MAX_LABEL_LEN = 50;
    private final int MAX_LABEL_ITEMS = 100;
    private final int BUFFER_CAPACITY = 5200;
    StringBuffer sb = new StringBuffer(BUFFER_CAPACITY);
    ...
    final String lineSeparator = System.lineSeparator();
    String[] labels = request.getParameterValues("label");
    if (labels.length &lt;= MAX_LABEL_ITEMS) {
        for (String label : labels) {
            if (label.length() &lt;= MAX_LABEL_LEN) {
                sb.append(label).append(lineSeparator);
            } else {
                // Handle error
            }
        }
    } else {
        // Handle error
    }
    ...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 이 취약점에 권장되는 수정 방법은 감지되지 않을 수 있으므로 수정 후 추가 감사를 수행하여 수정을 확인해야 할 수 있습니다. 취약점이 제거된 것을 확인한 후 문제를 안전하게 억제할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="0A4EEC9AA038747E7040A72F6E3E6054" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson3.java의 줄 70에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>70</LineStart>
<Snippet>        results.first();
        if (results.getString("department").equals("Sales")) {
          output.append("&lt;span class='feedback-positive'&gt;" + query + "&lt;/span&gt;");
          output.append(SqlInjectionLesson8.generateTable(results));
          return success(this).output(output.toString()).build();</Snippet>
<TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson3.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java</FilePath>
<LineStart>53</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack3")
  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="579DBEA7BD16E59C2CDC436F61B7865D" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CrossSiteScriptingLesson5a.java의 줄 76에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CrossSiteScriptingLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson5a.java</FilePath>
<LineStart>76</LineStart>
<Snippet>    StringBuilder cart = new StringBuilder();
    cart.append("Thank you for shopping at WebGoat. &lt;br /&gt;Your support is appreciated&lt;hr /&gt;");
    cart.append("&lt;p&gt;We have charged credit card:" + field1 + "&lt;br /&gt;");
    cart.append("                             ------------------- &lt;br /&gt;");
    cart.append("                               $" + totalSale);</Snippet>
<TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CrossSiteScriptingLesson5a.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson5a.java</FilePath>
<LineStart>60</LineStart>
<Snippet>      @RequestParam Integer QTY3,
      @RequestParam Integer QTY4,
      @RequestParam String field1,
      @RequestParam String field2) {
</Snippet>
<TargetFunction>completed(4)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0AD711CD8FFBE1785BE430F839AF55F1" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson2.java의 줄 71에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java</FilePath>
<LineStart>71</LineStart>
<Snippet>
      if (results.getString("department").equals("Marketing")) {
        output.append("&lt;span class='feedback-positive'&gt;" + query + "&lt;/span&gt;");
        output.append(SqlInjectionLesson8.generateTable(results));
        return success(this).feedback("sql-injection.2.success").output(output.toString()).build();</Snippet>
<TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java</FilePath>
<LineStart>58</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack2")
  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B039F5783386CD6B8400E6FDD4441175" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SqlInjectionLesson4.java의 줄 68에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>68</LineStart>
<Snippet>        // user completes lesson if column phone exists
        if (results.first()) {
          output.append("&lt;span class='feedback-positive'&gt;" + query + "&lt;/span&gt;");
          return success(this).output(output.toString()).build();
        } else {</Snippet>
<TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SqlInjectionLesson4.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java</FilePath>
<LineStart>54</LineStart>
<Snippet>  @PostMapping("/SqlInjection/attack4")
  @ResponseBody
  public AttackResult completed(@RequestParam String query) {
    return injectableQuery(query);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>J2EE Bad Practices: Leftover Debug Code</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MavenWrapperDownloader 클래스에는 디버그 코드가 포함되어 있어서 배포된 웹 응용 프로그램에 예기치 않은 진입점을 만들 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>일반적인 개발 방법은 응용 프로그램으로 발표하거나 배포하지는 않고 디버깅 및 테스트 목적으로만 특별 디자인된 "비밀" 코드를 추가하는 것입니다. 이 비밀 디버그 코드가 실수로 응용 프로그램에 남아 있게 되면 응용 프로그램은 예기치 않은 상호 작용 모드에 노출됩니다. 이 비밀 진입점은 디자인이나 테스트 도중 고려되지 않고 응용 프로그램의 예상 동작 조건 범위를 벗어나기 때문에 보안 위험을 야기합니다.

실수로 남겨둔 디버그 코드의 가장 일반적인 예는 main() 메서드가 웹 응용 프로그램에 나타나는 것입니다. 이는 제품 개발에서는 허용되는 방식이지만 J2EE 운영 응용 프로그램에 속한 클래스는 main()을 정의할 수 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>응용 프로그램의 운영 버전을 배포하기 전에 디버그 코드를 제거해야 합니다. 직접적인 보안 위협의 증명 여부에 관계없이 초기 개발 단계 이후에 응용 프로그램에 디버그 코드가 남아 있을 이유가 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. main() 메서드의 존재는 빙산의 일각일 수 있습니다. main()를 발견하면 개발자가 서둘렀거나 정상적으로 작업을 끝내지 못했음을 나타내는 다른 증거도 찾아 보십시오.

2. J2EE가 아닌 Java 응용 프로그램을 감사하는 경우 J2EE의 부적절한 사례 범주가 사용자 환경에 적용되지 않을 수 있습니다. 이런 경우 Audit Guide를 사용하여 이러한 문제를 억제할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="062583BB66ACD796C365A39658F0200A" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MavenWrapperDownloader 클래스에는 디버그 코드가 포함되어 있어서 배포된 웹 응용 프로그램에 예기치 않은 진입점을 만들 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>48</LineStart>
<Snippet>    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String args[]) {
        System.out.println("- Downloader started");
        File baseDirectory = new File(args[0]);</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5EBDAD36111B7B0623534060C913E0AC" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>StartWebGoat 클래스에는 디버그 코드가 포함되어 있어서 배포된 웹 응용 프로그램에 예기치 않은 진입점을 만들 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>StartWebGoat.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/server/StartWebGoat.java</FilePath>
<LineStart>39</LineStart>
<Snippet>public class StartWebGoat {

  public static void main(String[] args) {
    var parentBuilder =
        new SpringApplicationBuilder()</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F1EB117DAB9A7BB8CE19DB3043615F0C" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MD5 클래스에는 디버그 코드가 포함되어 있어서 배포된 웹 응용 프로그램에 예기치 않은 진입점을 만들 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MD5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java</FilePath>
<LineStart>43</LineStart>
<Snippet>   * @since ostermillerutils 1.00.00
   */
  public static void main(String[] args) {
    if (args.length == 0) {
      System.err.println("Please specify a file.");</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="81EF93870B078B7C5A1DC3819B4FF71F" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>PasswordResetLink 클래스에는 디버그 코드가 포함되어 있어서 배포된 웹 응용 프로그램에 예기치 않은 진입점을 만들 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>PasswordResetLink.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java</FilePath>
<LineStart>33</LineStart>
<Snippet>  }

  public static void main(String[] args) {
    if (args == null || args.length != 2) {
      System.out.println("Need a username and key");</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Key Management: Hardcoded Encryption Key</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>암호화 키를 하드코드하면 모든 프로젝트 개발자가 암호화 키를 볼 수 있고 문제 해결을 극히 어렵게 만들기 때문에 좋은 방법이 아닙니다. 코드가 운영 단계에 들어간 후 암호화 키를 변경하려면 소프트웨어 패치가 필요합니다. 암호화 키로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드 암호화 키를 사용합니다.


...
private static final String encryptionKey = "lakdsljkalkjlksdfkl";
byte[] keyBytes = encryptionKey.getBytes();
SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
Cipher encryptCipher = Cipher.getInstance("AES");
encryptCipher.init(Cipher.ENCRYPT_MODE, key);
...


코드에 액세스할 수 있는 모든 사람이 암호화 키에 액세스할 수 있습니다. 응용 프로그램을 공개한 후에는 프로그램에 패치를 적용하지 않고는 암호화 키를 변경할 방법이 없습니다. 직원이 이 정보에 대한 액세스 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 공격자가 응용 프로그램의 실행 파일에 액세스할 수 있으면 암호화 키 값을 추출할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>암호화 키는 하드코드해서는 안 되며 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호화 키를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호화 키를 읽어 남용할 가능성이 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D9CADB30DCDF344D2C5EEF2ED48688B0" ruleID="7864EF8A-A7EA-4077-AADB-A6D6DFAD3235">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>37</LineStart>
<Snippet>    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
    RSAKeyGenParameterSpec kpgSpec =
        new RSAKeyGenParameterSpec(
            2048, FERMAT_PRIMES[new SecureRandom().nextInt(FERMAT_PRIMES.length)]);
    keyPairGenerator.initialize(kpgSpec);</Snippet>
<TargetFunction>FunctionCall: RSAKeyGenParameterSpec()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C6F708F4093065577641FF2DB387645C" ruleID="6DBD0F5A-99EB-53B7-AB1E-D9B012E68020">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>45</LineStart>
<Snippet>
  public static String getPrivateKeyInPEM(KeyPair keyPair) {
    String encodedString = "-----BEGIN PRIVATE KEY-----\n";
    encodedString =
        encodedString</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="AF31D43A52AA589D1473F35540B488A1" ruleID="8FAE07A6-DBDB-443E-8601-521D3A748B5A">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>goatkeystore.pkcs12</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/goatkeystore.pkcs12</FilePath>
<LineStart>0</LineStart>
<Snippet>0�	�^B^A^C0�	�^F	*낷놑
^A^G^A쟼	�^D�	�0�	�0�^Ee^F	*낷놑</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="10413F7A711C3D8D3149FEAEBA1F96DB" ruleID="6DBD0F5A-99EB-53B7-AB1E-D9B012E68020">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CryptoUtil.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java</FilePath>
<LineStart>133</LineStart>
<Snippet>  public static PrivateKey getPrivateKeyFromPEM(String privateKeyPem)
      throws NoSuchAlgorithmException, InvalidKeySpecException {
    privateKeyPem = privateKeyPem.replace("-----BEGIN PRIVATE KEY-----", "");
    privateKeyPem = privateKeyPem.replace("-----END PRIVATE KEY-----", "");
    privateKeyPem = privateKeyPem.replace("\n", "").replace("\r", "");</Snippet>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Poor Error Handling: Empty Catch Block</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MavenWrapperDownloader.java의 main() 메서드는 71 줄의 예외 사항을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>소프트웨어에 대한 대부분의 심각한 공격은 프로그래머의 가정 위반에서 비롯됩니다. 공격 후, 프로그래머의 가정은 취약하고 근거가 빈약해 보이지만 공격 전에는 많은 프로그래머가 열심히 자신의 가정을 옹호하게 마련입니다.

코드에서 흔히 발견되는 두 가지 의심스런 가정은 "이 메서드 호출은 절대 실패하지 않는다" 및 "이 호출이 실패해도 상관 없다"입니다. 프로그래머가 예외를 무시하는 경우 암시적으로 이 가정 중 하나에 따라 동작하는 것으로 볼 수 있습니다.

예제 1: 다음의 발췌된 코드는 doExchange()에서 아주 드물게 발생하는 예외 사항을 무시합니다.


try {
  doExchange();
}
catch (RareException e) {
  // this can never happen
}


RareException이 발생해도 프로그램은 아무 일도 없었던 것처럼 계속 실행됩니다. 프로그램은 특수한 상황을 나타내는 증거를 전혀 기록하지 않기 때문에 이후에 프로그램의 동작을 밝히려는 노력이 실패할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>최소한 예외 사항이 발생했다는 사실을 기록하여 나중에 다시 검토할 때 예외 사항으로 인한 프로그램 동작을 이해할 수 있도록 해야 합니다. 더 좋은 방법은 현재 작업을 취소하는 것입니다. 호출자가 예외 사항을 올바로 처리할 수 없고 예외 사항이 발생한다는 것을 선언하기 어렵거나 불가능한 상황으로 인해 예외 사항이 무시되는 경우, RuntimeException 또는 Error 발생을 고려해 보십시오. 둘 다 검사하지 않는 예외 사항입니다. JDK 1.4부터 RuntimeException에는 다른 예외 사항을 쉽게 래핑할 수 있는 생성자가 있습니다. 

예제 2: Example 1의 코드는 다음과 같이 다시 작성할 수 있습니다.


try {
  doExchange();
}
catch (RareException e) {
  throw new RuntimeException("This can never happen", e);
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 경우에 따라 무시할 수 있는 드문 유형의 예외 사항이 있습니다. 예를 들면, Thread.sleep()은 InterruptedException을 발생시키고 대부분의 경우 프로그램은 중간에 깨어났는지 여부에 관계없이 동일하게 동작합니다.


  try {
    Thread.sleep(1000);
  }
  catch (InterruptedException e){
    // The thread has been woken up prematurely, but its
    // behavior should be the same either way.
  }
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A80E0F59C92A2CB7CDFBA09AF5AA6DFD" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>SqlInjectionLesson5.java의 createUser() 메서드는 63 줄의 예외 사항을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SqlInjectionLesson5.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java</FilePath>
<LineStart>63</LineStart>
<Snippet>        statement.execute();
      }
    } catch (Exception e) {
      // user already exists continue
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="06CE512A27B4117815DB6C26F7A558CF" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MavenWrapperDownloader.java의 main() 메서드는 71 줄의 예외 사항을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>71</LineStart>
<Snippet>                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="39AD21A3C857E28F26BC1507671B55C3" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ResetLinkAssignmentForgotPassword.java의 fakeClickingLinkEmail() 메서드는 113 줄의 예외 사항을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ResetLinkAssignmentForgotPassword.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentForgotPassword.java</FilePath>
<LineStart>113</LineStart>
<Snippet>              httpEntity,
              Void.class);
    } catch (Exception e) {
      // don't care
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="23BA3FDF0D60EE3704CE2D01331AFA76" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>JWTToken.java의 encode() 메서드는 94 줄의 예외 사항을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JWTToken.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/jwt/JWTToken.java</FilePath>
<LineStart>94</LineStart>
<Snippet>        builder.encoded(jws.getCompactSerialization());
        builder.signatureValid(true);
      } catch (JoseException e) {
        // Do nothing
      }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Unchecked Return Value</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Salaries.java의 copyFiles() 메서드는 62 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + "/" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + "/" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead &lt; 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException("file is unusually small");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. "그런 일은 절대 일어날 수 없습니다. 왜냐하면..."이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="14CE8995663BEEDCC400596D6B5F8C0B" ruleID="ED57A0C1-5039-43E7-B753-28128F786E8B">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Salaries.java의 copyFiles() 메서드는 62 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Salaries.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java</FilePath>
<LineStart>62</LineStart>
<Snippet>    File targetDirectory = new File(webGoatHomeDirectory, "/ClientSideFiltering");
    if (!targetDirectory.exists()) {
      targetDirectory.mkdir();
    }
    try {</Snippet>
<TargetFunction>mkdir()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="27A0F6A72F0135FA7E8D05D271796843" ruleID="ED57A0C1-5039-43E7-B753-28128F786E8B">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 메서드는 76 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>76</LineStart>
<Snippet>    File targetDirectory = new File(webGoatHomeDirectory, "/XXE/" + user.getUsername());
    if (!targetDirectory.exists()) {
      targetDirectory.mkdirs();
    }
    try {</Snippet>
<TargetFunction>mkdirs()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6441B8225E05FBC6365476E6D2469593" ruleID="ED57A0C1-5039-43E7-B753-28128F786E8B">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>ProfileUploadRetrieval.java의 ProfileUploadRetrieval() 메서드는 48 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProfileUploadRetrieval.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java</FilePath>
<LineStart>48</LineStart>
<Snippet>  public ProfileUploadRetrieval(@Value("${webgoat.server.directory}") String webGoatHomeDirectory) {
    this.catPicturesDirectory = new File(webGoatHomeDirectory, "/PathTraversal/" + "/cats");
    this.catPicturesDirectory.mkdirs();
  }
</Snippet>
<TargetFunction>mkdirs()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="77731CD542415C4CB21FC0AD230752BF" ruleID="ED57A0C1-5039-43E7-B753-28128F786E8B">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>MvcConfiguration.java의 createDirectory() 메서드는 72 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MvcConfiguration.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java</FilePath>
<LineStart>72</LineStart>
<Snippet>    File file = new File(fileLocation);
    if (!file.exists()) {
      file.mkdirs();
    }
  }</Snippet>
<TargetFunction>mkdirs()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Bad Practices: JVM Termination</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MavenWrapperDownloader.java의 89 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>웹 응용 프로그램을 통해 응용 프로그램 컨테이너를 종료하려 하는 것은 좋은 방법이 아닙니다. 종료 메서드 호출은 제거되지 않은 leftover debug code의 일부분이거나 Non-J2EE 응용 프로그램에서 가져온 코드일 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>웹 응용 프로그램 내에서 종료 메서드를 호출하지 마십시오. J2EE 응용 프로그램에 그와 같은 메서드 호출이 있으면 소프트웨어 상태가 불량해지므로 제거하는 것이 좋습니다. 인식 가능한 위험성 존재 여부를 떠나 그런 코드를 응용 프로그램에 남겨둘 합당한 이유를 찾기가 어렵습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. J2EE 응용 프로그램에 exit() 또는 halt() 호출이 있으면 다른 문제가 나타날 수 있습니다. exit() 또는 halt() 호출을 발견하면 개발자가 성급했거나 Non-J2EE 코드의 상당 부분이 보안 또는 품질 문제를 고려하지 않고 응용 프로그램에 도입되었다는 다른 증거도 찾아야 합니다.

2. J2EE가 아닌 Java 응용 프로그램을 감사하는 경우 J2EE의 부적절한 사례 범주가 사용자 환경에 적용되지 않을 수 있습니다. 이런 경우 Audit Guide를 사용하여 이러한 문제를 억제할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="FD1EDFF91BC971672F2619B9711638B7" ruleID="9D479AB5-B986-492C-B1F0-C11F2FD623F7">
                            <Category>J2EE Bad Practices: JVM Termination</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>MavenWrapperDownloader.java의 93 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>93</LineStart>
<Snippet>            System.out.println("- Error downloading");
            e.printStackTrace();
            System.exit(1);
        }
    }</Snippet>
<TargetFunction>exit()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6434CC262765E1D95877D4B5BBB103D7" ruleID="9D479AB5-B986-492C-B1F0-C11F2FD623F7">
                            <Category>J2EE Bad Practices: JVM Termination</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>MavenWrapperDownloader.java의 89 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MavenWrapperDownloader.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/.mvn/wrapper/MavenWrapperDownloader.java</FilePath>
<LineStart>89</LineStart>
<Snippet>            downloadFileFromURL(url, outputFile);
            System.out.println("Done");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println("- Error downloading");</Snippet>
<TargetFunction>exit()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3B5E1A4BB33F797EF5F471F33309B061" ruleID="9D479AB5-B986-492C-B1F0-C11F2FD623F7">
                            <Category>J2EE Bad Practices: JVM Termination</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>PasswordResetLink.java의 36 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>PasswordResetLink.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java</FilePath>
<LineStart>36</LineStart>
<Snippet>    if (args == null || args.length != 2) {
      System.out.println("Need a username and key");
      System.exit(1);
    }
    String username = args[0];</Snippet>
<TargetFunction>exit()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Log Forging (debug)</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>AsciiDoctorTemplateResolver.java의 determineLanguage() 메서드는 확인되지 않은 사용자 입력을 164 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Log forging 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스에서 데이터가 응용 프로그램에 입력됩니다.

2. 응용 프로그램 또는 시스템 로그 파일에 데이터가 작성됩니다.

응용 프로그램은 일반적으로 차후 검토, 통계 수집 또는 디버깅을 위해 로그 파일을 사용하여 이벤트나 트랙잭션의 기록을 저장합니다. 로그 파일 검토 작업은 응용 프로그램의 성격에 따라 필요할 때 수동으로 수행할 수도 있고 자동으로 중요한 이벤트나 추세 정보의 로그를 발췌하는 도구를 사용하여 자동으로 수행할 수도 있습니다.

공격자가 응용 프로그램에 데이터를 공급하고 이후에 문자 그대로 응용 프로그램에 대한 로그가 작성되면 로그 파일 해석이 방해를 받거나 잘못될 수 있습니다. 가장 가벼운 공격은 공격자가 응용 프로그램에 해당 문자가 포함된 입력을 제공하는 방식으로 로그 파일에 가짜 항목을 삽입하는 것입니다. 로그 파일을 자동으로 처리하는 경우 공격자는 파일의 형식을 손상시키거나 잘못된 문자를 삽입하여 파일을 사용할 수 없게 만들 수 있습니다. 보다 효과적인 공격은 로그 파일 통계를 왜곡하는 것입니다. 왜곡 또는 다른 방식으로 손상된 로그 파일을 사용하여 공격자의 공격 루트를 은폐하거나 심지어 악의적인 행위에 제 3자를 끌어들일 수도 있습니다[1]. 최악의 경우는 공격자가 코드나 다른 명령을 로그 파일에 삽입하고 로그 처리 유틸리티의 취약점을 이용하는 것입니다[2].

예제 1: 다음 웹 응용 프로그램 코드는 요청 개체에서 정수 값을 읽으려고 합니다. 값을 정수로 구문 분석할 수 없으면 문제점을 나타내는 오류 메시지와 함께 입력을 기록합니다.


...
        String val = request.getParameter("val");
        try {
                int value = Integer.parseInt(val);
        }
        catch (NumberFormatException nfe) {
                log.info("Failed to parse val = " + val);
        }
...


사용자가 val에 문자열 "twenty-one"을 전송하면 다음 항목이 기록됩니다.


INFO: Failed to parse val=twenty-one


그러나, 공격자가 "twenty-one%0a%0aINFO:+User+logged+out%3dbadguy" 문자열을 전송하는 경우 다음 항목이 기록됩니다.


INFO: Failed to parse val=twenty-one

INFO: User logged out=badguy


공격자가 같은 메커니즘을 사용하여 임의의 로그 항목을 삽입할 수 있다는 것은 말할 필요도 없습니다.

모바일 환경에서는 Log forging과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 2: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String val = this.getIntent().getExtras().getString("val");
        try {
                int value = Integer.parseInt();
        }
        catch (NumberFormatException nfe) {
                Log.e(TAG, "Failed to parse val = " + val);
        }
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>간접 참조로 log forging 공격을 예방하십시오. 기록해야 하는 각 이벤트에 해당하는 올바른 로그 항목 집합을 만들어 이 집합의 항목만 기록합니다. 사용자의 시스템 로그아웃과 같은 동적 콘텐트를 캡처하려면 항상 사용자가 제공하는 데이터가 아닌 서버에서 제어하는 값을 사용하십시오. 이렇게 하면 사용자가 제공하는 입력은 로그 항목에 직접 사용되지 않습니다.

다음과 같이 NumberFormatException에 해당하는 사전 정의된 로그 항목을 사용하도록 예제 1을 다시 작성할 수 있습니다.


...
        public static final String NFE = "Failed to parse val. The input is required to be an integer value."
...
        String val = request.getParameter("val");
        try {
                int value = Integer.parseInt(val);
        }
        catch (NumberFormatException nfe) {
                log.info(NFE);
        }
..


Android에 해당하는 코드는 다음과 같습니다.


...
        public static final String NFE = "Failed to parse val. The input is required to be an integer value."
...
        String val = this.getIntent().getExtras().getString("val");
        try {
                int value = Integer.parseInt();
        }
        catch (NumberFormatException nfe) {
                Log.e(TAG, NFE);
        }
...


경우에 따라 올바른 로그 항목 집합이 너무 크거나 복잡하기 때문에 이 접근 방식은 실용적이지 못합니다. 이런 상황에서 개발자는 흔히 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자 목록은 금방 불완전해지거나 최신 상태를 유지하기 어렵습니다. 효율적인 접근 방식은 로그 항목에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다. 대부분의 log forging 공격에서 핵심이 되는 문자는 '\n'(줄 바꿈) 문자로 이 문자는 로그 항목 허용 목록에 포함해서는 안 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 많은 로깅 작업이 개발 및 테스트 도중 프로그램 디버깅의 목적을 위해서만 만들어집니다. 경험에 따르면 우연이든, 의도적이든 운영 과정에서 디버깅을 사용하게 됩니다. 단지 프로그래머가 "운영에 디버깅을 사용할 계획이 없다"고 말한다고 해서 log forging 취약점을 간과해서는 안 됩니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="F7D27DF67F95A70DD1CCB545112EA80D" ruleID="61D4418B-F788-4C54-BFE4-D05E4769E29B">
                            <Category>Log Forging (debug)</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Ping.java의 logRequest() 메서드는 확인되지 않은 사용자 입력을 51 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>51</LineStart>
<Snippet>      @RequestHeader("User-Agent") String userAgent, @RequestParam(required = false) String text) {
    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);
    File logFile = new File(webGoatHomeDirectory, "/XXE/log" + webSession.getUserName() + ".txt");
    try {</Snippet>
<TargetFunction>org.slf4j.Logger.debug()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>49</LineStart>
<Snippet>  @ResponseBody
  public String logRequest(
      @RequestHeader("User-Agent") String userAgent, @RequestParam(required = false) String text) {
    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);</Snippet>
<TargetFunction>logRequest(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3ECCA250760EEB5C9D9D9BCAD47F0287" ruleID="61D4418B-F788-4C54-BFE4-D05E4769E29B">
                            <Category>Log Forging (debug)</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>AsciiDoctorTemplateResolver.java의 determineLanguage() 메서드는 확인되지 않은 사용자 입력을 164 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AsciiDoctorTemplateResolver.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java</FilePath>
<LineStart>164</LineStart>
<Snippet>      String langHeader = request.getHeader(Headers.ACCEPT_LANGUAGE_STRING);
      if (null != langHeader) {
        log.debug("browser locale {}", langHeader);
        return langHeader.substring(0, 2);
      } else {</Snippet>
<TargetFunction>org.slf4j.Logger.debug()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>AsciiDoctorTemplateResolver.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java</FilePath>
<LineStart>162</LineStart>
<Snippet>      return browserLocale.getLanguage();
    } else {
      String langHeader = request.getHeader(Headers.ACCEPT_LANGUAGE_STRING);
      if (null != langHeader) {
        log.debug("browser locale {}", langHeader);</Snippet>
<TargetFunction>jakarta.servlet.http.HttpServletRequest.getHeader()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BDEFF485531500730E06696FC81D0FF0" ruleID="61D4418B-F788-4C54-BFE4-D05E4769E29B">
                            <Category>Log Forging (debug)</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Ping.java의 logRequest() 메서드는 확인되지 않은 사용자 입력을 51 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>51</LineStart>
<Snippet>      @RequestHeader("User-Agent") String userAgent, @RequestParam(required = false) String text) {
    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);
    File logFile = new File(webGoatHomeDirectory, "/XXE/log" + webSession.getUserName() + ".txt");
    try {</Snippet>
<TargetFunction>org.slf4j.Logger.debug()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>Ping.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java</FilePath>
<LineStart>49</LineStart>
<Snippet>  @ResponseBody
  public String logRequest(
      @RequestHeader("User-Agent") String userAgent, @RequestParam(required = false) String text) {
    String logLine = String.format("%s %s %s", "GET", userAgent, text);
    log.debug(logLine);</Snippet>
<TargetFunction>logRequest(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>XML Entity Expansion Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>CommentsCache.java:105에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XML Bombs라고 하는 XML Entity Expansion injection은 서버의 할당된 리소스를 모두 소모할 때까지 기하급수적으로 확장되는 올바른 형식의 유효한 XML 블록을 이용하는 DoS(Denial of Service) 공격입니다. XML을 사용하면 문자열 대체 매크로로 작동하는 사용자 지정 엔터티를 정의할 수 있습니다. 되풀이되는 엔터티 확인을 중첩시켜 공격자가 서버 리소스를 쉽게 중단시킬 수 있습니다.

다음 XML 문서에서는 XML 폭탄의 예를 보여 줍니다.

&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
  &lt;!ENTITY lol "lol"&gt;
  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;
  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;
  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;
  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;
  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;
  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;


이 테스트는 작은 XML 문서를 메모리에서 3GB 이상으로 확장시켜 서버를 중단시킬 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XML 파서가 들어오는 XML 문서의 일부로 DTD(Document Type Definition) 사용자 지정 엔터티를 허용하지 않도록 안전하게 구성되어야 합니다.

XML 엔터티 확장 injection을 방지하려면 XML 팩토리, 파서 또는 판독기에 대해 "secure-processing" 속성을 설정해야 합니다.

factory.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true);


JAXP 1.3 이전 버전에서는 보안 처리 기능이 켜져 있는 경우 DOM 및 SAX 파서에 대해 기본 제한이 설정됩니다. 이 제한은 다음과 같습니다.

entityExpansionLimit = 64,000
elementAttributeLimit = 10,000

JAXP 1.4부터는 보안 처리 기능이 기본적으로 켜집니다. 위의 제한과 더불어 검증 파서에 새로운 maxOccur 제한이 추가되었습니다. 이 제한은 다음과 같습니다.

maxOccur = 5,000


인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
&#13;

StAX 파서의 경우 다음 구성이 권장됩니다.
- 엔터티 참조 확인 비활성화:

xmlInputFactory.setProperty("javax.xml.stream.isReplacingEntityReferences", false);


- 인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

xmlInputFactory.setProperty("javax.xml.stream.supportDTD", false);


- 외부 또는 로컬 엔터티 확인이 필요한 경우 안전한 리졸버(resolver)를 구축하고 XML 문서를 구문 분석하기 전에 설정합니다.

xmlInputFactory.setXMLResolver(mySafeResolver);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="1578BFF7F8BCB34E977AB2C50C85E962" ruleID="6A059AF5-3228-448E-8BD8-469EAAC6C44E">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CommentsCache.java:105에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>CommentsCache.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java</FilePath>
<LineStart>105</LineStart>
<Snippet>    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();</Snippet>
<TargetFunction>javax.xml.stream.XMLInputFactory.createXMLStreamReader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ContentTypeAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  public AttackResult createNewUser(
      HttpServletRequest request,
      @RequestBody String commentStr,
      @RequestHeader("Content-Type") String contentType) {
    AttackResult attackResult = failed(this).build();</Snippet>
<TargetFunction>createNewUser(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E20AAD6B15A5EECE50536DCE8059DA53" ruleID="6A059AF5-3228-448E-8BD8-469EAAC6C44E">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CommentsCache.java:105에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>CommentsCache.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java</FilePath>
<LineStart>105</LineStart>
<Snippet>    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();</Snippet>
<TargetFunction>javax.xml.stream.XMLInputFactory.createXMLStreamReader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>87</LineStart>
<Snippet>  @PostMapping(path = "xxe/blind", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult addComment(@RequestBody String commentStr) {
    var fileContentsForUser = userToFileContents.getOrDefault(getWebSession().getUser(), "");
</Snippet>
<TargetFunction>addComment(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="259298196DE6BDF97968F3FDF983E7D5" ruleID="6A059AF5-3228-448E-8BD8-469EAAC6C44E">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CommentsCache.java:105에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>CommentsCache.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java</FilePath>
<LineStart>105</LineStart>
<Snippet>    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();</Snippet>
<TargetFunction>javax.xml.stream.XMLInputFactory.createXMLStreamReader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SimpleXXE.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java</FilePath>
<LineStart>73</LineStart>
<Snippet>  @PostMapping(path = "xxe/simple", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
    String error = "";
    try {</Snippet>
<TargetFunction>createNewComment(1)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>XML External Entity Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>CommentsCache.java:105에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XML 외부 엔터티 공격에서는 XML 기능을 활용하여 처리 시점에 동적으로 문서를 구성합니다. XML 엔터티를 사용하면 지정된 리소스에서 동적으로 데이터를 포함시킬 수 있습니다. 외부 엔터티를 사용하면 XML 문서에 외부 URI의 데이터를 포함할 수 있습니다. 다른 방식으로 처리하도록 구성하지 않은 경우 외부 엔터티는 XML 파서가 URI로 지정된 리소스(예: 로컬 컴퓨터 또는 원격 시스템의 파일)를 접근하게 만듭니다. 이 동작으로 인해 응용 프로그램이 XML 외부 엔터티(XXE) 공격에 노출되고, 이를 통해 로컬 시스템에서 denial of service를 발생시키고, 로컬 컴퓨터의 파일에 무단으로 접근하고, 원격 컴퓨터를 스캔하고, 원격 시스템에서 denial of service를 발생시킬 수 있습니다.

다음 XML 문서에서는 XXE 공격의 예를 보여 줍니다.

&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
 &lt;!DOCTYPE foo [
  &lt;!ELEMENT foo ANY &gt;
  &lt;!ENTITY xxe SYSTEM "file:///dev/random" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;


이 예제에서 XML 파서가 엔터티를 /dev/random 파일의 컨텐츠로 대체하려고 시도하는 경우 서버가 중단될 수 있습니다(UNIX 시스템의 경우).</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XML unmarshaller가 수신 XML 문서의 일부로 외부 엔터티를 허용하지 않도록 안전하게 구성되어야 합니다.

XXE injection을 방지하려면 XML 소스를 java.io.File, java.io.Reader 또는 java.io.InputStream으로 직접 처리하는 unmarshal 메서드를 사용하지 마십시오. 안전하게 구성된 파서로 문서를 구문 분석하고 다음 예에 표시된 것처럼 보안 파서를 XML 소스를 사용하는 unmarshal 메서드를 사용합니다.


DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(&lt;XML Source&gt;);
Model model = (Model) u.unmarshal(document);
&#13;

StAX 파서의 경우 다음 구성이 권장됩니다.
- 외부 엔터티 확인 비활성화:

xmlInputFactory.setProperty("javax.xml.stream.isSupportingExternalEntities", false);


- 인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

xmlInputFactory.setProperty("javax.xml.stream.supportDTD", false);


- 외부 또는 로컬 엔터티 확인이 필요한 경우 안전한 리졸버(resolver)를 구축하고 XML 문서를 구문 분석하기 전에 설정합니다.

xmlInputFactory.setXMLResolver(mySafeResolver);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B2AE50CC082819416C515C867C0A2979" ruleID="D92D11B4-E03C-4B93-9DAA-402C19BE7EFC">
                            <Category>XML External Entity Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CommentsCache.java:105에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CommentsCache.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java</FilePath>
<LineStart>105</LineStart>
<Snippet>    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();</Snippet>
<TargetFunction>javax.xml.stream.XMLInputFactory.createXMLStreamReader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SimpleXXE.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java</FilePath>
<LineStart>73</LineStart>
<Snippet>  @PostMapping(path = "xxe/simple", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
    String error = "";
    try {</Snippet>
<TargetFunction>createNewComment(1)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="97C24C250C1B52E78F35CB2CCDFB3BDE" ruleID="D92D11B4-E03C-4B93-9DAA-402C19BE7EFC">
                            <Category>XML External Entity Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CommentsCache.java:105에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CommentsCache.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java</FilePath>
<LineStart>105</LineStart>
<Snippet>    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();</Snippet>
<TargetFunction>javax.xml.stream.XMLInputFactory.createXMLStreamReader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>BlindSendFileAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java</FilePath>
<LineStart>87</LineStart>
<Snippet>  @PostMapping(path = "xxe/blind", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public AttackResult addComment(@RequestBody String commentStr) {
    var fileContentsForUser = userToFileContents.getOrDefault(getWebSession().getUser(), "");
</Snippet>
<TargetFunction>addComment(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0A2051480F7728E46FF699494826E1B1" ruleID="D92D11B4-E03C-4B93-9DAA-402C19BE7EFC">
                            <Category>XML External Entity Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>CommentsCache.java:105에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CommentsCache.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java</FilePath>
<LineStart>105</LineStart>
<Snippet>    }

    var xsr = xif.createXMLStreamReader(new StringReader(xml));

    var unmarshaller = jc.createUnmarshaller();</Snippet>
<TargetFunction>javax.xml.stream.XMLInputFactory.createXMLStreamReader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ContentTypeAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java</FilePath>
<LineStart>62</LineStart>
<Snippet>  public AttackResult createNewUser(
      HttpServletRequest request,
      @RequestBody String commentStr,
      @RequestHeader("Content-Type") String contentType) {
    AttackResult attackResult = failed(this).build();</Snippet>
<TargetFunction>createNewUser(1)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MissingFunctionACUsers.java의 usersService() 메서드가 77 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;%= name %&gt;



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 "방명록"을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


&lt;% String eid = request.getParameter("eid"); %&gt;
...
Employee ID: &lt;%= eid %&gt;



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- "&lt;"는 태그가 시작되는 표시이기 때문에 특수합니다.

- "&amp;"는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "&gt;"는 일부 브라우저에서 페이지 작성자가 여는 "&lt;"를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- "&amp;"는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- "&amp;"는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- "%" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, "%"는 "%68%65%6C%6C%6F"와 같은 입력이 웹 페이지에 나타날 때 "hello"가 되는 경우 필터링해야 합니다.


&lt;SCRIPT&gt; &lt;/SCRIPT&gt;의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표(")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 "&lt;"가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저(특히 Internet Explorer 6 및 7 그 외 다른 브라우저들)는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 룰팩은 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값으로 Fortify는 Cross-Site Scripting, Poor Validation 취약점을 보고할 수 있습니다.

3. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="4CC0DB7730948834E7569DC29E7B48A6" ruleID="B15BA48C-C3A9-42C0-928D-B555CD29BFAD0">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>MissingFunctionACUsers.java의 usersService() 메서드가 77 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>MissingFunctionACUsers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java</FilePath>
<LineStart>77</LineStart>
<Snippet>        userRepository.findAllUsers().stream()
            .map(user -&gt; new DisplayUser(user, PASSWORD_SALT_SIMPLE))
            .collect(Collectors.toList()));
  }
</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.ok()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MissingAccessControlUserRepository.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java</FilePath>
<LineStart>24</LineStart>
<Snippet>
  public List&lt;User&gt; findAllUsers() {
    return jdbcTemplate.query("select username, password, admin from access_control_users", mapper);
  }
</Snippet>
<TargetFunction>org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="DDC5B124AE0BD076C62BC562F3E12F28" ruleID="B15BA48C-C3A9-42C0-928D-B555CD29BFAD0">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>MissingFunctionACUsers.java의 usersFixed() 메서드가 90 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>MissingFunctionACUsers.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java</FilePath>
<LineStart>90</LineStart>
<Snippet>          userRepository.findAllUsers().stream()
              .map(user -&gt; new DisplayUser(user, PASSWORD_SALT_ADMIN))
              .collect(Collectors.toList()));
    }
    return ResponseEntity.status(HttpStatus.FORBIDDEN).build();</Snippet>
<TargetFunction>org.springframework.http.ResponseEntity.ok()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MissingAccessControlUserRepository.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java</FilePath>
<LineStart>24</LineStart>
<Snippet>
  public List&lt;User&gt; findAllUsers() {
    return jdbcTemplate.query("select username, password, admin from access_control_users", mapper);
  }
</Snippet>
<TargetFunction>org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cross-Site Scripting: Self</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>clientSideFiltering.js의 ajaxFunction() 메서드가 17 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XSS(Cross-Site Scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. 자체 XSS의 경우에는 텍스트 상자나 DOM에서 제어할 수 있는 기타 값에서 데이터를 읽어들인 다음 클라이언트 측 코드를 사용하여 페이지에 데이터를 다시 작성합니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다. 자체 XSS의 경우 악성 콘텐트가 DOM(Document Object Model) 수정의 일부로 실행됩니다.

자체 XSS의 경우 악성 콘텐트는 JavaScript 세그먼트 형식이거나 브라우저에서 실행되는 기타 코드 유형입니다. 자체 XSS는 기본적으로 자기 자신에 대한 공격이므로 중요하지 않은 것으로 간주되는 경우가 많습니다. 하지만 다음 상황 중 하나가 발생할 수 있는 경우에는 표준 XSS 취약점과 동일하게 취급해야 합니다. 

- 웹 사이트에서 Cross-Site Request Forgery 취약점이 식별되는 경우
- 소셜 엔지니어링 공격으로 인해 사용자가 자신의 계정을 직접 공격하여 세션 보안을 침해할 수 있는 경우


예제 1: 다음의 HTML 형식을 고려해 보십시오.


&lt;div id="myDiv"&gt;
  Employee ID: &lt;input type="text" id="eid"&gt;&lt;br&gt;
  ...
  &lt;button&gt;Show results&lt;/button&gt;
&lt;/div&gt;
&lt;div id="resultsDiv"&gt;
  ...
&lt;/div&gt;


다음 jQuery 코드 세그먼트는 텍스트 상자에서 직원 ID를 읽고 사용자에게 표시합니다.


$(document).ready(function(){
  $("#myDiv").on("click", "button", function(){
    var eid = $("#eid").val();
    $("resultsDiv").append(eid);
    ...
  });
});


이러한 코드 예제는 ID가 eid인 텍스트 입력에서 직원 ID에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우에는 사용자가 버튼을 클릭하고 나면 브라우저가 실행하도록 코드가 DOM에 추가됩니다. 사용자가 텍스트 입력에 악성 콘텐트를 입력하도록 공격자가 유도할 수 있다면 해당 XSS는 DOM-based XSS에 불과합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전이나 렌더링되기 직전(DOM-based의 경우) 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- "&lt;"는 태그가 시작되는 표시이기 때문에 특수합니다.

- "&amp;"는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "&gt;"는 일부 브라우저에서 페이지 작성자가 여는 "&lt;"를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- "&amp;"는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다.

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- "&amp;"는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- "%" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, "%"는 "%68%65%6C%6C%6F"와 같은 입력이 웹 페이지에 나타날 때 "hello"가 되는 경우 필터링해야 합니다.


&lt;SCRIPT&gt; &lt;/SCRIPT&gt; 본문:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표(")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다.

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 '&lt;'가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CA1DD33F43145291A714FE245733B0CA" ruleID="810167D4-74D7-4579-8122-222913D6FAE50">
                            <Category>Cross-Site Scripting: Self</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>clientSideFiltering.js의 ajaxFunction() 메서드가 17 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>17</LineStart>
<Snippet>
function ajaxFunction(userId) {
    $.get("clientSideFiltering/salaries?userId=" + userId, function (result, status) {
        var html = "&lt;table border = '1' width = '90%' align = 'center'";
        html = html + '&lt;tr&gt;';</Snippet>
<TargetFunction>~JS_Generic.get()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>clientSideFiltering.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js</FilePath>
<LineStart>12</LineStart>
<Snippet>    if (!dataFetched) {
        dataFetched = true;
        ajaxFunction(document.getElementById("userID").value);
    }
}</Snippet>
<TargetFunction>Read value()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="11BC029AB8F16560B25048F80509F478" ruleID="810167D4-74D7-4579-8122-222913D6FAE50">
                            <Category>Cross-Site Scripting: Self</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>clientSideFilteringFree.js의 lambda() 메서드가 41 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>clientSideFilteringFree.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js</FilePath>
<LineStart>41</LineStart>
<Snippet>    $(".checkoutCode").on("blur", function () {
        var checkoutCode = $(".checkoutCode").val();
        $.get("clientSideFiltering/challenge-store/coupons/" + checkoutCode, function (result, status) {
            var discount = result.discount;
            if (discount &gt; 0) {</Snippet>
<TargetFunction>~JS_Generic.get()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>clientSideFilteringFree.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js</FilePath>
<LineStart>40</LineStart>
<Snippet>    })
    $(".checkoutCode").on("blur", function () {
        var checkoutCode = $(".checkoutCode").val();
        $.get("clientSideFiltering/challenge-store/coupons/" + checkoutCode, function (result, status) {
            var discount = result.discount;</Snippet>
<TargetFunction>~JS_Generic.val()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Password Management: Password in Configuration File</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>일반 텍스트 암호를 구성 파일에 저장하면 파일을 읽을 수 있는 사용자는 누구나 암호로 보호되는 리소스 접근이 허용됩니다. 때때로 개발자가 구성에 대한 접근 권한이 있는 사람에게서 응용 프로그램을 방어할 수 없다고 생각하는 경우가 있는데 이런 태도가 공격자에게 유리하게 작용합니다. 좋은 암호 관리 지침에 따르면 암호를 일반 텍스트로 저장하지 않아야 합니다.

</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>암호를 일반 텍스트로 저장해서는 안 됩니다. 시스템이 시작될 때 관리자에게 암호를 입력하도록 요구해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다.

일부 타사 제품에 보다 안전한 방법으로 암호를 관리하는 기능이 있다고 합니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 보안 솔루션의 경우 현실성 있는 유일한 옵션은 독점적 솔루션을 사용하는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer는 구성 파일에서 암호 속성에 사용되는 일반 이름을 검색합니다. 플래그가 지정된 항목이 암호로 사용되고 있고 암호 항목에 일반 텍스트가 포함되어 있는지 확인하여 이러한 문제를 감사하십시오.

2. 구성 파일의 항목이 기본 암호인 경우 이를 변경해야 할 뿐 아니라 구성 파일에서 난독 처리해야 합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="668C351ACC6D2190863E12F66A0CB9CA" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>messages.properties</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/i18n/messages.properties</FilePath>
<LineStart>34</LineStart>
<Snippet>InvalidData=Invalid Data
Go!=Go!
password=Password
password.confirm=Confirm password
username=Username</Snippet>
<TargetFunction>password()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6C0BF3EFA43501984AF71CA8F5754428" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>messages.properties</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/i18n/messages.properties</FilePath>
<LineStart>43</LineStart>
<Snippet>accounts.table.account=Account
accounts.table.user=User
accounts.table.password=Password
logout=Logout
version=Version</Snippet>
<TargetFunction>accounts.table.password()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Password Management: Weak Cryptography</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>암호 관리 이슈는 암호를 응용 프로그램의 속성 또는 구성 파일에 일반 텍스트로 저장할 때 발생합니다. 프로그래머는 base64 인코딩과 같은 인코딩 함수로 암호를 숨겨 암호 관리 문제를 해결하려고 하지만 이런 노력으로는 암호를 제대로 보호할 수 없습니다.

예제 1: 다음 코드는 속성 파일에서 암호를 읽고 이 암호를 사용하여 데이터베이스에 연결합니다.


...
Properties prop = new Properties();
prop.load(new FileInputStream("config.properties"));
String password = Base64.decode(prop.getProperty("password"));

DriverManager.getConnection(url, usr, password);
...


이 코드는 올바로 실행되지만 config.properties에 액세스할 수 있는 모든 사용자는 password의 값을 읽고 base64로 인코딩된 값임을 쉽게 알 수 있습니다. 비양심적인 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.

예제 2: 다음 코드는 Android WebView 저장소에서 사용자 이름과 암호를 읽은 다음 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
        String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
        String username = new String(Base64.decode(credentials[0], DEFAULT));
        String password = new String(Base64.decode(credentials[1], DEFAULT));
        handler.proceed(username, password);
  }
});
...


WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 루팅된 장치가 있거나 에뮬레이터를 사용하는 모든 사용자는 저장된 암호를 읽을 수 있습니다.

예제 3: 다음 코드는 MD5 해시 함수를 사용하여 암호를 인코딩하도록 Spring Security로 보호된 응용 프로그램을 구성합니다.

@Bean
public PasswordEncoder passwordEncoder() {
    return new MD5PasswordEncoder();
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>암호를 일반 텍스트로 저장하지 마십시오. 암호는 시스템이 시작될 때 관리자가 입력해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 보다 안전하게 암호를 관리할 수 있다고 주장하지만 이러한 기능에 대해서는 회의적입니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리합니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다.
 
Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 투명한 256비트 AES 데이터베이스 파일 암호화를 제공합니다. 이 방법으로 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 4: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


이 예제는 android.database.sqlite.SQLiteDatabase에 대한 참조를 net.sqlcipher.database.SQLiteDatabase로 대신합니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.

Spring Security의 경우 다이제스트 기반 암호 인코딩은 안전한 것으로 간주되지 않습니다. 또한 BCryptPasswordEncoder, Pbkdf2PasswordEncoder 또는 SCryptPasswordEncoder 같은 적응형 단방향 함수를 사용합니다. 암호 업그레이드를 지원하는 DelegatingPasswordEncoder를 사용하는 것이 좋습니다. 이 지원은 제거되지 않을 예정입니다. 이는 기존에 구현된 것이며 사용하는 것이 안전하지 않은 것으로 간주되어 사용되지 않습니다.

예제 5: 다음 코드는 위임 암호 인코더를 사용하도록 Spring Security로 보호된 응용 프로그램을 구성합니다.

@Bean
public PasswordEncoder passwordEncoder() {
    PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
    return encoder; 
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Secure Coding Rulepacks는 암호를 인수로 사용하는 것으로 알려진 함수를 찾아 암호 관리 이슈를 식별합니다. 암호가 프로그램 외부에서 제공되며 식별된 난독 처리 해제 루틴을 통과하지 않고 사용되는 경우 Fortify Static Code Analyzer는 암호 관리 이슈 플래그를 지정합니다.

암호 관리 이슈를 감사하려면 암호가 시스템에 입력되는 지점부터 시작하여 암호가 사용되는 지점까지 프로그램을 추적합니다. 난독 처리 해제를 수행하는 코드를 찾습니다. 난독 처리 해제 코드가 없으면 이 이슈는 해결되지 않은 것입니다. 암호가 난독 처리 해제 함수를 통과하는 경우 암호를 보호하는 데 사용하는 알고리즘이 견고한지 확인합니다.

암호가 제대로 보호된다고 확신하면 암호가 난독 처리로 보호되고 있음을 나타내는 난독 처리 해제 루틴에 대한 사용자 지정 통과 규칙(pass-through rule)을 작성하십시오. 이 규칙을 향후 응용 프로그램 분석에 포함시키면 식별된 난독 처리 해제 루틴을 통과한 암호는 더 이상 암호 관리 취약점을 일으키지 않습니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Struts 2 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="00ED5A01251FA97DED1DF10FF91B63E0" ruleID="211A940B-7324-4F90-BFF3-CF7ECEDE29CF">
                            <Category>Password Management: Weak Cryptography</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java</FilePath>
<LineStart>103</LineStart>
<Snippet>  @Bean
  public NoOpPasswordEncoder passwordEncoder() {
    return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
  }
}</Snippet>
<TargetFunction>FunctionCall: getInstance()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CDDFEA05C738C7AA437DA351BB141003" ruleID="211A940B-7324-4F90-BFF3-CF7ECEDE29CF">
                            <Category>Password Management: Weak Cryptography</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java</FilePath>
<LineStart>112</LineStart>
<Snippet>  @Bean
  public NoOpPasswordEncoder passwordEncoder() {
    return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
  }
}</Snippet>
<TargetFunction>FunctionCall: getInstance()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Privacy Violation: Autocomplete</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>hijackform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 "내 암호 저장" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  &lt;form method="post" autocomplete="off"&gt;
        Address: &lt;input name="address" /&gt;
        Password: &lt;input name="password" type="password" /&gt;
  &lt;/form&gt;


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  &lt;form method="post"&gt;
        Address: &lt;input name="address" /&gt;
        Password: &lt;input name="password" type="password" autocomplete="off"/&gt;
  &lt;/form&gt;


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="8E778A7762E99826CA67E0A83B2E4C25" ruleID="2FC7D1FF-11E4-468E-B7AB-F127828F4016">
                            <Category>Privacy Violation: Autocomplete</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>hijackform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>hijackform.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/hijacksession/templates/hijackform.html</FilePath>
<LineStart>16</LineStart>
<Snippet>					&lt;div class="form-group input-group"&gt;
						&lt;span class="input-group-addon"&gt;&lt;i
							class="glyphicon glyphicon-lock"&gt;&lt;/i&gt;&lt;/span&gt; &lt;input class="form-control"
							placeholder="Password" name="password" type="password" /&gt;
					&lt;/div&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="D130F2D11A11036C43935126D9371121" ruleID="2FC7D1FF-11E4-468E-B7AB-F127828F4016">
                            <Category>Privacy Violation: Autocomplete</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>spoofcookieform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>spoofcookieform.html</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/lessons/spoofcookie/templates/spoofcookieform.html</FilePath>
<LineStart>16</LineStart>
<Snippet>					&lt;div class="form-group input-group"&gt;
						&lt;span class="input-group-addon"&gt;&lt;i
							class="glyphicon glyphicon-lock"&gt;&lt;/i&gt;&lt;/span&gt; &lt;input class="form-control"
							placeholder="Password" name="password" type="password"
							id="spoof_password" /&gt;</Snippet>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: Incorrect Serializable Method Signature</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>VulnerableTaskHolder.java의 44에 포함된 메서드는 serializable 메서드를 사용하지만 서명이 잘못되었으므로 serialization/deserialization 중에 호출되지 않게 될 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>코드 정확성: serializable 클래스가 serialization 또는 deserialization 함수를 작성하지만 올바른 서명을 따르지 않는 경우 잘못된 Serializable 메서드 서명 이슈가 발생합니다. 


  private void writeObject(java.io.ObjectOutputStream out) throws IOException;
  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;
  private void readObjectNoData() throws ObjectStreamException;


serialization에 필요한 메서드 서명이 아닌 서명을 사용하는 경우 serialization/deserialization 중에 메서드가 호출되지 않게 될 수 있습니다. 그러면 serialization/deserialization이 완료되지 않거나, 신뢰할 수 없는 코드가 개체에 접근할 수 있습니다. 
발생(throw)하지 않은 예외가 있는 경우 serialization/deserialization이 실패하여 응용 프로그램이 중단되거나 그러한 개체가 부분적으로만 올바르게 생성되었을 수 있습니다. 이로 인해 디버깅하기 매우 어려운 취약점이 발생할 수 있습니다. 호출자가 이러한 예외를 캐치(catch)해야 프로그램이 중단되거나 개체가 부분적으로 생성되는 일 없이 그러한 잘못된 serialization/deserialization이 적절하게 처리될 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>특수하게 처리해야 하는 클래스에 대해 Java에서 serialization을 사용할 때 writeObject(), readObject() 및 readObjectNoData 메서드는 정확한 서명을 포함해야 합니다. 


  private void writeObject(java.io.ObjectOutputStream out) throws IOException;
  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;
  private void readObjectNoData() throws ObjectStreamException;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B118C2C9492E0956B4F2F4E1FA994EFD" ruleID="6652216F-0850-4985-847A-19DF0EF1CAD1">
                            <Category>Code Correctness: Incorrect Serializable Method Signature</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>VulnerableTaskHolder.java의 44에 포함된 메서드는 serializable 메서드를 사용하지만 서명이 잘못되었으므로 serialization/deserialization 중에 호출되지 않게 될 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableTaskHolder.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java</FilePath>
<LineStart>44</LineStart>
<Snippet>   * @author stupid develop
   */
  private void readObject(ObjectInputStream stream) throws Exception {
    // unserialize data so taskName and taskAction are available
    stream.defaultReadObject();</Snippet>
<TargetFunction>Function: readObject()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Command Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>VulnerableTaskHolder.java의 readObject() 메서드는 exec()을(를) 호출하여 명령을 실행합니다. 이 호출을 사용하면 공격자가 악의적인 명령을 삽입할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Command injection 취약점은 두 가지 형태로 나타납니다.

- 공격자가 프로그램이 실행하는 명령을 변경합니다. 공격자가 명시적으로 명령 부분을 제어합니다.

- 공격자가 프로그램이 실행되는 환경을 변경합니다. 공격자가 암시적으로 명령의 의미를 제어합니다.

여기서는, 공격자가 환경 변수를 변경하거나 악성 실행 파일을 검색 경로에 삽입하여 명령의 의미를 변경할 수 있는 두 번째 시나리오를 중점적으로 살펴보겠습니다. 이런 종류의 command injection 취약점은 다음 경우에 발생합니다.

1. 공격자가 응용 프로그램의 환경을 수정합니다. 

2. 응용 프로그램은 절대 경로 지정 또는 수행하는 이진 파일 확인 등의 작업을 거치지 않고 명령을 실행합니다. 

3. 응용 프로그램은 명령을 실행하여 공격자에게 공격자가 다른 방법으로는 얻을 수 없는 권한 또는 기능을 부여합니다. 

예제: 다음 코드는 사용자가 시스템의 암호를 업데이트할 수 있는 인터페이스를 제공하는 웹 응용 프로그램의 일부입니다. 특정 네트워크 환경에서 암호를 업데이트하는 프로세스의 일부는 /var/yp 디렉터리에서 make 명령을 실행하는 것입니다.


...
System.Runtime.getRuntime().exec("make");
...


여기서 문제는 프로그램이 make의 절대 경로를 지정하지 않아 Runtime.exec() 호출을 실행하기 전에 실행 환경이 정리되지 않는다는 점입니다. 공격자가 $PATH 변수를 수정하여 make라는 악성 이진 파일을 가리키도록 하고 자신의 환경에서 프로그램을 실행하면 원하는 파일 대신 악성 이진 파일이 로드됩니다. 응용 프로그램은 그 속성 때문에 시스템 작업을 수행하는 데 필요한 권한으로 실행됩니다. 즉, 공격자의 make는 이 권한으로 실행되어 공격자에게 시스템의 완전한 제어권을 넘겨줄 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>공격자는 명령이 실행되는 환경을 수정하여 프로그램이 실행하는 명령을 간접적으로 제어할 수 있습니다. 실행 환경을 신뢰할 수 없으므로 공격자가 환경을 조작하여 공격을 가하는 것을 막기 위한 예방 조치를 취해야 합니다. 가급적이면 명령은 응용 프로그램에서 제어해야 하고 절대 경로를 사용하여 실행해야 합니다. 교차 플랫폼 응용 프로그램의 경우와 같이 컴파일 시 경로를 알 수 없는 경우, 실행 도중 신뢰할 수 있는 값으로 절대 경로를 만들어야 합니다. 구성 파일 또는 환경에서 읽은 명령 값 및 경로를 올바른 값을 정의해 놓은 고정 값 집합과 대조하는 안전 검사를 수행해야 합니다.

이 소스가 조작된 것인지 밝히기 위한 검사도 수행할 수 있습니다. 예를 들어, 구성 파일이 누구나 쓸 수 있는(world-writable) 파일인 경우 프로그램이 실행을 거부할 수 있습니다. 실행할 이진 파일에 대한 정보를 사전에 알고 있으면 프로그램이 이진 파일의 ID를 확인하기 위한 검사를 실시할 수 있습니다. 이진 파일을 항상 특정 사용자가 소유해야 하거나 파일에 특정 접근 권한 집합을 지정해야 하는 경우, 파일을 실행하기 전에 이런 속성을 프로그래밍 방식으로 확인할 수 있습니다.

결론적으로 프로그램은 프로그램이 실행하는 명령을 제어하려는 가상의 공격자로부터 스스로를 완벽하게 보호하는 일이 불가능합니다. 따라서 상상할 수 있는 모든 입력 값 및 환경 조작을 식별하고 예방하기 위해 노력할 수밖에 없습니다. 목표는 최대한 많은 공격을 차단하는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Windows에서는 실행되는 명령이 Windows 내부 명령인 경우 보고된 문제가 우려 대상이 아닙니다. 내부 명령은 디스크에 상주하지 않습니다. 대신 컴퓨터 시스템이 시작될 때 메모리에 로드되는 COMMAND.COM에 상주합니다. 내부 명령에는 BREAK, CALL, CHCP, CHDIR(CD), CLS, COPY, CTTY, DATE, DEL(ERASE), DIR, ECHO, EXIT, FOR, GOTO, IF, MKDIR(MD), PATH, PAUSE, PROMPT, REM, RENAME(REN), RMDIR(RD), SET, SHIFT, TIME, TYPE, VER, VERIFY, VOL이 포함됩니다. 사용 중인 시스템의 최신 내부 명령 목록은 시스템 설명서를 참조하십시오.

2. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3D00A2EDD1CAF40F1B37BEFF6374E92A" ruleID="69777D84-8507-40A7-9C2B-0B18E4A5EB0A">
                            <Category>Command Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>VulnerableTaskHolder.java의 readObject() 메서드는 exec()을(를) 호출하여 명령을 실행합니다. 이 호출을 사용하면 공격자가 악의적인 명령을 삽입할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableTaskHolder.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java</FilePath>
<LineStart>65</LineStart>
<Snippet>      log.info("about to execute: {}", taskAction);
      try {
        Process p = Runtime.getRuntime().exec(taskAction);
        BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line = null;</Snippet>
<TargetFunction>exec(0)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Denial of Service</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>VulnerableTaskHolder.java의 68 줄, readLine() 호출을 사용하면 공격자가 프로그램을 중단할 수 있게 되거나 정식 사용자가 이용할 수 없게 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>공격자가 응용 프로그램에 요청을 과도하게 보내어 정식 사용자에 대한 서비스를 거부할 수도 있으나 플러딩(flooding) 공격은 네트워크 계층에서 무산되는 경우도 있습니다. 더 심각한 문제는 적은 수의 요청으로 공격자가 응용 프로그램을 과부화하도록 허용하는 버그입니다. 이러한 버그는 해당 요청이 사용되는 시스템 자원의 수치 또는 이 수치를 사용하는 기간을 공격자가 지정하도록 허용합니다.

예제 1: 다음 코드는 스레드가 절전 모드인 시간을 사용자가 지정하도록 허용합니다. 공격자는 큰 수를 지정하여 스레드를 무기한으로 지연시킬 수 있습니다. 적은 수의 요청으로 공격자가 응용 프로그램의 스레드 풀을 고갈시킬 수 있습니다.


  int usrSleepTime = Integer.parseInt(usrInput);
  Thread.sleep(usrSleepTime);


예제 2: 다음 코드는 zip 파일에서 문자열을 읽습니다. 이 코드에서는 readLine() 메서드를 사용하기 때문에 범위 지정 없는 입력 양을 읽습니다. 공격자가 OutOfMemoryException을 발생시키거나 대량의 메모리를 소모하도록 이 코드를 이용할 수 있으므로 프로그램이 가비지 수집(garbage collection)을 수행하는 데 더 많은 시간을 소모하거나 이후의 일부 작업 중에 메모리가 부족해집니다.


  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  String line = br.readLine();
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>자원을 부적절하게 이용하지 않도록 사용자 입력을 확인합니다.

예제 3: 다음 코드를 통해 사용자는 Example 1과 같이 스레드가 절전 모드로 있을 시간을 지정할 수 있지만 이는 값이 타당한 범위에 있는 경우에만 해당합니다.

  int usrSleepTime = Integer.parseInt(usrInput);
  if (usrSleepTime &gt;= SLEEP_MIN &amp;&amp;
      usrSleepTime &lt;= SLEEP_MAX) {
    Thread.sleep(usrSleepTime);
  } else {
    throw new Exception("Invalid sleep duration");
  }
}


예제 4: 다음 코드는 Example 2에서와 같이 zip 파일에서 문자열을 읽지만 이 코드가 읽는 최대 문자열 길이는 MAX_STR_LEN자입니다.

  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  StringBuffer sb = new StringBuffer();
  int intC;
  while ((intC = br.read()) != -1) {
    char c = (char) intC;
    if (c == '\n') {
      break;
    }
    if (sb.length() &gt;= MAX_STR_LEN) {
      throw new Exception("input too long");
    }
    sb.append(c);
  }
  String line = sb.toString();
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 공격자가 소모될 시스템 리소스의 양 또는 시스템 리소스가 사용될 기간을 통제하지 않은 경우 또는 최소한 직접적으로 통제하지 않은 경우에도 Denial of service가 발생할 수 있습니다. 오히려 프로그래머가 이러한 매개 변수를 지정하기 위해 안전하지 않은 상수 값을 선택할 수 있습니다. Fortify Secure Coding Rulepacks는 이러한 경우를 잠재적인 Denial of Services 취약점으로 보고합니다.

2. 이 취약점에 권장되는 수정 방법은 감지되지 않을 수 있으므로 수정 후 추가 감사를 수행하여 수정을 확인해야 할 수 있습니다. 취약점이 제거된 것을 확인한 후 문제를 안전하게 억제할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="6789722AFA05BF61582C52F586F10E34" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>VulnerableTaskHolder.java의 68 줄, readLine() 호출을 사용하면 공격자가 프로그램을 중단할 수 있게 되거나 정식 사용자가 이용할 수 없게 됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>VulnerableTaskHolder.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java</FilePath>
<LineStart>68</LineStart>
<Snippet>        BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line = null;
        while ((line = in.readLine()) != null) {
          log.info(line);
        }</Snippet>
<TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dockerfile Misconfiguration: Default User Privilege</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Dockerfile에 USER가 지정되어 있지 않으므로 기본적으로 루트 사용자로 실행됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Dockerfile에 USER가 지정되어 있지 않으면 Docker 컨테이너는 기본적으로 슈퍼 사용자 권한으로 실행됩니다. 이러한 슈퍼 사용자 권한은 컨테이너 안에서 실행 중인 코드로 전파되며 필요 이상으로 많은 권한을 제공합니다. 슈퍼 사용자 권한으로 Docker 컨테이너를 실행하면 공격 표면이 확장되어 공격자가 더 심각한 형태의 악용을 감행할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>따라서 가능한 경우 루트 사용자가 아닌 사용자로 컨테이너를 실행하는 것이 좋습니다.

루트가 아닌 사용자를 사용하도록 Docker 컨테이너를 수정하려면 Dockerfile에서 다음과 같이 다른 사용자를 지정해야 합니다.

RUN useradd myLowPrivilegeUser
USER myLowPrivilegeUser

    </Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="F8A0F676D23B0CE1F581A2966E424F8C" ruleID="375B7CCC-5920-4230-AE53-A7B264045525">
                            <Category>Dockerfile Misconfiguration: Default User Privilege</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Dockerfile에 USER가 지정되어 있지 않으므로 기본적으로 루트 사용자로 실행됩니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Dockerfile_desktop</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/Dockerfile_desktop</FilePath>
<LineStart>1</LineStart>
<Snippet>FROM lscr.io/linuxserver/webtop:ubuntu-xfce
LABEL NAME = "WebGoat: A deliberately insecure Web Application"
MAINTAINER "WebGoat team"</Snippet>
<TargetFunction>FROM()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dockerfile Misconfiguration: Dependency Confusion</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>비특정 버전을 사용하여 빌드 종속성을 검색하면 빌드 시스템이 악성 바이너리에 취약해지거나 시스템에서 예기치 않은 동작이 발생할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Dockerfile은 종속성 및 기본 이미지에 대해 바인딩되지 않은 버전 범위를 지정할 수 있습니다. 공격자가 리포지토리에 악성 버전의 종속성을 추가하거나 공격자의 제어 하에 있는 리포지토리에서 종속성을 다운로드하도록 빌드 시스템을 교란할 수 있는 상황에서 Docker가 특정 버전의 종속성 없이 구성되어 있으면 Docker는 손상된 종속성을 자동으로 다운로드하고 실행합니다.

이러한 유형의 약점은 공격자가 개발자의 구성 오류, 타이포스쿼팅을 활용하고 오픈 소스 리포지토리에 악성 패키지를 추가할 수 있는 공급망 공격의 결과로 악용될 수 있습니다. 이 유형의 공격은 게시된 패키지의 신뢰를 악용하여 액세스 권한을 얻고 데이터를 반출합니다.

Docker에서 latest 태그는 이미지의 버전을 제공하기 위한 다이제스트 또는 고유 태그를 사용하지 않고 이미지의 버전 수준을 자동으로 나타냅니다. Docker는 최신 이미지 매니페스트 파일을 가리키는 메커니즘으로 latest 태그를 자동으로 할당합니다. 태그는 변경이 가능하기 때문에 공격자는 latest(또는 imagename-lst, imagename-last, myimage와 같은 약한 태그)를 사용하여 이미지 또는 계층을 바꿀 수 있습니다.

예제 1: 다음 구성은 Docker에 ubuntu의 최신 버전을 사용하는 기본 이미지를 선택하도록 지시합니다.

    FROM ubuntu:Latest
    ...


Docker는 패키지 관리자를 지원하도록 구성된 리포지토리의 신뢰성을 검증하지 않습니다.

예제 2: 다음 구성은 패키지 관리자 zypper에 지정된 패키지의 최신 버전을 검색하도록 지시합니다.

...
zypper install package
...

Example 2에서 리포지토리가 손상된 경우 공격자는 동적 기준을 충족하는 버전을 업로드하고 zypper로 하여금 종속성의 악성 버전을 다운로드하도록 할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>버전 고정 또는 단순 고정을 수행하십시오. 버전 고정은 응용 프로그램 또는 시스템에 사용할 이미지, 라이브러리 및 지원 패키지의 버전을 명시적으로 지정합니다. 고정의 주된 목표는 시스템 안정성을 보장하여 반복 가능한 배포를 달성하는 것입니다. 고정을 수행하면 최종 사용자, 개발자 및 테스터가 모두 동일한 코드 기반을 사용할 수 있습니다. 또한 고정을 사용하면 응용 프로그램 보안 검증 및 맬웨어 감지의 엄격한 프로세스를 거친 안전한 종속성의 사용을 보장할 수 있습니다.

Docker에서 zypper(또는 기타 패키지 관리자)를 호출하는 경우 다음 형식을 사용하십시오.
    
    RUN zypper install &lt;package_name&gt;=&lt;version&gt; \
    RUN gem install &lt;package_name&gt; --version &lt;version&gt;
    RUN gem install &lt;package_name&gt; -v &lt;version&gt;
    RUN apk add &lt;package_name&gt;=&lt;version&gt;
    RUN apt-get update &amp;&amp; apt-get install -y  \
      &lt;package_name&gt;=&lt;version&gt;  \
      &lt;package_name&gt;=&lt;version&gt; \
      &lt;package_name&gt;=&lt;version&gt; \
      &amp;&amp; rm -rf /var/lib/apt/lists/*
    
여기서 &lt;package_name&gt;은 설치할 종속성의 이름이고 &lt;version&gt;은 응용 프로그램에 사용해야 하는 정확한 버전 또는 릴리스입니다.

Fortify는 또한 다음을 권장합니다.
- 패키지 관리자에 사용되는 리포지토리를 신뢰할 수 있는지 아니면 적절히 보관되는지 확인하고, 악성 코드를 패키지에 추가하는 것을 포함하여 설치 패키지 대체가 가능하지 않은지 확인하십시오.
- 공개 리포지토리 또는 신뢰할 수 없는 리포지토리를 사용하지 마십시오.
- 회귀 테스트를 실행하기 전에 패키지에서 맬웨어 및 보안 취약점을 검사하십시오.
- 디지털 서명된 이미지를 사용하십시오.
- latest와 같은 이미지 태그 또는 imagename-lst, imagename-last, myimage와 같은 취약한 태그를 운영 환경의 배포에 사용하지 마십시오.
- 특정 버전 태그와 같이 더 안정적인 태그를 사용하십시오. 그러나 이러한 태그도 변경되지 않는다는 보장은 없습니다.
- 뮤턴트 태그를 만들지 마십시오.
- 이미지 소스 및 해당 계층에 대한 엄격한 제어를 구현하십시오.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="F311119CB9A7E566CD0798F54D580940" ruleID="10AB223B-7AA6-464A-A036-4616C822C299">
                            <Category>Dockerfile Misconfiguration: Dependency Confusion</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>비특정 버전을 사용하여 빌드 종속성을 검색하면 빌드 시스템이 악성 바이너리에 취약해지거나 시스템에서 예기치 않은 동작이 발생할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>Dockerfile_desktop</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/Dockerfile_desktop</FilePath>
<LineStart>12</LineStart>
<Snippet>COPY config/desktop/WebGoat.txt /config/Desktop/

RUN \
 case $(uname -m) in \
  x86_64) ARCH=x64;; \</Snippet>
<TargetFunction>RUN()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dynamic Code Evaluation: Unsafe Deserialization</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>런타임 시 사용자가 제어하는 개체 스트림을 역직렬화하면 공격자가 서버에서 임의의 코드를 실행하거나, 응용 프로그램 로직을 남용하거나, DOS(Denial of Service)를 일으킬 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Java 직렬화는 개체 그래프를 개체 자체와 필요한 메타데이터를 포함한 바이트 스트림으로 바꿔 바이트 스트림에서 이를 재생성합니다. 개발자는 사용자 지정 코드를 생성하여 Java 개체 역직렬화 프로세스에 도움을 줄 수 있습니다. 이 프로세스에서는 역직렬화된 개체를 다른 개체 또는 프록시로 대체할 수 있습니다. 개체가 응용 프로그램으로 돌아가고 예상한 유형으로 지정되기 전에 재생성되는 동안 사용자 지정 역직렬화 프로세스가 발생합니다. 개발자가 예상한 유형을 적용하려 할 때는 이미 코드가 실행된 후일 수 있습니다. 

사용자 지정 역직렬화 루틴은 런타임 classpath에 있어야 하는 serializable 클래스에서 정의되며, 이는 공격자가 삽입할 수 없기 때문에 이러한 공격의 활용 가능성은 응용 프로그램 환경에서 사용할 수 있는 클래스에 따라 다릅니다. 유감스럽게도 일반적인 타사 클래스 또는 JDK 클래스도 JVM 리소스를 소모하거나, 악의적인 파일을 구축하거나, 임의의 코드를 실행하는 데 남용될 수 있습니다.&#13;




예제 1: 신뢰할 수 없는 개체 스트림을 역직렬화하는 응용 프로그램은 응용 프로그램을 손상시킬 수 있습니다.

InputStream is = request.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
MyObject obj = (MyObject) ois.readObject();
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>가능하면 개체 스트림의 콘텐트 확인 없이 신뢰할 수 없는 데이터를 역직렬화하지 마십시오. 역직렬화 중인 클래스를 확인하려면 미리 보기 역직렬화 패턴을 사용해야 합니다. 

먼저 개체 스트림에 클래스 설명 메타데이터가 포함된 후 해당 멤버 필드의 직렬화된 바이트가 포함됩니다. Java 직렬화 프로세스를 통해 개발자는 클래스 설명을 읽고 개체의 역직렬화를 진행 또는 중단할지 여부를 결정할 수 있습니다. 그러기 위해서는 하위 클래스 java.io.ObjectInputStream을 지정하고 resolveClass(ObjectStreamClass desc) 메서드의 사용자 지정 구현을 제공해야 합니다. 여기서 클래스 검증 및 확인을 수행합니다.

Apache Commons IO(org.apache.commons.io.serialization.ValidatingObjectInputStream)와 같이 쉽게 사용 가능한 미리 보기 패턴의 기존 구현이 있습니다. 항상 엄격한 허용 목록 접근 방식을 사용하여 필요한 유형만 역직렬화해야 합니다. 공격자가 사용 가능한 여러 가젯을 사용해 거부 목록을 무시할 수 있으므로 거부 목록 접근 방식은 사용하지 않는 것이 좋습니다. 또한 코드 실행을 수행하기 위한 일부 클래스는 공개적으로 알려져 있더라도 알 수 없거나 숨겨진 클래스가 있을 수 있으므로 항상 허용 목록 접근 방식을 사용하는 것이 좋습니다. 허용 목록에서 허용되는 모든 클래스를 감사하여 역직렬화해도 안전한지를 확인해야 합니다.

역직렬화를 라이브러리 또는 프레임워크에서 수행할 경우(예: JMX, RMI, JMS, HTTP Invoker를 사용할 때) 개발자가 제어할 수 없는 상황이므로 앞선 권장 사항이 유용하지 않습니다. 그럴 경우 이러한 프로토콜이 다음 요구 사항을 충족하는지 확인해야 합니다.

- 공개적으로 노출되지 않음
- 인증 사용
- 무결성 검사 사용
- 암호화 사용

또한 Fortify Runtime에서는 응용 프로그램에서 ObjectInputStream로부터 역직렬화를 수행할 때마다 적용되는 보안 제어를 제공합니다. 이는 응용 프로그램 코드뿐 아니라 라이브러리 및 프레임워크 코드도 해당 유형의 공격으로부터 보호합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 기존 ObjectInputStream을 구현하는 데 취약점이 있고 DoS(Denial of Service) 공격을 수행하는 데 사용될 수 있는 기본 클래스에 대한 거부 목록을 구현하는 것이 어렵기 때문에 미리 보기 ObjectInputStream이 구현되더라도 이 문제는 보고되지만 그 심각도는 Medium으로 낮춰집니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5C689CE7F25C670228BE531CE8A9CD5D" ruleID="65F4371B-9180-4631-AC91-C06B07C5FC480">
                            <Category>Dynamic Code Evaluation: Unsafe Deserialization</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>런타임 시 사용자가 제어하는 개체 스트림을 역직렬화하면 공격자가 서버에서 임의의 코드를 실행하거나, 응용 프로그램 로직을 남용하거나, DOS(Denial of Service)를 일으킬 수 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>InsecureDeserializationTask.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/deserialization/InsecureDeserializationTask.java</FilePath>
<LineStart>60</LineStart>
<Snippet>        new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(b64token)))) {
      before = System.currentTimeMillis();
      Object o = ois.readObject();
      if (!(o instanceof VulnerableTaskHolder)) {
        if (o instanceof String) {</Snippet>
<TargetFunction>java.io.ObjectInputStream.readObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>InsecureDeserializationTask.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/deserialization/InsecureDeserializationTask.java</FilePath>
<LineStart>49</LineStart>
<Snippet>  @PostMapping("/InsecureDeserialization/task")
  @ResponseBody
  public AttackResult completed(@RequestParam String token) throws IOException {
    String b64token;
    long before;</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Dynamic Code Evaluation: Unsafe XStream Deserialization</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>VulnerableComponentsLesson.java 파일은 57 줄에서 XStream을 사용하여 확인되지 않은 XML 입력을 역직렬화합니다. 런타임 시 사용자가 제어하는 XML 문서를 역직렬화하면 공격자가 서버에서 악성 코드를 실행할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>개발자는 XStream 라이브러리를 통해 손쉽게 개체를 전송하여 XML 문서로 직렬화할 수 있습니다. 그러나 XStream 역직렬화는 공격자가 서버에서 임의의 Java 코드를 실행하도록 허용할 수 있습니다.

예제 1: 다음 Java 코드는 신뢰할 수 없는 입력을 처리하는 XStream 인스턴스를 보여줍니다.


XStream xstream = new XStream();
String body = IOUtils.toString(request.getInputStream(), "UTF-8");
Contact expl = (Contact) xstream.fromXML(body);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XStream은 버전 1.4.7 이후부터 java.beans.EventHandler 등의 알려진 불량 클래스 역직렬화를 암시적으로 방지합니다. 그러나 향후 새로운 가젯이 발견될 수 있기 때문에 거부 목록 접근 방식은 충분하지 않습니다. 또한 XStream 1.4.7은 개발자가 유형 권한을 정의하도록 허용합니다. 이러한 권한을 사용하여 역직렬화되는 유형을 명시적으로 허용(허용 목록)할 수 있으므로 개체 그래프에 예기치 않은 유형을 삽입할 수 없습니다. 외부 소스에서 데이터를 역직렬화하는 응용 프로그램은 이 기능을 사용하여 임의 명령 실행 위험을 제한해야 합니다. 공격자가 다양한 클래스를 사용하여 원격 코드 실행을 수행하고 거부 목록을 우회할 수 있으므로 항상 허용 목록 접근 방식(허용되는 유형 검사)을 사용해야 합니다.

예제 2: 다음 Java 코드는 허용되는 유형을 정의하여 신뢰할 수 없는 입력을 안전하게 처리하는 XStream 인스턴스를 보여 줍니다.


XStream xstream = new XStream();
// clear out existing permissions and set own ones
xstream.addPermission(NoPermissionType.NONE);
// allow some basics
xstream.addPermission(NullPermission.NULL);
xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);
xstream.allowTypeHierarchy(Collection.class);
// allow any type from the same package
xstream.allowTypesByWildcard(new String[] {
    Contact.class.getPackage().getName()+".*"
});
String body = IOUtils.toString(request.getInputStream(), "UTF-8");
Contact expl = (Contact) xstream.fromXML(body);


허용 목록에서 허용되는 모든 클래스를 감사하여 역직렬화해도 안전한지를 확인해야 합니다.

XStream을 Spring 프로젝트의 마샬링 솔루션으로 사용하는 경우 “converters” 속성을 사용하여 org.springframework.oxm.xstream.CatchAllConverter 변환기로 시작하는 사용자 지정 변환기 체인을 설정하십시오.

예제 3: 다음 Spring 구성은 “converters” 속성을 사용하여 사용자 지정 변환 체인을 설정합니다. 

    &lt;bean id="marshallingHttpMessageConverter" class="org.springframework.http.converter.xml.MarshallingHttpMessageConverter"&gt;
        &lt;property name="marshaller" ref="xstreamMarshaller"/&gt;
        &lt;property name="unmarshaller" ref="xstreamMarshaller"/&gt;
    &lt;/bean&gt;

    &lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
        &lt;property name="aliases"&gt;
            &lt;props&gt;
                &lt;prop key="contact"&gt;org.company.converters.Contact&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="converters"&gt;
            &lt;list&gt;
                &lt;bean class="org.springframework.oxm.xstream.CatchAllConverter"/&gt;
                &lt;bean class="org.company.converters.ContactConverter"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7F03CE88BFEC1BE527092446C93EB6D7" ruleID="3B3C6BD3-2ACF-46BE-AB6B-1719C0D8940B">
                            <Category>Dynamic Code Evaluation: Unsafe XStream Deserialization</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>VulnerableComponentsLesson.java 파일은 57 줄에서 XStream을 사용하여 확인되지 않은 XML 입력을 역직렬화합니다. 런타임 시 사용자가 제어하는 XML 문서를 역직렬화하면 공격자가 서버에서 악성 코드를 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>VulnerableComponentsLesson.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java</FilePath>
<LineStart>57</LineStart>
<Snippet>                .replace(" &lt;", "&lt;");
      }
      contact = (Contact) xstream.fromXML(payload);
    } catch (Exception ex) {
      return failed(this).feedback("vulnerable-components.close").output(ex.getMessage()).build();</Snippet>
<TargetFunction>com.thoughtworks.xstream.XStream.fromXML()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>VulnerableComponentsLesson.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java</FilePath>
<LineStart>40</LineStart>
<Snippet>
  @PostMapping("/VulnerableComponents/attack1")
  public @ResponseBody AttackResult completed(@RequestParam String payload) {
    XStream xstream = new XStream();
    xstream.setClassLoader(Contact.class.getClassLoader());</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>File Disclosure: Spring</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>WebWolfRedirect.java의 19 줄에서 openWebWolf() 메서드는 확인되지 않은 입력으로 만들어진 경로를 사용하여 서버 쪽 전달을 호출합니다. 이로 인해 공격자는 응용 프로그램 바이너리를 다운로드하거나 보호할 수 있는 디렉터리 내 임의의 파일을 볼 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>다음과 같은 경우 파일 공개가 발생합니다.
1. 신뢰할 수 없는 소스에서 데이터가 프로그램에 입력됩니다.


2. 데이터를 사용하여 경로를 동적으로 생성합니다. 



예제 1: 다음 코드는 신뢰할 수 없는 데이터를 취하고 이를 사용하여 서버 쪽 전달에 사용되는 경로를 빌드합니다.


...
	String returnURL = request.getParameter("returnURL");
	return new ModelAndView(returnURL);
	...


공격자가 민감한 파일 위치와 일치하는 요청 매개 변수를 URL에 제공한 경우, 해당 파일을 볼 수 있습니다. 예를 들어 "http://www.yourcorp.com/webApp/logic?returnURL=WEB-INF/applicationContext.xml"에서 응용 프로그램의 applicationContext.xml을 볼 수 있습니다. 
공격자는 applicationContext.xml을 확보한 후 applicationContext.xml 또는 클래스나 jar 파일에서 참조된 다른 구성 파일을 찾아 다운로드할 수 있습니다. 그러면 공격자는 응용 프로그램에 대한 민감한 정보를 얻고 해당 정보를 대상으로 다른 유형의 공격을 할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>신뢰할 수 없는 데이터를 사용하여 서버 쪽 리소스에 대한 요청을 지시하지 마십시오. 대신 위치 및 경로 간 간접 참조를 사용하십시오.
다음은 사용하지 마십시오.

&lt; a href="http://www.yourcorp.com/webApp/logic?nextPage=WEB-INF/signup.jsp"&gt;New Customer&lt;/a&gt;

다음을 사용하십시오.

&lt; a href="http://www.yourcorp.com/webApp/logic?nextPage=newCustomer"&gt;New Customer&lt;/a&gt;

서버 쪽 로직에는 키 "newCustomer" 아래 저장된 경로가 "/WEB-INF/signup.jsp"인 서버 쪽 경로에 대해 로직 이름으로 입력된 맵이 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="67B9FCACE29C49DF47831F8F435C365D" ruleID="C4B02732-6AD9-49BF-96DF-1CD432D1EA1E0">
                            <Category>File Disclosure: Spring</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>WebWolfRedirect.java의 19 줄에서 openWebWolf() 메서드는 확인되지 않은 입력으로 만들어진 경로를 사용하여 서버 쪽 전달을 호출합니다. 이로 인해 공격자는 응용 프로그램 바이너리를 다운로드하거나 보호할 수 있는 디렉터리 내 임의의 파일을 볼 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>WebWolfRedirect.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java</FilePath>
<LineStart>19</LineStart>
<Snippet>    var url = applicationContext.getEnvironment().getProperty("webwolf.url");

    return new ModelAndView("redirect:" + url + "/home");
  }
}</Snippet>
<TargetFunction>org.springframework.web.servlet.ModelAndView.ModelAndView()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WebWolfRedirect.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java</FilePath>
<LineStart>17</LineStart>
<Snippet>  @GetMapping("/WebWolf")
  public ModelAndView openWebWolf() {
    var url = applicationContext.getEnvironment().getProperty("webwolf.url");

    return new ModelAndView("redirect:" + url + "/home");</Snippet>
<TargetFunction>org.springframework.core.env.PropertyResolver.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>HTML5: Overly Permissive Message Posting Policy</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>ace.js의 1740 줄에서 프로그램은 지나치게 허용적인 대상 원본을 사용하여 문서 간 메시지를 게시합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>HTML5의 새 기능 중 하나는 문서 간 메시징입니다. 스크립트는 이 기능을 통해 다른 창에 메시지를 게시할 수 있습니다. 해당 API를 사용하면 사용자는 대상 창의 원본을 지정할 수 있습니다. 그러나, 지나치게 허용적인 대상 원본을 사용하면 악성 스크립트가 부적절한 방법으로 피해자 응용 프로그램과 통신하여 스푸핑, 데이터 도난, 릴레이 및 기타 공격으로 이어질 수 있기 때문에 대상 원본 지정 시 주의해야 합니다.

예제 1: 다음은 와일드카드를 사용하여 프로그래밍 방식으로 전송할 메시지의 대상 원본을 지정하는 예입니다.


  o.contentWindow.postMessage(message, '*');


대상 원본의 값으로 *를 사용하면 스크립트가 원본에 상관없이 창에 메시지를 전송 중이라는 의미입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>*를 대상 원본의 값으로 사용하지 마십시오. 대신 특정 대상 원본을 제공하십시오.

예제 2: 다음 코드는 대상 원본에 특정 값을 제공합니다.


  o.contentWindow.postMessage(message, 'www.trusted.com');
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B0DB27D3BCA30450522BACB84C239AE2" ruleID="E789B621-9F69-49C5-A30C-ED6A89F80E31">
                            <Category>HTML5: Overly Permissive Message Posting Policy</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ace.js의 1740 줄에서 프로그램은 지나치게 허용적인 대상 원본을 사용하여 문서 간 메시지를 게시합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ace.js</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/resources/webgoat/static/js/libs/ace.js</FilePath>
<LineStart>1740</LineStart>
<Snippet>        
        exports.addListener(win, "message", listener);
        win.postMessage(messageName, "*");
    };
}</Snippet>
<TargetFunction>FunctionPointerCall: postMessage()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Insecure Randomness: User-Controlled Seed</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    </Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="140E99ACA7DA41F5640C2A65B803CD23" ruleID="3CB1D23E-CE0D-47E5-B387-F1026CDA0D64">
                            <Category>Insecure Randomness: User-Controlled Seed</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>PasswordResetLink.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java</FilePath>
<LineStart>17</LineStart>
<Snippet>    if (username.equalsIgnoreCase("admin")) {
      // Admin has a fix reset link
      random.setSeed(key.length());
    }
    return scramble(random, scramble(random, scramble(random, MD5.getHashString(username))));</Snippet>
<TargetFunction>java.util.Random.setSeed()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>PasswordResetLink.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java</FilePath>
<LineStart>33</LineStart>
<Snippet>  }

  public static void main(String[] args) {
    if (args == null || args.length != 2) {
      System.out.println("Need a username and key");</Snippet>
<TargetFunction>main(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Often Misused: Authentication</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>getLocalHost()에 대한 호출로 반환된 정보는 신뢰할 수 없습니다. 공격자가 DNS 항목을 스푸핑할 수 있습니다. 보안을 DNS에 의존하지 마십시오.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>많은 DNS 서버가 스푸핑 공격에 취약하기 때문에 언젠가는 소프트웨어가 손상된 DNS 서버가 있는 환경에서 실행될 수도 있다고 가정해야 합니다. 공격자가 DNS 업데이트를 수행할 수 있게 되면(DNS 캐시 감염(cache-poisoning)이라고도 함) 네트워크 트래픽을 자신의 시스템을 통과하도록 라우팅하거나 자신의 IP 주소가 사용자 도메인의 일부로 보이도록 만듭니다. 시스템 보안을 DNS 이름에 맡길 수 없습니다.


예제: 다음 코드는 DNS 조회를 사용하여 인바운드 요청이 신뢰할 수 있는 호스트의 것인지 여부를 결정합니다. 공격자가 DNS 캐시를 감염시키면 신뢰할 수 있는 지위를 얻게 됩니다.


 String ip = request.getRemoteAddr();
 InetAddress addr = InetAddress.getByName(ip);
 if (addr.getCanonicalHostName().endsWith("trustme.com")) {
 trusted = true;
 }


IP 주소는 DNS 이름보다는 신뢰할 수 있지만 역시 스푸핑될 수 있습니다. 공격자는 쉽게 자신들이 보내는 패킷의 원본 IP 주소를 위조할 수 있지만 응답 패킷은 위조된 IP 주소로 반환됩니다. 응답 패킷을 보려면 공격자는 피해자 시스템과 위조된 IP 주소 사이의 트래픽을 염탐해야 합니다. 공격자는 원하는 염탐을 수행하기 위해 보통 피해자 컴퓨터와 같은 서브넷에 있으려고 합니다. 공격자가 소스 라우팅을 사용하면 이 요구 사항을 피해 갈 수도 있지만 오늘날 인터넷의 상당 부분에서 소스 라우팅을 허용하지 않습니다. 간단히 말해, IP 주소 확인은 인증 기법의 필수적인 부분이기는 하지만 authentication에 필요한 유일한 요소는 아닙니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>호스트의 순방향 및 역방향 DNS 엔트리가 일치하는지 확인하면 도메인 이름 조회에 대한 신뢰가 커질 것입니다. 공격자는 대상 도메인의 이름 서버를 제어하지 않고는 순방향 및 역방향 DNS 엔트리를 모두 스푸핑할 수 없습니다. 하지만 이것도 완벽한 접근 방식은 아닙니다. 공격자가 도메인 등록 기관을 속여 도메인이 악성 이름 서버에 연결되도록 할 수 있습니다. DNS 엔트리를 기반으로 한 authentication은 매우 위험한 발상입니다.

어떤 authentication 메커니즘도 완벽할 수는 없지만 호스트 기반 authentication 보다 나은 대안은 있습니다. 암호 시스템은 양호한 보안 기능을 제공하지만 잘못된 암호 선택, 안전하지 않은 암호 전송 및 잘못된 password management에 취약합니다. SSL과 같은 암호화 기법을 고려해 볼 수 있지만 이 기법은 너무 복잡해서 심각한 구현 오류의 위험이 따라다니고 항상 핵심 요소를 도난 당할 위험이 있습니다. 대부분의 경우, 물리적인 토큰을 비롯한 복수 요소 authentication은 합리적인 비용으로 최고의 보안을 보장합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. DNS 정보를 사용하는 방법을 검사하십시오. 프로그램의 authentication 메커니즘이 무너질 수 있는지 여부 외에도 DNS 가장이 사회 공학 공격에 이용될 수 있는지도 고려합니다. 예를 들어, 공격자들이 게시가 내부 시스템에서 한 것처럼 보이도록 만들면, 공격자들은 신뢰성을 얻게 될까요?</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="719393AB8D03F72A694AC68F67C48976" ruleID="C7D64877-9D39-40E0-9510-5B7051F6E778">
                            <Category>Often Misused: Authentication</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>getLocalHost()에 대한 호출로 반환된 정보는 신뢰할 수 없습니다. 공격자가 DNS 항목을 스푸핑할 수 있습니다. 보안을 DNS에 의존하지 마십시오.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>Assignment1Test.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java</FilePath>
<LineStart>56</LineStart>
<Snippet>  @Test
  void success() throws Exception {
    InetAddress addr = InetAddress.getLocalHost();
    String host = addr.getHostAddress();
    mockMvc</Snippet>
<TargetFunction>getLocalHost()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Password Management: Empty Password</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>빈 암호는 쉽게 해결할 수 없는 방식으로 시스템 보안을 침해할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>빈 문자열을 암호 변수로 지정하는 것은 좋은 방법이 아닙니다. 빈 암호를 사용하여 다른 시스템을 인증하는 데 성공하게 되면 빈 암호를 받기 때문에 해당 계정의 보안이 침해될 수 있습니다. 올바른 값이 변수에 할당될 때까지 빈 암호가 단순히 자리 표시자로 사용되는 경우에는 코드에 익숙치 않은 사용자를 혼란시킬 수 있으며 예기치 못한 제어 흐름 경로에 문제를 일으킬 수 있습니다.



예제 1: 다음 코드는 빈 암호를 사용하여 데이터베이스에 연결하려 시도합니다.

    ...
    DriverManager.getConnection(url, "scott", "");
    ...


Example 1의 코드가 성공하면 데이터베이스 사용자 계정인 “scott”이 공격자가 쉽게 추측할 수 있는 빈 암호로 구성되어 있음을 나타냅니다. 프로그램을 공개한 후에는 비어 있지 않은 암호를 사용하기 위한 계정 업데이트를 위해 코드 변경이 필요합니다.

예제 2: 다음 코드는 암호 변수를 빈 문자열로 초기화하고 암호의 저장된 값 읽기를 시도하여 사용자가 제공하는 값과 비교합니다.


    ...
    String storedPassword = "";
    String temp;

    if ((temp = readPassword()) != null) {
        storedPassword = temp;
    }

    if(storedPassword.equals(userPassword))
        // Access protected resources
        ...
    }
    ...


readPassword()가 데이터베이스 오류 또는 다른 문제로 인해 저장된 암호를 검색하지 못하면 공격자가 userPassword에 대해 빈 문자열을 입력하여 암호 확인을 무시할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 3: 다음 코드는 사용자 이름과 암호 변수를 빈 문자열로 초기화하고, 서버가 현재 요청을 이전에 거부하지 않은 경우 Android WebView 저장소에서 자격 증명을 읽은 후 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String username = "";
    String password = "";

    if (handler.useHttpAuthUsernamePassword()) {
      String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
      username = credentials[0];
      password = credentials[1];
    }
    handler.proceed(username, password);
  }
});
...


Example 2와 마찬가지로 useHttpAuthUsernamePassword()에서 false를 반환하면 공격자가 빈 암호를 입력하여 보호된 페이지를 볼 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>항상, 암호화된 외부 리소스에서 저장된 암호 값을 읽고 암호 변수에 의미 있는 값을 지정하십시오. 민감한 리소스를 빈 암호 또는 null 암호로 보호하지 않도록 해야 합니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 따라서 암호화된 데이터베이스에 자격 증명을 저장할 수 있습니다.

예제 4: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="74F1E8AD635A457A4F9E96B9052D094D" ruleID="8bd01c50-a769-11de-8a39-0800200c9a66">
                            <Category>Password Management: Empty Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>빈 암호는 쉽게 해결할 수 없는 방식으로 시스템 보안을 침해할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>User.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/xxe/User.java</FilePath>
<LineStart>31</LineStart>
<Snippet>
  private String username = "";
  private String password = "";

  public String getPassword() {</Snippet>
<TargetFunction>FieldAccess: password()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Path Manipulation: Zip Entry Overwrite</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>ProfileZipSlip.java의 75 줄에서 copy()을(를) 호출하면 공격자가 시스템의 모든 위치에서 임의로 파일에 쓸 수 있습니다. </Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>path manipulation: ZIP 항목의 파일 경로를 확인하지 않고 ZIP 파일을 열어 확장하면 ZIP 항목 덮어쓰기 오류가 발생합니다.

예제 1: 다음 예제에서는 ZIP 파일에서 파일을 추출한 다음 안전하지 않은 방식으로 파일을 디스크에 씁니다.


  private static final int BUFSIZE = 512;
  private static final int TOOBIG = 0x640000;
  ...
  public final void unzip(String filename) throws IOException {
    FileInputStream fis = new FileInputStream(filename);
    ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));
    ZipEntry zipEntry = null;

    int numOfEntries = 0;
    long total = 0;

    try {
      while ((zipEntry = zis.getNextEntry()) != null) {
        byte data[] = new byte[BUFSIZE];
        int count = 0;
        String outFileName = zipEntry.getName();
        if (zipEntry.isDirectory()){
          new File(outFileName).mkdir(); //create the new directory
          continue;
        }
        FileOutputStream outFile = new FileOutputStream(outFileName);
        BufferedOutputStream dest = new BufferedOutputStream(outFile, BUFSIZE);
        //read data from ZIP, but do not read huge entries
        while (total + BUFSIZE &lt;= TOOBIG &amp;&amp; (count = zis.read(data, 0, BUFSIZE)) != -1) {
          dest.write(data, 0, count);
          total += count;
        }
        ...
      }
    } finally{
      zis.close();
    }
  }
  ...


Example 1에서는 이 항목 내의 데이터에 대한 읽기/쓰기 기능을 수행하기 전에 zipEntry.getName() 검증을 수행하지 않습니다. ZIP 파일이 Unix 기반 컴퓨터의 “/tmp/” 디렉터리에 원래 배치되었고 ZIP 항목이 “../etc/hosts”이며 응용 프로그램이 필요한 권한으로 실행되는 경우 이 파일이 시스템 hosts 파일을 덮어씁니다. 그러면 공격자는 컴퓨터의 트래픽을 공격자 컴퓨터로 다시 보내는 등 원하는 모든 위치로 전송할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>ZIP 파일을 통한 Path Manipulation을 방지하는 최선의 방법은 간접 참조를 사용하는 것입니다. ZIP 항목이 쓸 수 있는 올바른 경로 이름의 목록을 생성하고 ZIP 항목 위치와 일치하는 파일에 쓰십시오. 이 접근 방식을 사용하면 ZIP 파일의 사용자 입력이 파일 위치를 지정하는 데 직접 사용되지 않습니다.

그러나 이 예제에서는 이러한 접근 방식이 실용적이지 못할 수 있습니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 거부 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.

이 경우 java.io.File.getCanonicalPath() 등의 API를 사용하여 파일 경로의 정규화된 형식을 검색할 수 있습니다. 이 경로는 쓰게 될 파일의 디렉터리를 확인하는 데 사용할 수 있습니다.

예제 2: 아래에는 만들 파일 이름이 프로그래머가 지정한 디렉터리 내에 있음을 확인하는 데 사용되는 유틸리티 함수가 나와 있습니다.


public class MyFileUtils{
...
  public static validateFilenameInDir(String filename, String intendedDirectory) throws IOException{
    File checkFile = new File(filename);
    String canonicalPathToCheck = checkFile.getCanonicalPath();

    File intendedDir = new File(intendedDirectory);
    String canonicalPathToVerify = intendedDir.getCanonicalPath();

    if (canonicalPathToCheck.startsWith(canonicalPathToVerify)){
      return canonicalPathToCheck;
    } else{
      throw new IllegalStateException("This file is outside the intended extraction directory.");
    }
  }
...
}


예제 3: 다음은 Example 2를 사용하여 Example 1을 해결합니다.


  private static final int BUFSIZE = 512;
  private static final int TOOBIG = 0x640000;
  ...
  public final void unzip(String filename) throws IOException {
    FileInputStream fis = new FileInputStream(filename);
    ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));
    ZipEntry zipEntry = null;

    int numOfEntries = 0;
    long total = 0;

    try {
      while ((zipEntry = zis.getNextEntry()) != null) {
        byte data[] = new byte[BUFSIZE];
        int count = 0;

        // verify that the file to be written to is located in the current directory
        String outFileName = MyFileUtils.validateFilenameInDir(zipEntry.getName(), ".");

        if (zipEntry.isDirectory()) {
          new File(outFileName).mkdir(); //create the new directory
          continue;
        }
        FileOutputStream outFile = new FileOutputStream(outFileName);
        BufferedOutputStream dest = new BufferedOutputStream(outFile, BUFSIZE);
        //read data from ZIP, but do not read huge entries
        while (total + BUFSIZE &lt;= TOOBIG &amp;&amp; (count = zis.read(data, 0, BUFSIZE)) != -1) {
          dest.write(data, 0, count);
          total += count;
        }
        ...
      }
    } finally {
      zis.close();
    }
  }
  ...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="BF9EB58D7A762D3401365A6BFCB1723E" ruleID="13DC12CE-83A1-449A-B892-E2FB69F72C64">
                            <Category>Path Manipulation: Zip Entry Overwrite</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ProfileZipSlip.java의 75 줄에서 copy()을(를) 호출하면 공격자가 시스템의 모든 위치에서 임의로 파일에 쓸 수 있습니다. </Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>75</LineStart>
<Snippet>        File f = new File(tmpZipDirectory.toFile(), e.getName());
        InputStream is = zip.getInputStream(e);
        Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);
      }
</Snippet>
<TargetFunction>java.nio.file.Files.copy()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProfileZipSlip.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java</FilePath>
<LineStart>73</LineStart>
<Snippet>      while (entries.hasMoreElements()) {
        ZipEntry e = entries.nextElement();
        File f = new File(tmpZipDirectory.toFile(), e.getName());
        InputStream is = zip.getInputStream(e);
        Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);</Snippet>
<TargetFunction>java.util.zip.ZipEntry.getName()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Race Condition: Singleton Member Field</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>LogBleedingTask 클래스는 하나뿐이기 때문에 password 멤버 필드는 사용자 간에 공유됩니다. 결과는 하나의 사용자가 다른 사용자의 데이터를 볼 수 있는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>많은 Servlet 개발자들은 Servlet이 단일 항목이라는 사실을 모릅니다. Servlet의 인스턴스는 하나뿐이며, 이 단일 인스턴스를 여러 번 사용하여 다른 스레드에 의해서 동시에 처리되는 여러 요청을 처리합니다. 

이런 무지로 인해 일반적으로 발생하는 결과는 개발자가 사용자로 하여금 실수로 다른 사용자의 데이터를 볼 수 있도록 Servlet 멤버 필드를 사용하는 것입니다. 다시 말해, 사용자 데이터를 Servlet 멤버 필드에 저장하여 데이터 접근 경쟁 조건(race condition)을 야기합니다.

예제 1: 다음 Servlet은 요청 매개 변수의 값을 멤버 필드에 저장한 다음, 나중에 매개 변수 값을 응답 출력 스트림으로 보냅니다.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     name = req.getParameter("name");
     ...
     out.println(name + ", thanks for visiting!");
   }
}


이 코드는 단일 사용자 환경에서는 올바로 동작하지만, 두 명의 사용자가 거의 동시에 Servlet에 접근하면 다음과 같이 두 요청 처리기 스레드가 얽힐 수 있습니다.

스레드 1:	name에 "Dick" 할당
스레드 2:	name에 "Jane" 할당
스레드 1:	print "Jane, thanks for visiting!"
스레드 2:	print "Jane, thanks for visiting!"

따라서 첫 번째 사용자에게 두 번째 사용자의 이름이 표시됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Servlet 멤버 필드를 상수 저장 외에 다른 용도로 사용하지 마십시오. 즉, 모든 멤버 필드를 static final로 지정하십시오.

개발자가 데이터를 코드의 한 장소에서 다른 장소로 옮겨야 할 때 사용자 데이터에 Servlet 멤버 필드를 사용하고 싶을 것입니다. 그래야 할 경우, 별도의 클래스를 선언하고 Servlet은 새 클래스를 "래핑"하는 데만 사용하도록 하십시오. 

예제 2: Example 1의 버그는 다음과 같이 수정할 수 있습니다.


public class GuestBook extends HttpServlet {

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
	GBRequestHandler handler = new GBRequestHandler();
	handler.handle(req, res);
   }
}

public class GBRequestHandler {

   String name;

   public void handle(HttpServletRequest req, HttpServletResponse res) {
     name = req.getParameter("name");
     ...
     out.println(name + ", thanks for visiting!");
   }

}


또는 Servlet이 동기화된 차단을 사용하여 서블릿 인스턴스 변수에 접근할 수 있지만 동기화된 차단을 사용하면 중요한 성능 문제가 발생할 수 있습니다.

동기화된 블록 내에서 필드 접근을 래핑하는 경우 같은 동기화 블록 또는 메서드 내에서 해당 멤버에 대한 모든 읽기 및 쓰기 작업을 수행해야 문제를 방지할 수 있습니다.

예제 3: Example 1 쓰기 작업(할당)을 동기화된 블록에서 래핑해도 문제는 해결되지 않습니다. 스레드가 name 필드 수정을 위한 잠금을 획득하기는 하지만 이후 잠금을 해제하므로 두 번째 스레드가 값을 다시 변경할 수 있기 때문입니다. name 값을 변경한 후 첫 번째 스레드가 실행을 다시 시작하면 두 번째 스레드가 할당한 값이 인쇄됩니다.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     synchronized(name) {
        name = req.getParameter("name");
     }
     ...
     out.println(name + ", thanks for visiting!");
   }
}


이러한 race condition을 해결하려면 공유 멤버 필드에 대한 모든 쓰기 및 읽기 작업을 동일한 동기화된 블록 내에서 최소 단위로 실행해야 합니다.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     synchronized(name) {
        name = req.getParameter("name");
        ...
        out.println(name + ", thanks for visiting!");
     }
   }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="FA3D4834DC852AEB4341576A9CC76F7F" ruleID="46BD334E-BA05-4177-B856-06B1034F5FB3">
                            <Category>Race Condition: Singleton Member Field</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>LogBleedingTask 클래스는 하나뿐이기 때문에 password 멤버 필드는 사용자 간에 공유됩니다. 결과는 하나의 사용자가 다른 사용자의 데이터를 볼 수 있는 것입니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LogBleedingTask.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java</FilePath>
<LineStart>47</LineStart>
<Snippet>  @PostConstruct
  public void generatePassword() {
    password = UUID.randomUUID().toString();
    log.info(
        "Password for admin: {}",</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Server-Side Request Forgery</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>51 줄의 openStream() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>공격자가 응용 프로그램 서버에서 설정된 네트워크 연결에 영향을 미칠 수 있을 때 SSRF(Server-Side Request Forgery)가 발생합니다. 네트워크 연결의 출처는 응용 프로그램 서버 내부 IP가 되며, 공격자는 이 연결을 이용해서 네트워크 제어를 무시하고 원래는 노출되지 않은 내부 리소스를 스캔 또는 공격할 수 있게 됩니다.



예제: 다음은 공격자가 서버가 연결하는 URL을 제어할 수 있게 되는 예입니다.


String url = request.getParameter("url");
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet(url);
CloseableHttpResponse response1 = httpclient.execute(httpGet);


공격자가 네트워크 연결을 하이재킹하는 능력은 해당 공격자가 제어 가능한 URI의 특정 부분 및 연결에 사용된 라이브러리에 좌우됩니다. 예를 들어, URI 스키마를 제어할 수 있게 되면 공격자는 http 또는 https와는 다른 다음 프로토콜을 사용할 수 있게 됩니다.

- up://
- ldap://
- jar://
- gopher://
- mailto://
- ssh2://
- telnet://
- expect://

이렇게 하이재킹된 네트워크 연결을 이용하여 공격자는 다음과 같은 공격을 수행할 수 있습니다.

- 인트라넷 리소스 포트 스캐닝
- 방화벽 무시
- 응용 프로그램 서버 또는 인트라넷에서 실행 중인 취약 프로그램 공격
- Injection 공격 또는 CSRF를 활용한 내/외부 웹 응용 프로그램 공격
- file:// 스키마를 활용하여 로컬 파일에 접근
- Windows 시스템에서 공격자가 file:// 스키마 및 UNC 경로를 통해 내부 공유 자료에 접근 및 스캔 가능
- DNS 캐시 감염 공격 수행</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>사용자 제어 데이터를 기반으로 하여 네트워크 연결을 설정하지 마십시오. 또한 요청은 예정된 대상으로 전달되는지 확인해야 합니다. 대상 URI 구축을 위해 사용자 데이터가 필요한 경우에는 다음과 같은 간접 참조를 사용하십시오. 즉, 사용자가 선택해야 하는 올바른 리소스 이름의 목록을 만듭니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.

또한 필요한 경우 사용자 입력이 대상 시스템의 지정된 리소스에만 사용되도록 하십시오. URI 스키마, 호스트, 포트는 응용 프로그램이 제어하도록 해야 합니다. 이런 방식을 통해 공격자가 가할 수 있는 피해를 크게 줄일 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="1CE8A3993EC5BF68D0047C66EA8F9468" ruleID="33DDCCB9-248C-46E8-BF4E-0A8DFA006946">
                            <Category>Server-Side Request Forgery</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>51 줄의 openStream() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SSRFTask2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java</FilePath>
<LineStart>51</LineStart>
<Snippet>    if (url.matches("http://ifconfig\\.pro")) {
      String html;
      try (InputStream in = new URL(url).openStream()) {
        html =
            new String(in.readAllBytes(), StandardCharsets.UTF_8)</Snippet>
<TargetFunction>java.net.URL.openStream()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSRFTask2.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java</FilePath>
<LineStart>44</LineStart>
<Snippet>  @PostMapping("/SSRF/task2")
  @ResponseBody
  public AttackResult completed(@RequestParam String url) {
    return furBall(url);
  }</Snippet>
<TargetFunction>completed(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Spring Security Misconfiguration: Disabled Security Headers</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Spring Security 기본 보안 헤더는 비활성화되어 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Spring Security는 응용 프로그램을 보호할 수 있도록 기본 보안 헤더를 설정합니다. Spring Security에서 삽입한 기본 보안 헤더는 다음과 같습니다.


Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block


이러한 헤더는 응용 프로그램을 보호하는 데 적합한 헤더입니다. 더 제한적인 값으로 바뀌지 않는 한 이러한 헤더를 비활성화하지 마십시오.

예제: 다음 코드는 Spring Security 기본 헤더를 비활성화합니다. 

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ...
        http.headers.disable()
        ...
    }
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>사업상 꼭 필요한 이유가 있거나 더 제한적인 값으로 바뀌지 않는 한 기본값을 비활성화하지 마십시오.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D2E9691798757A47BF0958D4405130ED" ruleID="67DBAE17-B261-4F00-811A-6593F04CAFE2">
                            <Category>Spring Security Misconfiguration: Disabled Security Headers</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Spring Security 기본 보안 헤더는 비활성화되어 있습니다.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>WebSecurityConfig.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java</FilePath>
<LineStart>87</LineStart>
<Snippet>        .logout(logout -&gt; logout.deleteCookies("JSESSIONID").invalidateHttpSession(true))
        .csrf(csrf -&gt; csrf.disable())
        .headers(headers -&gt; headers.disable())
        .exceptionHandling(
            handling -&gt;</Snippet>
<TargetFunction>FunctionCall: disable()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Weak Cryptographic Hash</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>약한 암호화 해시는 데이터의 무결성을 보장할 수 없고 보안이 중요한 컨텍스트에 사용되어서는 안 됩니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>MD2, MD4, MD5, RIPEMD-160 및 SHA-1은 메시지 및 기타 데이터의 무결성을 확인하는 데 흔히 사용되는 인기 있는 암호화 해시 알고리즘입니다. 하지만 최근의 암호화 연구를 통해 이러한 알고리즘에 근본적인 취약점이 있음이 밝혀졌으므로 더 이상 보안이 중요한 상황에 사용해서는 안 됩니다.

MD 및 RIPEMD 해시를 효과적으로 해체하기 위한 기법이 널리 사용되고 있으므로 보안을 위해 이러한 알고리즘을 신뢰해서는 안 됩니다. SHA-1의 경우, 현재의 기술은 여전히 상당한 계산 능력이 필요하며 구현하기 더 어렵습니다. 그러나 공격자는 알고리즘의 아킬레스 건을 찾아 이를 해결하는 기술로 심지어 더 빠른 공격을 발견할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>보안이 중요한 상황에서는 데이터 확인을 위해 MD2, MD4, MD5, RIPEMD-160 및 SHA-1을 사용하지 마십시오. 현재로서는 SHA-224, SHA-256, SHA-384, SHA-512 및 SHA-3가 좋은 대안입니다. 그러나 보안 해시 알고리즘의 이러한 변형은 SHA-1만큼 세밀히 검사되지 않았으므로 이러한 알고리즘의 보안에 영향을 줄 수 있는 앞으로의 조사에 신경을 써야 합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B975F145AFDE72FB05EFB21574722586" ruleID="FD6C18E2-3AD8-4842-84CD-3E3D638BCCE4">
                            <Category>Weak Cryptographic Hash</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>약한 암호화 해시는 데이터의 무결성을 보장할 수 없고 보안이 중요한 컨텍스트에 사용되어서는 안 됩니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HashingAssignment.java</FileName>
<FilePath>Downloads/WebGoat-2023.8/WebGoat-2023.8/src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java</FilePath>
<LineStart>55</LineStart>
<Snippet>      String secret = SECRETS[new Random().nextInt(SECRETS.length)];

      MessageDigest md = MessageDigest.getInstance("MD5");
      md.update(secret.getBytes());
      byte[] digest = md.digest();</Snippet>
<TargetFunction>getInstance()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
</ReportDefinition>
