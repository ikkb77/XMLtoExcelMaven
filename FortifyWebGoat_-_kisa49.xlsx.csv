위험도,폴더,대분류,취약점,위험인자 진입 파일경로,위험인자 진입 파일명,위험인자 진입 라인넘버,위험인자 진입 소스조각,위험인자 진입 함수,취약점 탐지 파일경로,취약점 탐지 파일명,취약점 탐지 라인넘버,취약점 탐지 소스조각,취약점 탐지 함수,취약점 이슈 개요,취약점 개요,취약점 설명,취약점 조치 권고내용,취약점 조치 tip,취약점 이슈 고유키,취약점 rule 고유키,auditor 태그,auditor 아이디,auditor 의견,스캔시간,
High,High,API Abuse,<none>,,,,,,"src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java","MissingFunctionACUsers.java",90,"    @PostMapping(path = {""access-control/users"", ""access-control/users-admin-fix""}, consumes = ""application/json"", produces = ""application/json"")
    @ResponseBody
    public User addUser(@RequestBody User newUser) {
        try {
            userRepository.save(newUser);",Function: addUser(),"모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",82BB8D697F115857B713413814A6989F,66F1C785-3EDF-4CF2-9217-3275D7BC5DB7,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,,,,,,"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",202,"            </i>
          </span>
                                        <input class=""form-control"" placeholder=""Password"" name=""password""
                                               type=""password""
                                               value="""" required=""""/>",Function: addUser(),"PasswordReset.html의 형식은 202 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1FD01115EAF3814E42D3ACAD5387EC79,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,,,,,,"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",35,"                <input name=""secQuestion1"" value="""" type=""TEXT"" /><br/><br />

                <input type=""hidden"" name=""jsEnabled"" value=""1"" />
                <input type=""hidden"" name=""verifyMethod"" value=""SEC_QUESTIONS"" />
                <input type=""hidden"" name=""userId"" value=""12309746"" />",Function: addUser(),"숨겨진 폼 필드가 AuthBypass.html의 35 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6D5,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",68,"            }

            query.setInt(1, count);
            //String query = ""SELECT * FROM user_data WHERE Login_Count = "" + login_count + "" and userid = "" + accountName, ;
            try {","java.sql.PreparedStatement.setInt()","적절한 access control 없이 SqlInjectionLesson5b.java의 injectableQuery() 메서드는 공격자가 제어하는 기본 키를 포함하는 68 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",12DA5F1B7A151B80B29B76F952FCEE61,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",59,"			request.getSession().setAttribute(""keyPair"", keyPair);
		}
		return privateKey;
    }
	",Read privateKey(),"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",59,"			request.getSession().setAttribute(""keyPair"", keyPair);
		}
		return privateKey;
    }
	",Return privateKey(),"SigningAssignment.java의 getPrivateKey() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",A2235C48B1F31D614FB7FF0C10EF2E72,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","SqlInjectionLesson2.java",55,"    @PostMapping(""/SqlInjection/attack2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","SqlInjectionLesson2.java",62,"        try (var connection = dataSource.getConnection()) {
            Statement statement = connection.createStatement(TYPE_SCROLL_INSENSITIVE, CONCUR_READ_ONLY);
            ResultSet results = statement.executeQuery(query);
            StringBuilder output = new StringBuilder();
","java.sql.Statement.executeQuery()","SqlInjectionLesson2.java의 62 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",A95E4E2C2316D4086848A23257634FE0,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java","SqlInjectionChallengeLogin.java",46,"    @PostMapping(""/SqlInjectionAdvanced/challenge_Login"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        try (var connection = dataSource.getConnection()) {
            var statement = connection.prepareStatement(""select password from sql_challenge_users where userid = ? and password = ?"");",login(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java","SqlInjectionChallengeLogin.java",49,"        try (var connection = dataSource.getConnection()) {
            var statement = connection.prepareStatement(""select password from sql_challenge_users where userid = ? and password = ?"");
            statement.setString(1, username_login);
            statement.setString(2, password_login);
            var resultSet = statement.executeQuery();","java.sql.PreparedStatement.setString()","적절한 access control 없이 SqlInjectionChallengeLogin.java의 login() 메서드는 공격자가 제어하는 기본 키를 포함하는 49 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",87FE0E2A4E81E33E835542D4B734FC46,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java","SqlInjectionChallengeLogin.java",46,"    @PostMapping(""/SqlInjectionAdvanced/challenge_Login"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        try (var connection = dataSource.getConnection()) {
            var statement = connection.prepareStatement(""select password from sql_challenge_users where userid = ? and password = ?"");",login(0),"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",51,"
                <p>Password:</p>
                <input name=""newPassword"" value="""" type=""password"" /><br/>

                <p>Confirm Password:</p>","java.sql.PreparedStatement.setString()","AuthBypass.html의 형식은 51 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F26FE4CAF8C7528EED062E6D872E7BA1,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java","SqlInjectionChallengeLogin.java",46,"    @PostMapping(""/SqlInjectionAdvanced/challenge_Login"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        try (var connection = dataSource.getConnection()) {
            var statement = connection.prepareStatement(""select password from sql_challenge_users where userid = ? and password = ?"");",login(0),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",77,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","java.sql.PreparedStatement.setString()","Challenge6.html의 형식은 77 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F93F98330B2AC2A31772911B07034F69,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","org.springframework.web.servlet.ModelAndView.addObject()","LandingAssignment.java의 openPasswordReset() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5A2131394207A3E41CFE97F1313E20B1,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",160,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordRemoveUserInput"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>","org.springframework.web.servlet.ModelAndView.addObject()","PathTraversal.html의 형식은 160 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD13,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",84,"
        } catch (Exception e) {
            System.err.println(e.getMessage());
            return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",C50CAE221F5766FF6BE7A3844D2AA685,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",24,"                    

                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail/reset"">",FunctionCall: println(),"입력 폼 필드의 HTML5 검증이 비활성화됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",363F98CA35057374D036AE8628932F5F,F9E9799A-2A81-4BFE-837D-17F73AC1EDD6,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java","Assignment1Test.java",82,"
//    @Test
//    public void correctPasswordXForwardHeaderMissing() throws Exception {
//        mockMvc.perform(MockMvcRequestBuilders.post(""/challenge/1"")
//                .param(""username"", ""admin"")",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F34F47B45E6C809E174D70B7674B2BA3,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/java/org/owasp/webgoat/lessons/jwt/JWTFinalEndpoint.java","JWTFinalEndpoint.java",94,"                        final String kid = (String) header.get(""kid"");
                        try (var connection = dataSource.getConnection()) {
                            ResultSet rs = connection.createStatement().executeQuery(""SELECT key FROM jwt_keys WHERE id = '"" + kid + ""'"");
                            while (rs.next()) {
                                return TextCodec.BASE64.decode(rs.getString(1));",executeQuery(),"JWTFinalEndpoint.java의 94 줄에서 resolveSigningKeyBytes() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8F8E8BBEF7DF2A9BDBAD6E0304E80EF4,4B673A45-9AD5-4CBA-945B-11A3702CDF57,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/resources/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",14,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <input type=""hidden"" id=""user_id"" value=""102""/>
        <!-- using attack-form class on your form, will allow your request to be ajaxified and stay within the display framework for webgoat -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form""",executeQuery(),"숨겨진 폼 필드가 ClientSideFiltering.html의 14 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5F4950CF24C4A51AC52C8EF229E29C00,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java","WebSecurityConfig.java",60,"
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry security = http
                .authorizeRequests()",Function: configure(),"CSP(Content Security Policy)가 구성되지 않았습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DECC9FB4111A7C8A2CDFE634EC5E5026,46B482B2-3EA4-4634-8ECA-BD7C83C7E84C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",63,"        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);
        modelAndView.addObject(""uniqueCode"", StringUtils.reverse(getWebSession().getUserName()));
","Read this.landingPageUrl()","src/main/resources/lessons/bypassrestrictions/html/BypassRestrictions.html","BypassRestrictions.html",108,"                <textarea cols=""25"" name=""field7"" rows=""1"">301-604-4882</textarea>
            </div>
            <input type=""hidden"" value="""" name=""error""/>
            <p>
                <button type=""submit"" class=""btn btn-primary"">Submit</button>",Function: configure(),"숨겨진 폼 필드가 BypassRestrictions.html의 108 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DB2AF756C50DF0B08BB75222C29AECE7,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java","SqlOnlyInputValidationOnKeywords.java",48,"    @PostMapping(""/SqlOnlyInputValidationOnKeywords/attack"")
    @ResponseBody
    public AttackResult attack(@RequestParam(""userid_sql_only_input_validation_on_keywords"") String userId) {
        userId = userId.toUpperCase().replace(""FROM"", """").replace(""SELECT"", """");
        if (userId.contains("" "")) {",attack(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",67,"            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.CONCUR_READ_ONLY)) {
                ResultSet results = statement.executeQuery(query);

                if ((results != null) && results.first()) {","java.sql.Statement.executeQuery()","SqlInjectionLesson6a.java의 67 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",9EAB8D48586C3E656E1204CEAE97FC5D,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java","SqlOnlyInputValidationOnKeywords.java",48,"    @PostMapping(""/SqlOnlyInputValidationOnKeywords/attack"")
    @ResponseBody
    public AttackResult attack(@RequestParam(""userid_sql_only_input_validation_on_keywords"") String userId) {
        userId = userId.toUpperCase().replace(""FROM"", """").replace(""SELECT"", """");
        if (userId.contains("" "")) {",attack(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",51,"                <script th:src=""@{/lesson_js/assignment10b.js}"" type=""text/javascript"" charset=""utf-8""></script>
            </div>
            <input type=""hidden"" name=""editor""/>
            <div class=""input-group"" style=""position: absolute; top: 310px;"">
                <button class=""btn btn-primary"" type=""submit"">Submit</button>","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 SqlInjectionMitigations.html의 51 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",CDEFD3ABA14086B585AA86ABF8AF7E2F,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"		if (basicAuth == null) {
			String password = HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
			basicAuth = getBasicAuth(username, password);
			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}",Read password(),"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",145,"        Locale browserLocale = (Locale) request.getSession().getAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME);
        if (null != browserLocale) {
            log.debug(""browser locale {}"", browserLocale);
            return browserLocale.getLanguage();
        } else {","org.slf4j.Logger.debug()","AsciiDoctorTemplateResolver.java의 determineLanguage() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F97D18FD7BA6A30FB205CA279EF6BDC1,BAADF2C8-89C1-415D-BAA0-7FA62199BC83,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"		if (basicAuth == null) {
			String password = HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
			basicAuth = getBasicAuth(username, password);
			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}",Read password(),"target/classes/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",88,"                  action=""/WebGoat/clientSideFiltering/getItForFree"">

                <input id=""discount"" type=""hidden"" value=""0""/>
                <div class=""row"">
","org.slf4j.Logger.debug()","숨겨진 폼 필드가 ClientSideFiltering.html의 88 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5F4950CF24C4A51AC52C8EF229E29C05,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",64,"    @PostMapping(""/crypto/signing/verify"")
    @ResponseBody
    public AttackResult completed(HttpServletRequest request, @RequestParam String modulus, @RequestParam String signature) {
		
		String tempModulus = modulus;/* used to validate the modulus of the public key but might need to be corrected */",completed(1),"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",73,"		}
		if (!DatatypeConverter.printHexBinary(rsaPubKey.getModulus().toByteArray()).equals(tempModulus.toUpperCase())) {
			log.warn(""modulus {} incorrect"", modulus);
			return failed(this).feedback(""crypto-signing.modulusnotok"").build();
		}","org.slf4j.Logger.warn()","SigningAssignment.java의 completed() 메서드는 확인되지 않은 사용자 입력을 73 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",03AA2F22B55EBDD14670CBC403D68368,9667C493-BADE-4668-87D9-BF3CCA799FD9,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",64,"    @PostMapping(""/crypto/signing/verify"")
    @ResponseBody
    public AttackResult completed(HttpServletRequest request, @RequestParam String modulus, @RequestParam String signature) {
		
		String tempModulus = modulus;/* used to validate the modulus of the public key but might need to be corrected */",completed(1),"target/classes/webgoat/templates/login.html","login.html",39,"                <div class=""form-group"">
                    <label for=""exampleInputPassword1"" th:text=""#{password}"">Password</label>
                    <input type=""password"" class=""form-control"" id=""exampleInputPassword1"" th:placeholder=""#{password}""
                           name='password' />
                </div>","org.slf4j.Logger.warn()","login.html의 형식은 39 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DA87A9C902D54BAADFCA48C96419F2F3,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",62,"            query = ""SELECT * FROM user_data WHERE first_name = 'John' and last_name = '"" + accountName + ""'"";
            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
                ResultSet results = statement.executeQuery(query);

                if ((results != null) && (results.first())) {","java.sql.Statement.executeQuery()","SqlInjectionLesson5a.java의 62 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8314159B7C4111BF8FD08A643E68F862,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"target/classes/lessons/challenges/html/Challenge7.html","Challenge7.html",49,"                                        </div>

                                        <input type=""hidden"" class=""hide"" name=""token"" id=""token"" value=""""/>
                                    </form>
","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 Challenge7.html의 49 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",75600F22027A5E2C274C88ADB1F5ACD1,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",51,"                <script th:src=""@{/lesson_js/assignment10b.js}"" type=""text/javascript"" charset=""utf-8""></script>
            </div>
            <input type=""hidden"" name=""editor""/>
            <div class=""input-group"" style=""position: absolute; top: 310px;"">
                <button class=""btn btn-primary"" type=""submit"">Submit</button>","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 SqlInjectionMitigations.html의 51 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",CDEFD3ABA14086B585AA86ABF8AF7E30,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",77,"                }
            } catch (SQLException e) {
                System.err.println(e.getMessage());
                return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
            }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",C50CAE221F5766FF6BE7A3844D2AA684,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",133,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>",FunctionCall: println(),"SqlInjectionAdvanced.html의 형식은 133 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7C9548FA80341DC23622D7D388D93DA,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"src/main/resources/webwolf/templates/registration.html","registration.html",39,"                    password</label>
                <div class=""col-sm-4"">
                    <input type=""password"" class=""form-control"" id=""matchingPassword"" placeholder=""Password""
                           name='matchingPassword' th:value=""*{matchingPassword}""/>
                </div>",FunctionCall: println(),"registration.html의 형식은 39 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549BF,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(1),"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",54,"
                <p>Confirm Password:</p>
                <input name=""newPasswordConfirm"" value="""" type=""password"" /><br/><br />

                <input type=""hidden"" name=""userId"" value=""12309746"" />",FunctionCall: println(),"AuthBypass.html의 형식은 54 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F26FE4CAF8C7528EED062E6D872E7BA2,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/container/users/RegistrationController.java","RegistrationController.java",35,"
    @PostMapping(""/register.mvc"")
    public String registration(@ModelAttribute(""userForm"") @Valid UserForm userForm, BindingResult bindingResult, HttpServletRequest request) throws ServletException {
        userValidator.validate(userForm, bindingResult);
",registration(0),"src/main/java/org/owasp/webgoat/container/users/UserService.java","UserService.java",52,"
    private void createLessonsForUser(WebGoatUser webGoatUser) {
        jdbcTemplate.execute(""CREATE SCHEMA \"""" + webGoatUser.getUsername() + ""\"" authorization dba"");
        flywayLessons.apply(webGoatUser.getUsername()).migrate();
    }","org.springframework.jdbc.core.JdbcTemplate.execute()","UserService.java의 52 줄에서 createLessonsForUser() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1D825C99ACE0C93AE13D3AE15E31A0C0,F911204F-8028-4FFE-A1FE-2039F8A64B45,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/container/users/RegistrationController.java","RegistrationController.java",35,"
    @PostMapping(""/register.mvc"")
    public String registration(@ModelAttribute(""userForm"") @Valid UserForm userForm, BindingResult bindingResult, HttpServletRequest request) throws ServletException {
        userValidator.validate(userForm, bindingResult);
",registration(0),"target/classes/webwolf/templates/registration.html","registration.html",39,"                    password</label>
                <div class=""col-sm-4"">
                    <input type=""password"" class=""form-control"" id=""matchingPassword"" placeholder=""Password""
                           name='matchingPassword' th:value=""*{matchingPassword}""/>
                </div>","org.springframework.jdbc.core.JdbcTemplate.execute()","registration.html의 형식은 39 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549C3,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",65,"                Statement checkStatement = connection.createStatement(TYPE_SCROLL_INSENSITIVE,
                        CONCUR_READ_ONLY);
                statement.executeUpdate(query);
                ResultSet results = checkStatement.executeQuery(""SELECT * FROM employees WHERE last_name='Barnett';"");
                StringBuilder output = new StringBuilder();","java.sql.Statement.executeUpdate()","SqlInjectionLesson3.java의 65 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F0C8E5A5EB7D1749BA1E248DF7710239,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"target/classes/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",22,"            <script th:src=""@{/lesson_js/clientSideFiltering.js}""
                    language=""JavaScript""></script>
            <input id=""userID"" value=""101"" name=""userID"" type=""HIDDEN""/>
            <div id=""lesson_wrapper"">
                <div id=""lesson_header""></div>","java.sql.Statement.executeUpdate()","숨겨진 폼 필드가 ClientSideFiltering.html의 22 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5F4950CF24C4A51AC52C8EF229E29C04,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"target/classes/lessons/ssrf/html/SSRF.html","SSRF.html",40,"                <table>
                    <tr>
                        <td><input type=""hidden"" id=""url2"" name=""url"" value=""images/cat.png""/></td>

                        <td><input","java.sql.Statement.executeUpdate()","숨겨진 폼 필드가 SSRF.html의 40 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E6F8598ADC56CACB263A11487CB5FCBB,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java","Assignment1Test.java",85,"//        mockMvc.perform(MockMvcRequestBuilders.post(""/challenge/1"")
//                .param(""username"", ""admin"")
//                .param(""password"", SolutionConstants.PASSWORD))
//                .andExpect(jsonPath(""$.feedback"", CoreMatchers.is(messages.getMessage(""ip.address.unknown""))))
//                .andExpect(jsonPath(""$.lessonCompleted"", CoreMatchers.is(false)));",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",C7D050E3851B8DCDA95D9C1863C41210,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",53,"    @PostMapping(""/SqlInjectionMitigations/attack12a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String ip) {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(""select ip from servers where ip = ? and hostname = ?"")) {",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",56,"        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(""select ip from servers where ip = ? and hostname = ?"")) {
            preparedStatement.setString(1, ip);
            preparedStatement.setString(2, ""webgoat-prd"");
            ResultSet resultSet = preparedStatement.executeQuery();","java.sql.PreparedStatement.setString()","적절한 access control 없이 SqlInjectionLesson13.java의 completed() 메서드는 공격자가 제어하는 기본 키를 포함하는 56 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4CD9946DDA17EFB4514516D6450229B2,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",53,"    @PostMapping(""/SqlInjectionMitigations/attack12a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String ip) {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(""select ip from servers where ip = ? and hostname = ?"")) {",completed(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",103,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordFix"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>","java.sql.PreparedStatement.setString()","PathTraversal.html의 형식은 103 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD12,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",53,"    @PostMapping(""/SqlInjectionMitigations/attack12a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String ip) {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(""select ip from servers where ip = ? and hostname = ?"")) {",completed(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",54,"
                <p>Confirm Password:</p>
                <input name=""newPasswordConfirm"" value="""" type=""password"" /><br/><br />

                <input type=""hidden"" name=""userId"" value=""12309746"" />","java.sql.PreparedStatement.setString()","AuthBypass.html의 형식은 54 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F26FE4CAF8C7528EED062E6D872E7BA4,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",53,"    @PostMapping(""/SqlInjectionMitigations/attack12a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String ip) {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(""select ip from servers where ip = ? and hostname = ?"")) {",completed(0),"src/main/resources/webgoat/templates/login.html","login.html",39,"                <div class=""form-group"">
                    <label for=""exampleInputPassword1"" th:text=""#{password}"">Password</label>
                    <input type=""password"" class=""form-control"" id=""exampleInputPassword1"" th:placeholder=""#{password}""
                           name='password' />
                </div>","java.sql.PreparedStatement.setString()","login.html의 형식은 39 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DA87A9C902D54BAADFCA48C96419F2F2,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(2),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",77,"                    preparedStatement.setString(1, username_reg);
                    preparedStatement.setString(2, email_reg);
                    preparedStatement.setString(3, password_reg);
                    preparedStatement.execute();
                    attackResult = success(this).feedback(""user.created"").feedbackArgs(username_reg).build();","java.sql.PreparedStatement.setString()","적절한 access control 없이 SqlInjectionChallenge.java의 registerNewUser() 메서드는 공격자가 제어하는 기본 키를 포함하는 77 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",78D79E403BDBE07F3BD264BD0580ADA9,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(2),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",63,"                                <div class=""form-group input-group"">
                                    <span class=""input-group-addon""><i class=""glyphicon glyphicon-lock""></i></span>
                                    <input class=""form-control"" placeholder=""Password"" name=""password""
                                           type=""password"" value=""""/>
                                </div>","java.sql.PreparedStatement.setString()","PasswordReset.html의 형식은 63 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1FD01115EAF3814E42D3ACAD5387EC76,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(2),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",48,"                        </div>
                    </form>
                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail"">","java.sql.PreparedStatement.setString()","입력 폼 필드의 HTML5 검증이 비활성화됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",363F98CA35057374D036AE8628932F62,F9E9799A-2A81-4BFE-837D-17F73AC1EDD6,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(2),"src/main/resources/lessons/insecurelogin/html/InsecureLogin.html","InsecureLogin.html",31,"
                <input type=""text"" value="""" name=""username"" placeholder=""username""/>
                <input type=""password"" value="""" name=""password"" placeholder=""password"" />
                <input type=""submit"" value=""Submit"" />
","java.sql.PreparedStatement.setString()","InsecureLogin.html의 형식은 31 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",20EDE9B5A34C45AAB00BFAAD12F8119B,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(2),"target/classes/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",17,"                <div class=""form-group"">
                    <label for=""password"" class=""control-label"">Password</label>
                    <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                           name='password'/>
                </div>","java.sql.PreparedStatement.setString()","webwolfPasswordReset.html의 폼은 17 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",55D1A18A9BD791C88450CC9ADDC6F9AB,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",80,"    @PostMapping(path = ""xxe/blind"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult addComment(@RequestBody String commentStr) {
        var fileContentsForUser = userToFileContents.getOrDefault(getWebSession().getUser(), """");
",addComment(0),"src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",102,"        }

        var xsr = xif.createXMLStreamReader(new StringReader(xml));

        var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:102에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E20AAD6B15A5EECE50536DCE8059DA53,6A059AF5-3228-448E-8BD8-469EAAC6C44E,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",138,"        try {
            Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());","java.sql.Statement.executeUpdate()","SqlInjectionLesson8.java의 138 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2FCCFCD72BC9F30C2178EBDB9A1CAF02,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",63,"        try (Connection connection = dataSource.getConnection()) {
            try (Statement statement = connection.createStatement(TYPE_SCROLL_INSENSITIVE, CONCUR_READ_ONLY)) {
                statement.executeUpdate(query);
                connection.commit();
                ResultSet results = statement.executeQuery(""SELECT phone from employees;"");","java.sql.Statement.executeUpdate()","SqlInjectionLesson4.java의 63 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F4D9FB48336E207FE2E2418D6367AD9C,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"target/classes/lessons/passwordreset/templates/password_reset.html","password_reset.html",15,"                <h2 class=""sign_up_title"">Reset your password</h2>
                    <div class=""form-group"" th:classappend=""${#fields.hasErrors('password')}? 'has-error'"">
                        <input type=""hidden"" name=""resetLink"" th:field=""*{resetLink}"" />
                        <label for=""password"" class=""control-label"" th:text=""#{password}"">Password</label>
                        <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""","java.sql.Statement.executeUpdate()","숨겨진 폼 필드가 password_reset.html의 15 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DE6A19D6A740E2496DCE04D77527D499,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",58,"        String queryString = ""SELECT * From user_data WHERE Login_Count = ? and userid= "" + accountName;
        try (Connection connection = dataSource.getConnection()) {
            PreparedStatement query = connection.prepareStatement(queryString, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);

            int count = 0;","java.sql.Connection.prepareStatement()","SqlInjectionLesson5b.java의 58 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FE45DF42DBC098DDCE0124FCCDA0E5C2,5870A527-08AF-452C-84B2-7F6C360CA7EF,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java","LabelAndHintIntegrationTest.java",137,"                System.out.println(""actual:""+jsonPath.getString(ESCAPE_JSON_PATH_CHAR+key+ESCAPE_JSON_PATH_CHAR));
                System.out.println(""expected: ""+propsLang.getProperty(key));
                System.out.println();
                Assertions.fail();
            }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",411644EDC6701B894A157BC26D4AA38B,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",258,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordZipSlip"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FunctionCall: println(),"PathTraversal.html의 형식은 258 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD18,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java","LabelAndHintIntegrationTest.java",130,"        for (String key: propsLang.stringPropertyNames()) {
            if (!propsDefault.containsKey(key)) {
                System.err.println(""key: "" + key + "" in ("" +lang+"") is missing from default properties"");
                Assertions.fail();
            }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5C7FBE7ACFCD999EFBD41C8B534FCC64,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"target/classes/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",57,"                });
            </script>
            <input type=""hidden"" name=""networkNum"" id=""networkNum"" value=""foo"" />
            <table>
                <tr>",FunctionCall: println(),"숨겨진 폼 필드가 ChromeDevTools.html의 57 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4D4E3F29FD6DBA7A281702847EA47ECB,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",36,"
                <input type=""hidden"" name=""jsEnabled"" value=""1"" />
                <input type=""hidden"" name=""verifyMethod"" value=""SEC_QUESTIONS"" />
                <input type=""hidden"" name=""userId"" value=""12309746"" />
",FunctionCall: println(),"숨겨진 폼 필드가 AuthBypass.html의 36 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6DA,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",51,"    @PostMapping(""/SqlInjection/assignment5b"")
    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }",completed(0),"src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java","Assignment1Test.java",95,"//                .header(""X-Forwarded-For"", ""127.0.1.2"")
//                .param(""username"", ""admin"")
//                .param(""password"", SolutionConstants.PASSWORD))
//                .andExpect(jsonPath(""$.feedback"", CoreMatchers.is(messages.getMessage(""ip.address.unknown""))))
//                .andExpect(jsonPath(""$.lessonCompleted"", CoreMatchers.is(false)));",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",C7D050E3851B8DCDA95D9C1863C41211,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",76,"        		.filter(t -> allowedTrace(t, user))
                .map(t -> new Tracert(t.getTimestamp(), path(t), toJsonString(t))).collect(toList());
        model.addObject(""traces"", traces);

        return model;","org.springframework.web.servlet.ModelAndView.addObject()","Requests.java의 get() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",63A9C4C9750CF172334B4D00100A8FFE,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",100,"                return false;
            } else {
                System.err.println(e.getMessage());
                return false;
            }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",96A478F4925CFE19357D40F157F55A1E,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",53,"    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --
    }
",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E9A4128E90D097A6022B1E631A1511CE,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"target/classes/lessons/challenges/html/Challenge1.html","Challenge1.html",30,"                        <div class=""form-group"">
                            <label for=""exampleInputPassword1"" th:text=""#{password}"">Password</label>
                            <input type=""password"" class=""form-control"" id=""exampleInputPassword1""
                                   placeholder=""Password""
                                   name='password'/>",Comment(),"Challenge1.html의 형식은 30 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",05039B3043CF0D3BE2063667E37DBE2E,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",56,"                <input name=""newPasswordConfirm"" value="""" type=""password"" /><br/><br />

                <input type=""hidden"" name=""userId"" value=""12309746"" />

                <input name=""submit"" value=""Submit"" type=""submit""/>",Comment(),"숨겨진 폼 필드가 AuthBypass.html의 56 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6DC,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java","LabelAndHintIntegrationTest.java",136,"                System.out.println(""key: "" + key + "" in ("" +lang+"") has incorrect translation in label service"");
                System.out.println(""actual:""+jsonPath.getString(ESCAPE_JSON_PATH_CHAR+key+ESCAPE_JSON_PATH_CHAR));
                System.out.println(""expected: ""+propsLang.getProperty(key));
                System.out.println();
                Assertions.fail();",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",62F86F2F8137D833B577D020F9DBAE60,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(0),"target/classes/webgoat/templates/registration.html","registration.html",41,"                        <label for=""password"" class=""col-sm-2 control-label"" th:text=""#{password}"">Password</label>
                        <div class=""col-sm-4"">
                            <input type=""password"" class=""form-control"" id=""password"" th:placeholder=""#{password}""
                                   name='password' th:value=""*{password}""/>
                        </div>",FunctionCall: println(),"registration.html의 형식은 41 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549C0,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java","Servers.java",68,"    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    public List<Server> sort(@RequestParam String column) throws Exception {
        List<Server> servers = new ArrayList<>();
",sort(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java","Servers.java",72,"
        try (var connection = dataSource.getConnection()) {
            try (var statement = connection.prepareStatement(""select id, hostname, ip, mac, status, description from SERVERS where status <> 'out of order' order by "" + column)) {
                try (var rs = statement.executeQuery()) {
                    while (rs.next()) {","java.sql.Connection.prepareStatement()","Servers.java의 72 줄에서 sort() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",67D43BA273CF03F2493177A252A49395,5870A527-08AF-452C-84B2-7F6C360CA7EF,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java","Servers.java",68,"    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    public List<Server> sort(@RequestParam String column) throws Exception {
        List<Server> servers = new ArrayList<>();
",sort(0),"target/classes/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",50,"				<script th:src=""@{/lesson_js/assignment4.js}"" type=""text/javascript"" charset=""utf-8""></script>
			</div>
			<input type=""hidden"" name=""editor2""/>
			<div class=""input-group"" style=""position: absolute; top: 365px;"">
				<button class=""btn btn-primary"" type=""submit"">Submit</button>","java.sql.Connection.prepareStatement()","숨겨진 폼 필드가 CrossSiteScriptingMitigation.html의 50 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",81A26F15DA840732342EB9C7130C7F0D,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(2),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",62,"            query = ""SELECT * FROM user_data WHERE first_name = 'John' and last_name = '"" + accountName + ""'"";
            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
                ResultSet results = statement.executeQuery(query);

                if ((results != null) && (results.first())) {","java.sql.Statement.executeQuery()","SqlInjectionLesson5a.java의 62 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",46BC2D367EBCFDEA0966E114C8607DB8,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",59,"        }
        try (var connection = dataSource.getConnection()) {
            PreparedStatement statement = connection.prepareStatement(""select password from challenge_users where userid = '"" + username_login + ""' and password = '"" + password_login + ""'"");
            ResultSet resultSet = statement.executeQuery();
","java.sql.Connection.prepareStatement()","Assignment5.java의 59 줄에서 login() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",12FBD812EE5474630BFA107DA592E31A,5870A527-08AF-452C-84B2-7F6C360CA7EF,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"target/classes/lessons/insecurelogin/html/InsecureLogin.html","InsecureLogin.html",31,"
                <input type=""text"" value="""" name=""username"" placeholder=""username""/>
                <input type=""password"" value="""" name=""password"" placeholder=""password"" />
                <input type=""submit"" value=""Submit"" />
","java.sql.Connection.prepareStatement()","InsecureLogin.html의 형식은 31 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",20EDE9B5A34C45AAB00BFAAD12F8119C,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"target/classes/lessons/hijacksession/templates/hijackform.html","hijackform.html",16,"					<div class=""form-group input-group"">
						<span class=""input-group-addon""><i
							class=""glyphicon glyphicon-lock""></i></span> <input class=""form-control""
							placeholder=""Password"" name=""password"" type=""password"" />
					</div>","java.sql.Connection.prepareStatement()","hijackform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8E778A7762E99826CA67E0A83B2E4C26,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",30,"                    <td>user/pass</td>
                    <td>user:<input name=""username"" value="""" type=""TEXT"" /></td>
                    <td>pass:<input name=""password"" value="""" type=""password"" /></td>
                    <td>
                        <input","java.sql.Connection.prepareStatement()","IDOR.html의 형식은 30 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",3ED6FCD911BC7513ED7B5603956AD522,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"src/main/resources/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",50,"				<script th:src=""@{/lesson_js/assignment4.js}"" type=""text/javascript"" charset=""utf-8""></script>
			</div>
			<input type=""hidden"" name=""editor2""/>
			<div class=""input-group"" style=""position: absolute; top: 365px;"">
				<button class=""btn btn-primary"" type=""submit"">Submit</button>","java.sql.Connection.prepareStatement()","숨겨진 폼 필드가 CrossSiteScriptingMitigation.html의 50 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",81A26F15DA840732342EB9C7130C7F0B,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"target/classes/lessons/passwordreset/templates/password_reset.html","password_reset.html",17,"                        <input type=""hidden"" name=""resetLink"" th:field=""*{resetLink}"" />
                        <label for=""password"" class=""control-label"" th:text=""#{password}"">Password</label>
                        <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                               name='password' th:value=""*{password}""/>
                        <span th:if=""${#fields.hasErrors('password')}"" th:errors=""*{password}"">Password error</span>","java.sql.Connection.prepareStatement()","password_reset.html의 형식은 17 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4527DD070AD14C14AACC180940E12BC3,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(0),"src/main/resources/webwolf/templates/registration.html","registration.html",30,"                <label for=""password"" class=""col-sm-2 control-label"" th:text=""#{password}"">Password</label>
                <div class=""col-sm-4"">
                    <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                           name='password' th:value=""*{password}""/>
                </div>","java.sql.Connection.prepareStatement()","registration.html의 형식은 30 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549BE,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java","SqlInjectionChallengeLogin.java",46,"    @PostMapping(""/SqlInjectionAdvanced/challenge_Login"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        try (var connection = dataSource.getConnection()) {
            var statement = connection.prepareStatement(""select password from sql_challenge_users where userid = ? and password = ?"");",login(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallengeLogin.java","SqlInjectionChallengeLogin.java",50,"            var statement = connection.prepareStatement(""select password from sql_challenge_users where userid = ? and password = ?"");
            statement.setString(1, username_login);
            statement.setString(2, password_login);
            var resultSet = statement.executeQuery();
","java.sql.PreparedStatement.setString()","적절한 access control 없이 SqlInjectionChallengeLogin.java의 login() 메서드는 공격자가 제어하는 기본 키를 포함하는 50 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4BC169646D09490A78AB5E8A500EB381,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",38,"
        var newdiv = document.createElement(""div"");
        newdiv.innerHTML = html;
        var container = document.getElementById(""hiddenEmployeeRecords"");
        container.appendChild(newdiv);","Assignment to newdiv.innerHTML()","clientSideFiltering.js 파일은 38 줄의 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우가 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",9FE7635289F1960D5327A6F4312523F0,C4FCEF97-FF0A-4683-8B29-5B0E5AEE65570,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",37,"                <input type=""hidden"" name=""jsEnabled"" value=""1"" />
                <input type=""hidden"" name=""verifyMethod"" value=""SEC_QUESTIONS"" />
                <input type=""hidden"" name=""userId"" value=""12309746"" />

                <input name=""submit"" value=""Submit"" type=""submit""/>","Assignment to newdiv.innerHTML()","숨겨진 폼 필드가 AuthBypass.html의 37 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6D7,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/resources/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",17,"                <div class=""form-group"">
                    <label for=""password"" class=""control-label"">Password</label>
                    <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                           name='password'/>
                </div>","Assignment to newdiv.innerHTML()","webwolfPasswordReset.html의 형식은 17 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",7F60C92EC10E172362680C722397D986,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",38,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_login"" id=""password4"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","Assignment to newdiv.innerHTML()","Challenge6.html의 형식은 38 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F93F98330B2AC2A31772911B07034F68,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"target/classes/webwolf/templates/registration.html","registration.html",30,"                <label for=""password"" class=""col-sm-2 control-label"" th:text=""#{password}"">Password</label>
                <div class=""col-sm-4"">
                    <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                           name='password' th:value=""*{password}""/>
                </div>","Assignment to newdiv.innerHTML()","registration.html의 형식은 30 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549C2,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/resources/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",64,"						webgoat.customjs.assignRandomVal();
					</script>
					<input type=""hidden"" name=""magic_num"" id=""magic_num"" value=""foo"" />
					<table>
						<tr>","Assignment to newdiv.innerHTML()","숨겨진 폼 필드가 HttpBasics.html의 64 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8BA31261E60311C8E10B6F0B3EAC9B88,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",38,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_login"" id=""password4"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","Assignment to newdiv.innerHTML()","Challenge6.html의 형식은 38 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F93F98330B2AC2A31772911B07034F65,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java","WebSecurityConfig.java",56,"                .antMatchers(""/css/**"", ""/images/**"", ""/js/**"", ""/fonts/**"", ""/webjars/**"", ""/home"").permitAll()
                .antMatchers(HttpMethod.GET, ""/mail/**"", ""/requests/**"").authenticated()
                .antMatchers(""/files"").authenticated()
                .anyRequest().permitAll();
        security.and().csrf().disable().formLogin()",FunctionCall: antMatchers(),"Spring Security가 잘못된 요청 선택기를 사용하여 경로를 보호합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",7D84B5F913F0A01063486A092B700032,07600237-7319-4A07-9780-0091AA759FB9,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",66,"                Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
                log(connection, query);
                ResultSet results = statement.executeQuery(query);

                if (results.getStatement() != null) {","java.sql.Statement.executeQuery()","SqlInjectionLesson8.java의 66 줄에서 injectableQueryConfidentiality() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",A115AB9AF8BB4D2B3C3309EC643177FA,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java","SecurePasswordsAssignment.java",51,"
        output.append(""<b>Your Password: *******</b></br>"");
        output.append(""<b>Length: </b>"" + password.length() + ""</br>"");
        output.append(""<b>Estimated guesses needed to crack your password: </b>"" + df.format(strength.getGuesses()) + ""</br>"");
        output.append(""<div style=\""float: left;padding-right: 10px;\""><b>Score: </b>"" + strength.getScore() + ""/4 </div>"");",Read password(),"src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java","SecurePasswordsAssignment.java",76,"            return success(this).feedback(""securepassword-success"").output(output.toString()).build();
        else
            return failed(this).feedback(""securepassword-failed"").output(output.toString()).build();
    }
",Return(),"SecurePasswordsAssignment.java의 completed() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",432CCB0CB50E1827E48DAEB31F1D05A6,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",75,"                } else {
                    PreparedStatement preparedStatement = connection.prepareStatement(""INSERT INTO sql_challenge_users VALUES (?, ?, ?)"");
                    preparedStatement.setString(1, username_reg);
                    preparedStatement.setString(2, email_reg);
                    preparedStatement.setString(3, password_reg);","java.sql.PreparedStatement.setString()","적절한 access control 없이 SqlInjectionChallenge.java의 registerNewUser() 메서드는 공격자가 제어하는 기본 키를 포함하는 75 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8424E6E59CA0A6A55BE70871888E021B,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/main/resources/lessons/challenges/html/Challenge1.html","Challenge1.html",30,"                        <div class=""form-group"">
                            <label for=""exampleInputPassword1"" th:text=""#{password}"">Password</label>
                            <input type=""password"" class=""form-control"" id=""exampleInputPassword1""
                                   placeholder=""Password""
                                   name='password'/>","java.sql.PreparedStatement.setString()","Challenge1.html의 형식은 30 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",05039B3043CF0D3BE2063667E37DBE2D,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/main/resources/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",14,"            <form role=""form"" method=""GET"" th:action=""${webwolfUrl}"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                <input type=""hidden"" name=""uniqueCode"" th:value=""${uniqueCode}""/>
                <div class=""form-group"">
                    <label for=""password"" class=""control-label"">Password</label>","java.sql.PreparedStatement.setString()","숨겨진 폼 필드가 webwolfPasswordReset.html의 14 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4F0374CF97C72D5FEE04BD47E6BB5A7C,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java","Assignment1Test.java",91,"
//    @Test
//    public void correctPasswordXForwardHeaderWrong() throws Exception {
//        mockMvc.perform(MockMvcRequestBuilders.post(""/challenge/1"")
//                .header(""X-Forwarded-For"", ""127.0.1.2"")",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FCECF816121EB822EBD8F5C9C0F5730D,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/it/java/org/owasp/webgoat/ProgressRaceConditionIntegrationTest.java","ProgressRaceConditionIntegrationTest.java",50,"            }
        }).count();
        System.err.println(""counted status 500: ""+countStatusCode500);
        Assertions.assertThat(countStatusCode500).isLessThanOrEqualTo((NUMBER_OF_CALLS - (NUMBER_OF_CALLS/NUMBER_OF_PARALLEL_THREADS)));
    }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7B7C21CD4008AAAC3DBE74F2860F137,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java","VulnerableTaskHolder.java",64,"                                new InputStreamReader(p.getInputStream()));
            String line = null;
            while ((line = in.readLine()) != null) {
                log.info(line);
            }",readLine(),"VulnerableTaskHolder.java의 64 줄, readLine() 호출을 사용하면 공격자가 프로그램을 중단할 수 있게 되거나 정식 사용자가 이용할 수 없게 됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",6789722AFA05BF61582C52F586F10E34,24023E22-D6C7-4D5C-B049-38B7EFC8B408,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java","LogBleedingTask.java",50,"    public void generatePassword(){
        password = UUID.randomUUID().toString();
        log.info(""Password for admin: {}"", Base64.getEncoder().encodeToString(password.getBytes(StandardCharsets.UTF_8)));
    }
","Read this.password()","src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java","LogBleedingTask.java",50,"    public void generatePassword(){
        password = UUID.randomUUID().toString();
        log.info(""Password for admin: {}"", Base64.getEncoder().encodeToString(password.getBytes(StandardCharsets.UTF_8)));
    }
","org.slf4j.Logger.info()","LogBleedingTask.java의 generatePassword() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",7096CF2041D404F4C0A8B1C9AEA614B4,BAADF2C8-89C1-415D-BAA0-7FA62199BC83,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/logging/LogBleedingTask.java","LogBleedingTask.java",50,"    public void generatePassword(){
        password = UUID.randomUUID().toString();
        log.info(""Password for admin: {}"", Base64.getEncoder().encodeToString(password.getBytes(StandardCharsets.UTF_8)));
    }
","Read this.password()","src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java","WebSecurityConfig.java",72,"    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService); //.passwordEncoder(bCryptPasswordEncoder());
    }
",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B9D97CD505CCB837D7BB8985307CCF6D,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",51,"    @PostMapping(""/SqlInjectionAdvanced/attack6a"")
    @ResponseBody
    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",67,"            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.CONCUR_READ_ONLY)) {
                ResultSet results = statement.executeQuery(query);

                if ((results != null) && results.first()) {","java.sql.Statement.executeQuery()","SqlInjectionLesson6a.java의 67 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",9E74B2D7F1DFBC0DB1F379F6F06755E3,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",51,"    @PostMapping(""/SqlInjectionAdvanced/attack6a"")
    @ResponseBody
    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",77,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","java.sql.Statement.executeQuery()","Challenge6.html의 폼은 77 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",86F954F8F76C97C6C0799132759D6D32,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",51,"    @PostMapping(""/SqlInjectionAdvanced/attack6a"")
    @ResponseBody
    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --",completed(0),"target/classes/lessons/htmltampering/html/HtmlTampering.html","HtmlTampering.html",132,"                                    </div>
                                </td>
                                <input id=""Total"" name=""Total"" type=""HIDDEN"" value=""2999.99""/>
                            </tr>
                            </tbody>","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 HtmlTampering.html의 132 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8B5CBAC6FD590247173FBB86E7C9DA2A,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",51,"    @PostMapping(""/SqlInjectionAdvanced/attack6a"")
    @ResponseBody
    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",77,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","java.sql.Statement.executeQuery()","Challenge6.html의 형식은 77 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F93F98330B2AC2A31772911B07034F66,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java","SqlOnlyInputValidation.java",48,"    @PostMapping(""/SqlOnlyInputValidation/attack"")
    @ResponseBody
    public AttackResult attack(@RequestParam(""userid_sql_only_input_validation"") String userId) {
        if (userId.contains("" "")) {
            return failed(this).feedback(""SqlOnlyInputValidation-failed"").build();",attack(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",67,"            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                    ResultSet.CONCUR_READ_ONLY)) {
                ResultSet results = statement.executeQuery(query);

                if ((results != null) && results.first()) {","java.sql.Statement.executeQuery()","SqlInjectionLesson6a.java의 67 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AF4D42AECC02E7DB3FE084E346D3287A,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java","SqlOnlyInputValidation.java",48,"    @PostMapping(""/SqlOnlyInputValidation/attack"")
    @ResponseBody
    public AttackResult attack(@RequestParam(""userid_sql_only_input_validation"") String userId) {
        if (userId.contains("" "")) {
            return failed(this).feedback(""SqlOnlyInputValidation-failed"").build();",attack(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",129,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","java.sql.Statement.executeQuery()","SqlInjectionAdvanced.html의 형식은 129 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7C9548FA80341DC23622D7D388D93D9,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java","SqlOnlyInputValidation.java",48,"    @PostMapping(""/SqlOnlyInputValidation/attack"")
    @ResponseBody
    public AttackResult attack(@RequestParam(""userid_sql_only_input_validation"") String userId) {
        if (userId.contains("" "")) {
            return failed(this).feedback(""SqlOnlyInputValidation-failed"").build();",attack(0),"src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java","LabelAndHintIntegrationTest.java",135,"            if (!jsonPath.getString(ESCAPE_JSON_PATH_CHAR+key+ESCAPE_JSON_PATH_CHAR).equals(propsLang.get(key))) {
                System.out.println(""key: "" + key + "" in ("" +lang+"") has incorrect translation in label service"");
                System.out.println(""actual:""+jsonPath.getString(ESCAPE_JSON_PATH_CHAR+key+ESCAPE_JSON_PATH_CHAR));
                System.out.println(""expected: ""+propsLang.getProperty(key));
                System.out.println();",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",81217D1C8E35A28EA138EB878F585133,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",90,"            PasswordChangeForm form = new PasswordChangeForm();
            form.setResetLink(link);
            model.addAttribute(""form"", form);
            modelAndView.addObject(""form"", form);
            modelAndView.setViewName(""password_reset""); //Display html page for changing password","org.springframework.ui.Model.addAttribute()","ResetLinkAssignment.java의 resetPassword() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",7A2AD9F91A66399E36200113690B2992,D15D5B27-53F4-4F78-8DF4-2AB924496A3F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"target/classes/lessons/spoofcookie/templates/spoofcookieform.html","spoofcookieform.html",16,"					<div class=""form-group input-group"">
						<span class=""input-group-addon""><i
							class=""glyphicon glyphicon-lock""></i></span> <input class=""form-control""
							placeholder=""Password"" name=""password"" type=""password""
							id=""spoof_password"" />","org.springframework.ui.Model.addAttribute()","spoofcookieform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",D130F2D11A11036C43935126D9371122,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"src/main/resources/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",931,"};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FA1668F9C81061945FC2B459758FEFCB,9DC93E75-BA94-4FA1-A177-ED1201EB29BC,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",81,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>",Comment(),"Challenge6.html의 폼은 81 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",86F954F8F76C97C6C0799132759D6D35,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/mailbox/MailboxController.java","MailboxController.java",50,"        UserDetails user = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        ModelAndView modelAndView = new ModelAndView();
        List<Email> emails = mailboxRepository.findByRecipientOrderByTimeDesc(user.getUsername());
        if (emails != null && !emails.isEmpty()) {
            modelAndView.addObject(""total"", emails.size());","org.owasp.webgoat.webwolf.mailbox.MailboxRepository.findByRecipientOrderByTimeDesc()","src/main/java/org/owasp/webgoat/webwolf/mailbox/MailboxController.java","MailboxController.java",53,"        if (emails != null && !emails.isEmpty()) {
            modelAndView.addObject(""total"", emails.size());
            modelAndView.addObject(""emails"", emails);
        }
        modelAndView.setViewName(""mailbox"");","org.springframework.web.servlet.ModelAndView.addObject()","MailboxController.java의 mail() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1156D3BC4034E0A9A8A48E6C81485503,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/mailbox/MailboxController.java","MailboxController.java",50,"        UserDetails user = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        ModelAndView modelAndView = new ModelAndView();
        List<Email> emails = mailboxRepository.findByRecipientOrderByTimeDesc(user.getUsername());
        if (emails != null && !emails.isEmpty()) {
            modelAndView.addObject(""total"", emails.size());","org.owasp.webgoat.webwolf.mailbox.MailboxRepository.findByRecipientOrderByTimeDesc()","src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",49,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""password"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>","org.springframework.web.servlet.ModelAndView.addObject()","PathTraversal.html의 형식은 49 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD11,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",38,"
        var newdiv = document.createElement(""div"");
        newdiv.innerHTML = html;
        var container = document.getElementById(""hiddenEmployeeRecords"");
        container.appendChild(newdiv);","Assignment to newdiv.innerHTML()","clientSideFiltering.js 파일은 38 줄의 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우가 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",9FE7635289F1960D5327A6F4312523EF,C4FCEF97-FF0A-4683-8B29-5B0E5AEE65570,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java","SecurePasswordsAssignment.java",65,"            output.append(""<b>Warning: </b>"" + strength.getFeedback().getWarning() + ""</br>"");
        // possible feedback: https://github.com/dropbox/zxcvbn/blob/master/src/feedback.coffee
        // maybe ask user to try also weak passwords to see and understand feedback?
        if (strength.getFeedback().getSuggestions().size() != 0) {
            output.append(""<b>Suggestions:</b></br><ul>"");",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",0001975526E6118B9552413F279D2CE2,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",31,"            html = html + '<td>' + result[i].FirstName + '</td>';
            html = html + '<td>' + result[i].LastName + '</td>';
            html = html + '<td>' + result[i].SSN + '</td>';
            html = html + '<td>' + result[i].Salary + '</td>';
            html = html + '</tr>';",Read SSN(),"src/main/resources/lessons/spoofcookie/templates/spoofcookieform.html","spoofcookieform.html",16,"					<div class=""form-group input-group"">
						<span class=""input-group-addon""><i
							class=""glyphicon glyphicon-lock""></i></span> <input class=""form-control""
							placeholder=""Password"" name=""password"" type=""password""
							id=""spoof_password"" />",Comment(),"spoofcookieform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",D130F2D11A11036C43935126D9371121,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",56,"			KeyPair keyPair = CryptoUtil.generateKeyPair();
			privateKey = CryptoUtil.getPrivateKeyInPEM(keyPair);
			request.getSession().setAttribute(""privateKeyString"", privateKey);
			request.getSession().setAttribute(""keyPair"", keyPair);
		}",Read privateKey(),"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",59,"			request.getSession().setAttribute(""keyPair"", keyPair);
		}
		return privateKey;
    }
	",Return privateKey(),"SigningAssignment.java의 getPrivateKey() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",A2235C48B1F31D614FB7FF0C10EF2E71,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",56,"			KeyPair keyPair = CryptoUtil.generateKeyPair();
			privateKey = CryptoUtil.getPrivateKeyInPEM(keyPair);
			request.getSession().setAttribute(""privateKeyString"", privateKey);
			request.getSession().setAttribute(""keyPair"", keyPair);
		}",Read privateKey(),"src/main/resources/lessons/ssrf/html/SSRF.html","SSRF.html",40,"                <table>
                    <tr>
                        <td><input type=""hidden"" id=""url2"" name=""url"" value=""images/cat.png""/></td>

                        <td><input",Return privateKey(),"숨겨진 폼 필드가 SSRF.html의 40 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E6F8598ADC56CACB263A11487CB5FCB9,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",56,"			KeyPair keyPair = CryptoUtil.generateKeyPair();
			privateKey = CryptoUtil.getPrivateKeyInPEM(keyPair);
			request.getSession().setAttribute(""privateKeyString"", privateKey);
			request.getSession().setAttribute(""keyPair"", keyPair);
		}",Read privateKey(),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",77,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>",Return privateKey(),"Challenge6.html의 폼은 77 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",86F954F8F76C97C6C0799132759D6D34,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",138,"        try {
            Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());","java.sql.Statement.executeUpdate()","SqlInjectionLesson8.java의 138 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",80C036C93DD83B2F7E7207DF586D92C1,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(1),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",81,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>","java.sql.Statement.executeUpdate()","Challenge6.html의 형식은 81 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F93F98330B2AC2A31772911B07034F6A,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(1),"src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",57,"                });
            </script>
            <input type=""hidden"" name=""networkNum"" id=""networkNum"" value=""foo"" />
            <table>
                <tr>","java.sql.Statement.executeUpdate()","숨겨진 폼 필드가 ChromeDevTools.html의 57 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4D4E3F29FD6DBA7A281702847EA47EC9,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(1),"target/classes/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",44,"
            <input type=""text"" value="""" name=""username"" placeholder=""username""/>
            <input type=""password"" value="""" name=""password"" placeholder=""password""/>
            <input type=""submit"" value=""Submit""/>
","java.sql.Statement.executeUpdate()","LogSpoofing.html의 형식은 44 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2C8FF083DC2CECBC075A446DA48FBF2C,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(1),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",100,"                                       type=""text""/>
                                <input class=""form-control"" id=""reviewStars"" name=""stars"" type=""text""/>
                                <input type=""hidden"" name=""validateReq"" value=""2aa14227b9a13d0bede0388a7fba9aa9""/>
                                <input type=""submit"" name=""submit"" value=""Submit review""/>
                            </form>","java.sql.Statement.executeUpdate()","숨겨진 폼 필드가 CSRF.html의 100 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B0DF8DB7D4369C6F17CBE67DA2AD15C8,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/SigningAssignment.java","SigningAssignment.java",56,"			KeyPair keyPair = CryptoUtil.generateKeyPair();
			privateKey = CryptoUtil.getPrivateKeyInPEM(keyPair);
			request.getSession().setAttribute(""privateKeyString"", privateKey);
			request.getSession().setAttribute(""keyPair"", keyPair);
		}",Read privateKey(),"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",145,"        Locale browserLocale = (Locale) request.getSession().getAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME);
        if (null != browserLocale) {
            log.debug(""browser locale {}"", browserLocale);
            return browserLocale.getLanguage();
        } else {","org.slf4j.Logger.debug()","AsciiDoctorTemplateResolver.java의 determineLanguage() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",26C484338F8FFEDBE540C6DA5A467457,BAADF2C8-89C1-415D-BAA0-7FA62199BC83,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",42,"
	public static String getBasicAuth(String username, String password) {
    	return Base64.getEncoder().encodeToString(username.concat("":"").concat(password).getBytes());
    }
	",Read password(),"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",56,"			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}
		return ""Authorization: Basic "".concat(basicAuth);
    }
	",Return(),"EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",327A61D07BCA5E76E2F8918566E8F495,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"		if (basicAuth == null) {
			String password = HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
			basicAuth = getBasicAuth(username, password);
			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}",Read password(),"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",56,"			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}
		return ""Authorization: Basic "".concat(basicAuth);
    }
	",Return(),"EncodingAssignment.java의 getBasicAuth() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",327A61D07BCA5E76E2F8918566E8F496,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"		if (basicAuth == null) {
			String password = HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
			basicAuth = getBasicAuth(username, password);
			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}",Read password(),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",160,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordRemoveUserInput"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",Return(),"PathTraversal.html의 형식은 160 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD17,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",53,"		if (basicAuth == null) {
			String password = HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
			basicAuth = getBasicAuth(username, password);
			request.getSession().setAttribute(""basicAuth"", basicAuth);
		}",Read password(),"target/classes/webwolf/templates/webwolf-login.html","webwolf-login.html",37,"                    </div>
                    <div class=""form-group"">
                        <input type=""password"" name=""password"" id=""password"" class=""form-control input-lg""
                               placeholder=""Password WebGoat"" required=""true""/>
                    </div>",Return(),"webwolf-login.html의 형식은 37 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FED73A9935C5A2A0DAD0182124240FCE,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",66,"                Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
                SqlInjectionLesson8.log(connection, query);
                ResultSet results = statement.executeQuery(query);
                var test = results.getRow() != 0;
                if (results.getStatement() != null) {","java.sql.Statement.executeQuery()","SqlInjectionLesson9.java의 66 줄에서 injectableQueryIntegrity() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",A4AAB3F4B0AAC9BB5B7D9D572EA71AB3,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java","WebSecurityConfig.java",57,"                .antMatchers(HttpMethod.GET, ""/mail/**"", ""/requests/**"").authenticated()
                .antMatchers(""/files"").authenticated()
                .anyRequest().permitAll();
        security.and().csrf().disable().formLogin()
                .loginPage(""/login"").failureUrl(""/login?error=true"");",FunctionCall: permitAll(),"Spring Security는 이전 보안 식과 일치하지 않는 요청을 허용하도록 구성되었습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",3DD8F04CFCB508697C3335370AFABDEF,109F6BAF-6C63-4A5C-878F-193F24344F45,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/container/users/RegistrationController.java","RegistrationController.java",35,"
    @PostMapping(""/register.mvc"")
    public String registration(@ModelAttribute(""userForm"") @Valid UserForm userForm, BindingResult bindingResult, HttpServletRequest request) throws ServletException {
        userValidator.validate(userForm, bindingResult);
",registration(0),"src/main/java/org/owasp/webgoat/container/users/UserValidator.java","UserValidator.java",27,"        UserForm userForm = (UserForm) o;

        if (userRepository.findByUsername(userForm.getUsername()) != null) {
            errors.rejectValue(""username"", ""username.duplicate"");
        }","org.owasp.webgoat.container.users.UserRepository.findByUsername()","적절한 access control 없이 UserValidator.java의 validate() 메서드는 공격자가 제어하는 기본 키를 포함하는 27 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",46FDD03306F4A24BE142769A319244A7,7E257BA2-628C-4BF8-AB9F-19DA68E8964F0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",59,"        }
        try (var connection = dataSource.getConnection()) {
            PreparedStatement statement = connection.prepareStatement(""select password from challenge_users where userid = '"" + username_login + ""' and password = '"" + password_login + ""'"");
            ResultSet resultSet = statement.executeQuery();
","java.sql.Connection.prepareStatement()","Assignment5.java의 59 줄에서 login() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",335B38300BD8C08EC7CA2C4E1343A7B0,5870A527-08AF-452C-84B2-7F6C360CA7EF,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",21,"          successCallback=""""
          action=""/WebGoat/csrf/basic-get-flag"">
        <input name=""csrf"" type=""hidden"" value=""false""/>
        <input type=""submit"" name=""submit""/>
","java.sql.Connection.prepareStatement()","숨겨진 폼 필드가 CSRF.html의 21 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B0DF8DB7D4369C6F17CBE67DA2AD15C7,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",22,"
            <input type=""text"" value="""" name=""username"" placeholder=""username""/>
            <input type=""password"" value="""" name=""password"" placeholder=""password""/>
            <input type=""submit"" value=""Submit""/>
","java.sql.Connection.prepareStatement()","LogSpoofing.html의 형식은 22 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2C8FF083DC2CECBC075A446DA48FBF2B,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/resources/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",88,"                  action=""/WebGoat/clientSideFiltering/getItForFree"">

                <input id=""discount"" type=""hidden"" value=""0""/>
                <div class=""row"">
","java.sql.Connection.prepareStatement()","숨겨진 폼 필드가 ClientSideFiltering.html의 88 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5F4950CF24C4A51AC52C8EF229E29C02,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",931,"};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FA1668F9C81061945FC2B459758FEFCD,9DC93E75-BA94-4FA1-A177-ED1201EB29BC,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",63,"                                <div class=""form-group input-group"">
                                    <span class=""input-group-addon""><i class=""glyphicon glyphicon-lock""></i></span>
                                    <input class=""form-control"" placeholder=""Password"" name=""password""
                                           type=""password"" value=""""/>
                                </div>",Comment(),"PasswordReset.html의 형식은 63 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1FD01115EAF3814E42D3ACAD5387EC78,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",92,"            model.addAttribute(""form"", form);
            modelAndView.addObject(""form"", form);
            modelAndView.setViewName(""password_reset""); //Display html page for changing password
        } else {
        	modelAndView.setViewName(""password_link_not_found"");",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4700270C52A1EAB4C99EED3787842722,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",100,"                                       type=""text""/>
                                <input class=""form-control"" id=""reviewStars"" name=""stars"" type=""text""/>
                                <input type=""hidden"" name=""validateReq"" value=""2aa14227b9a13d0bede0388a7fba9aa9""/>
                                <input type=""submit"" name=""submit"" value=""Submit review""/>
                            </form>",Comment(),"숨겨진 폼 필드가 CSRF.html의 100 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B0DF8DB7D4369C6F17CBE67DA2AD15CA,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",140,"            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());
        }
    }",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",58CE9816677EE72826BCEC9499E2C9B2,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",17,"                <div class=""form-group"">
                    <label for=""password"" class=""control-label"">Password</label>
                    <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                           name='password'/>
                </div>",FunctionCall: println(),"webwolfPasswordReset.html의 형식은 17 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",7F60C92EC10E172362680C722397D987,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/java/org/owasp/webgoat/container/lessons/LessonConnectionInvocationHandler.java","LessonConnectionInvocationHandler.java",30,"        if (authentication != null && authentication.getPrincipal() instanceof WebGoatUser user) {
            try (var statement = targetConnection.createStatement()) {
                statement.execute(""SET SCHEMA \"""" + user.getUsername() + ""\"""");
            }
        }",execute(),"LessonConnectionInvocationHandler.java의 30 줄에서 invoke() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F15838C8B29F1BFFF806C03B20CDCFC7,4B673A45-9AD5-4CBA-945B-11A3702CDF57,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/resources/webgoat/static/js/libs/ace.js","ace.js",1740,"        
        exports.addListener(win, ""message"", listener);
        win.postMessage(messageName, ""*"");
    };
}",FunctionPointerCall: postMessage(),"ace.js의 1740 줄에서 프로그램은 지나치게 허용적인 대상 원본을 사용하여 문서 간 메시지를 게시합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B0DB27D3BCA30450522BACB84C239AE2,E789B621-9F69-49C5-A30C-ED6A89F80E31,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,API Abuse,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/java/org/owasp/webgoat/webwolf/mailbox/Email.java","Email.java",45,@Entity
@NoArgsConstructor
public class Email implements Serializable {

    @Id,Class: Email(),"Email.java의 클래스는 데이터베이스의 지속적인 엔터티이면서 동적으로 범위를 요청하는 개체입니다. 요청 매개 변수로 자동 입력되도록 데이터베이스의 지속적인 엔터티를 허용하면 공격자가 연결 엔터티에 의도하지 않은 데이터베이스 기록을 작성하거나 엔터티 개체의 의도하지 않은 필드를 업데이트할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",72F79DE2B6B083E4E536FF85A4F559DC,7A5FADA5-01E9-4FEF-95A2-B1FA83D5E8E2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/resources/webgoat/static/js/libs/jquery.form.js","jquery.form.js",931,"};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FA1668F9C81061945FC2B459758FEFCC,9DC93E75-BA94-4FA1-A177-ED1201EB29BC,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",103,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordFix"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",Comment(),"PathTraversal.html의 형식은 103 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD16,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",89,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_login"" id=""password4"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>",Comment(),"SqlInjectionAdvanced.html의 형식은 89 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7C9548FA80341DC23622D7D388D93D8,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",89,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_login"" id=""password4"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>",Comment(),"SqlInjectionAdvanced.html의 형식은 89 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7C9548FA80341DC23622D7D388D93D5,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java","Assignment5.java",51,"    @PostMapping(""/challenge/5"")
    @ResponseBody
    public AttackResult login(@RequestParam String username_login, @RequestParam String password_login) throws Exception {
        if (!StringUtils.hasText(username_login) || !StringUtils.hasText(password_login)) {
            return failed(this).feedback(""required4"").build();",login(1),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",129,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>",Comment(),"SqlInjectionAdvanced.html의 폼은 129 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",00922BA91B78F39B43486FB9A7B69121,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java","SecurePasswordsAssignment.java",51,"
        output.append(""<b>Your Password: *******</b></br>"");
        output.append(""<b>Length: </b>"" + password.length() + ""</br>"");
        output.append(""<b>Estimated guesses needed to crack your password: </b>"" + df.format(strength.getGuesses()) + ""</br>"");
        output.append(""<div style=\""float: left;padding-right: 10px;\""><b>Score: </b>"" + strength.getScore() + ""/4 </div>"");",Read password(),"src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java","SecurePasswordsAssignment.java",74,"
        if (strength.getScore() >= 4)
            return success(this).feedback(""securepassword-success"").output(output.toString()).build();
        else
            return failed(this).feedback(""securepassword-failed"").output(output.toString()).build();",Return(),"SecurePasswordsAssignment.java의 completed() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",3444F2328A8B41AE6A759D9990B36DF2,31546B66-03D9-48A3-A1B8-0DF151C9DA2B0,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/securepasswords/SecurePasswordsAssignment.java","SecurePasswordsAssignment.java",51,"
        output.append(""<b>Your Password: *******</b></br>"");
        output.append(""<b>Length: </b>"" + password.length() + ""</br>"");
        output.append(""<b>Estimated guesses needed to crack your password: </b>"" + df.format(strength.getGuesses()) + ""</br>"");
        output.append(""<div style=\""float: left;padding-right: 10px;\""><b>Score: </b>"" + strength.getScore() + ""/4 </div>"");",Read password(),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",30,"                    <td>user/pass</td>
                    <td>user:<input name=""username"" value="""" type=""TEXT"" /></td>
                    <td>pass:<input name=""password"" value="""" type=""password"" /></td>
                    <td>
                        <input",Return(),"IDOR.html의 형식은 30 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",3ED6FCD911BC7513ED7B5603956AD521,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",60,"    @PostMapping(path = ""xxe/content-type"")
    @ResponseBody
    public AttackResult createNewUser(HttpServletRequest request, @RequestBody String commentStr, @RequestHeader(""Content-Type"") String contentType) throws Exception {
        AttackResult attackResult = failed(this).build();
",createNewUser(1),"src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",102,"        }

        var xsr = xif.createXMLStreamReader(new StringReader(xml));

        var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:102에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",98100B9A230CEAD9FD52C147C2CD5704,6A059AF5-3228-448E-8BD8-469EAAC6C44E,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",138,"        try {
            Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());","java.sql.Statement.executeUpdate()","SqlInjectionLesson8.java의 138 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",9CAECD3FE18F3237CBE89DA0E2EF6539,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(0),"src/main/resources/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",44,"
            <input type=""text"" value="""" name=""username"" placeholder=""username""/>
            <input type=""password"" value="""" name=""password"" placeholder=""password""/>
            <input type=""submit"" value=""Submit""/>
","java.sql.Statement.executeUpdate()","LogSpoofing.html의 형식은 44 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2C8FF083DC2CECBC075A446DA48FBF2A,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",81,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>","java.sql.Statement.executeUpdate()","Challenge6.html의 폼은 81 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",86F954F8F76C97C6C0799132759D6D33,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.port()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","org.springframework.web.servlet.ModelAndView.addObject()","FileServer.java의 getFiles() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1E3A26C62B0429F34B63D7FD653EB347,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/server/StartupMessage.java","StartupMessage.java",26,"        if (event.getApplicationContext().getApplicationName().contains(""WebGoat"")) {
            port = event.getApplicationContext().getEnvironment().getProperty(""server.port"");
            address = event.getApplicationContext().getEnvironment().getProperty(""server.address"");
        }
    }","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/server/StartupMessage.java","StartupMessage.java",22,"    void onStartup(ApplicationReadyEvent event) {
        if (StringUtils.hasText(port) && !StringUtils.hasText(System.getProperty(""running.in.docker""))) {
            log.info(""Please browse to http://{}:{}/WebGoat to get started..."", address, port);
        }
        if (event.getApplicationContext().getApplicationName().contains(""WebGoat"")) {","org.slf4j.Logger.info()","StartupMessage.java의 onStartup() 메서드는 확인되지 않은 사용자 입력을 22 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4DB025EFE3BA7983578C69A0864CAB82,9667C493-BADE-4668-87D9-BF3CCA799FD9,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(1),"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",76,"        		.filter(t -> allowedTrace(t, user))
                .map(t -> new Tracert(t.getTimestamp(), path(t), toJsonString(t))).collect(toList());
        model.addObject(""traces"", traces);

        return model;","org.springframework.web.servlet.ModelAndView.addObject()","Requests.java의 get() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",9924AA30226C163F1760FFCBD3856102,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(1),"src/main/resources/lessons/passwordreset/templates/password_reset.html","password_reset.html",12,"    <div class=""row"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"">
            <form role=""form"" method=""POST"" action=""/WebGoat/PasswordReset/reset/change-password"" th:object=""${form}"" novalidate=""novalidate"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                    <div class=""form-group"" th:classappend=""${#fields.hasErrors('password')}? 'has-error'"">","org.springframework.web.servlet.ModelAndView.addObject()","입력 폼 필드의 HTML5 검증이 비활성화됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F63D7EBBF13CE7E531ADC35E4F0FB670,F9E9799A-2A81-4BFE-837D-17F73AC1EDD6,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",53," */
@Controller
@RequiredArgsConstructor
@Slf4j
@RequestMapping(value = ""/requests"")",Requests(1),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",133,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>","org.springframework.web.servlet.ModelAndView.addObject()","SqlInjectionAdvanced.html의 폼은 133 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",00922BA91B78F39B43486FB9A7B69120,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",91,"            form.setResetLink(link);
            model.addAttribute(""form"", form);
            modelAndView.addObject(""form"", form);
            modelAndView.setViewName(""password_reset""); //Display html page for changing password
        } else {","org.springframework.web.servlet.ModelAndView.addObject()","ResetLinkAssignment.java의 resetPassword() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F94E7EF0E3C204FBA40C41764C0093DA,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"src/main/resources/webwolf/templates/webwolf-login.html","webwolf-login.html",37,"                    </div>
                    <div class=""form-group"">
                        <input type=""password"" name=""password"" id=""password"" class=""form-control input-lg""
                               placeholder=""Password WebGoat"" required=""true""/>
                    </div>","org.springframework.web.servlet.ModelAndView.addObject()","webwolf-login.html의 형식은 37 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FED73A9935C5A2A0DAD0182124240FCD,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",85,"
    @GetMapping(""/PasswordReset/reset/reset-password/{link}"")
    public ModelAndView resetPassword(@PathVariable(value = ""link"") String link, Model model) {
    	ModelAndView modelAndView = new ModelAndView();
        if (ResetLinkAssignment.resetLinks.contains(link)) {",resetPassword(0),"target/classes/lessons/bypassrestrictions/html/BypassRestrictions.html","BypassRestrictions.html",108,"                <textarea cols=""25"" name=""field7"" rows=""1"">301-604-4882</textarea>
            </div>
            <input type=""hidden"" value="""" name=""error""/>
            <p>
                <button type=""submit"" class=""btn btn-primary"">Submit</button>","org.springframework.web.servlet.ModelAndView.addObject()","숨겨진 폼 필드가 BypassRestrictions.html의 108 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DB2AF756C50DF0B08BB75222C29AECE8,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","org.springframework.web.servlet.ModelAndView.addObject()","FileServer.java의 getFiles() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",3E77F1E85E76537A6EE5EFE37B1D245C,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","target/classes/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",30,"				<script th:src=""@{/lesson_js/assignment3.js}"" type=""text/javascript"" charset=""utf-8""></script>
			</div>
			<input type=""hidden"" name=""editor""/>
			<div class=""input-group"" style=""position: absolute; top: 365px;"">
				<button class=""btn btn-primary"" type=""submit"">Submit</button>","org.springframework.web.servlet.ModelAndView.addObject()","숨겨진 폼 필드가 CrossSiteScriptingMitigation.html의 30 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",81A26F15DA840732342EB9C7130C7F0C,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","src/main/resources/lessons/htmltampering/html/HtmlTampering.html","HtmlTampering.html",132,"                                    </div>
                                </td>
                                <input id=""Total"" name=""Total"" type=""HIDDEN"" value=""2999.99""/>
                            </tr>
                            </tbody>","org.springframework.web.servlet.ModelAndView.addObject()","숨겨진 폼 필드가 HtmlTampering.html의 132 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8B5CBAC6FD590247173FBB86E7C9DA29,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","target/classes/webgoat/static/js/libs/ace.js","ace.js",1740,"        
        exports.addListener(win, ""message"", listener);
        win.postMessage(messageName, ""*"");
    };
}",FunctionPointerCall: postMessage(),"ace.js의 1740 줄에서 프로그램은 지나치게 허용적인 대상 원본을 사용하여 문서 간 메시지를 게시합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B0DB27D3BCA30450522BACB84C239AE3,E789B621-9F69-49C5-A30C-ED6A89F80E31,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","src/main/resources/lessons/passwordreset/templates/password_reset.html","password_reset.html",15,"                <h2 class=""sign_up_title"">Reset your password</h2>
                    <div class=""form-group"" th:classappend=""${#fields.hasErrors('password')}? 'has-error'"">
                        <input type=""hidden"" name=""resetLink"" th:field=""*{resetLink}"" />
                        <label for=""password"" class=""control-label"" th:text=""#{password}"">Password</label>
                        <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""",FunctionPointerCall: postMessage(),"숨겨진 폼 필드가 password_reset.html의 15 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DE6A19D6A740E2496DCE04D77527D498,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","src/main/resources/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",30,"				<script th:src=""@{/lesson_js/assignment3.js}"" type=""text/javascript"" charset=""utf-8""></script>
			</div>
			<input type=""hidden"" name=""editor""/>
			<div class=""input-group"" style=""position: absolute; top: 365px;"">
				<button class=""btn btn-primary"" type=""submit"">Submit</button>",FunctionPointerCall: postMessage(),"숨겨진 폼 필드가 CrossSiteScriptingMitigation.html의 30 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",81A26F15DA840732342EB9C7130C7F0A,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",48,"                        </div>
                    </form>
                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail"">",FunctionPointerCall: postMessage(),"입력 폼 필드의 HTML5 검증이 비활성화됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",363F98CA35057374D036AE8628932F60,F9E9799A-2A81-4BFE-837D-17F73AC1EDD6,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",118,"
        modelAndView.addObject(""files"", uploadedFiles);
        modelAndView.addObject(""webwolf_url"", ""http://"" + server + "":"" + port);
        return modelAndView;
    }","Read this.server()","target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",24,"                    

                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail/reset"">",FunctionPointerCall: postMessage(),"입력 폼 필드의 HTML5 검증이 비활성화됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",363F98CA35057374D036AE8628932F61,F9E9799A-2A81-4BFE-837D-17F73AC1EDD6,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java","Ping.java",49,"    @RequestMapping(method = RequestMethod.GET)
    @ResponseBody
    public String logRequest(@RequestHeader(""User-Agent"") String userAgent, @RequestParam(required = false) String text) {
        String logLine = String.format(""%s %s %s"", ""GET"", userAgent, text);
        log.debug(logLine);",logRequest(0),"src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java","Ping.java",51,"    public String logRequest(@RequestHeader(""User-Agent"") String userAgent, @RequestParam(required = false) String text) {
        String logLine = String.format(""%s %s %s"", ""GET"", userAgent, text);
        log.debug(logLine);
        File logFile = new File(webGoatHomeDirectory, ""/XXE/log"" + webSession.getUserName() + "".txt"");
        try {","org.slf4j.Logger.debug()","Ping.java의 logRequest() 메서드는 확인되지 않은 사용자 입력을 51 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",BDEFF485531500730E06696FC81D0FF0,61D4418B-F788-4C54-BFE4-D05E4769E29B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",19,"        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");
    }
}","org.springframework.web.servlet.ModelAndView.ModelAndView()","WebWolfRedirect.java의 openWebWolf() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B892F437DBC6E6E52F1069E21A93E137,65BC1586-E429-4EA1-86CA-51FB4B32D667,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/resources/lessons/hijacksession/templates/hijackform.html","hijackform.html",16,"					<div class=""form-group input-group"">
						<span class=""input-group-addon""><i
							class=""glyphicon glyphicon-lock""></i></span> <input class=""form-control""
							placeholder=""Password"" name=""password"" type=""password"" />
					</div>","org.springframework.web.servlet.ModelAndView.ModelAndView()","hijackform.html의 형식은 16 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8E778A7762E99826CA67E0A83B2E4C25,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","target/classes/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",78,"                </tr>
            </table>
            <input type=""hidden"" name=""network_num"" id=""networkNumCopy"" value=""foo"" />
        </form>
        <div class=""attack-feedback""></div>","org.springframework.web.servlet.ModelAndView.ModelAndView()","숨겨진 폼 필드가 ChromeDevTools.html의 78 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4D4E3F29FD6DBA7A281702847EA47ECC,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java","Ping.java",49,"    @RequestMapping(method = RequestMethod.GET)
    @ResponseBody
    public String logRequest(@RequestHeader(""User-Agent"") String userAgent, @RequestParam(required = false) String text) {
        String logLine = String.format(""%s %s %s"", ""GET"", userAgent, text);
        log.debug(logLine);",logRequest(1),"src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java","Ping.java",51,"    public String logRequest(@RequestHeader(""User-Agent"") String userAgent, @RequestParam(required = false) String text) {
        String logLine = String.format(""%s %s %s"", ""GET"", userAgent, text);
        log.debug(logLine);
        File logFile = new File(webGoatHomeDirectory, ""/XXE/log"" + webSession.getUserName() + "".txt"");
        try {","org.slf4j.Logger.debug()","Ping.java의 logRequest() 메서드는 확인되지 않은 사용자 입력을 51 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F7D27DF67F95A70DD1CCB545112EA80D,61D4418B-F788-4C54-BFE4-D05E4769E29B,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",66,"                Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
                SqlInjectionLesson8.log(connection, query);
                ResultSet results = statement.executeQuery(query);
                var test = results.getRow() != 0;
                if (results.getStatement() != null) {","java.sql.Statement.executeQuery()","SqlInjectionLesson9.java의 66 줄에서 injectableQueryIntegrity() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",281AB9A5C90EFF539D82092D9F6AB007,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(1),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",49,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""password"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>","java.sql.Statement.executeQuery()","PathTraversal.html의 형식은 49 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD15,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",23,"
    public List<User> findAllUsers() {
        return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
    }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java","MissingFunctionACUsers.java",67,"            displayUsers.add(new DisplayUser(user, PASSWORD_SALT_SIMPLE));
        }
        model.addObject(""allUsers"", displayUsers);

        return model;","org.springframework.web.servlet.ModelAndView.addObject()","MissingFunctionACUsers.java의 listUsers() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E3E76919680C80CE721A046CAE278010,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",23,"
    public List<User> findAllUsers() {
        return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
    }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",36,"
                <input type=""hidden"" name=""jsEnabled"" value=""1"" />
                <input type=""hidden"" name=""verifyMethod"" value=""SEC_QUESTIONS"" />
                <input type=""hidden"" name=""userId"" value=""12309746"" />
","org.springframework.web.servlet.ModelAndView.addObject()","숨겨진 폼 필드가 AuthBypass.html의 36 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6D6,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",23,"
    public List<User> findAllUsers() {
        return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
    }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","src/main/resources/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",22,"            <script th:src=""@{/lesson_js/clientSideFiltering.js}""
                    language=""JavaScript""></script>
            <input id=""userID"" value=""101"" name=""userID"" type=""HIDDEN""/>
            <div id=""lesson_wrapper"">
                <div id=""lesson_header""></div>","org.springframework.web.servlet.ModelAndView.addObject()","숨겨진 폼 필드가 ClientSideFiltering.html의 22 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5F4950CF24C4A51AC52C8EF229E29C01,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",23,"
    public List<User> findAllUsers() {
        return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
    }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","target/classes/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",14,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <input type=""hidden"" id=""user_id"" value=""102""/>
        <!-- using attack-form class on your form, will allow your request to be ajaxified and stay within the display framework for webgoat -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form""","org.springframework.web.servlet.ModelAndView.addObject()","숨겨진 폼 필드가 ClientSideFiltering.html의 14 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5F4950CF24C4A51AC52C8EF229E29C03,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",68,"    @PostMapping(path = ""xxe/simple"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
        String error = """";
        try {",createNewComment(1),"src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",102,"        }

        var xsr = xif.createXMLStreamReader(new StringReader(xml));

        var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:102에 구성된 XML 파서는 DTD(Document Type Definition) 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 엔터티 확장 injection에 노출될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",45EBCBF224D56DAEE842FC8A63368C0E,6A059AF5-3228-448E-8BD8-469EAAC6C44E,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",68,"    @PostMapping(path = ""xxe/simple"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
        String error = """";
        try {",createNewComment(1),"src/main/resources/webgoat/templates/registration.html","registration.html",41,"                        <label for=""password"" class=""col-sm-2 control-label"" th:text=""#{password}"">Password</label>
                        <div class=""col-sm-4"">
                            <input type=""password"" class=""form-control"" id=""password"" th:placeholder=""#{password}""
                                   name='password' th:value=""*{password}""/>
                        </div>","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","registration.html의 형식은 41 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549BC,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",68,"    @PostMapping(path = ""xxe/simple"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
        String error = """";
        try {",createNewComment(1),"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",56,"                <input name=""newPasswordConfirm"" value="""" type=""password"" /><br/><br />

                <input type=""hidden"" name=""userId"" value=""12309746"" />

                <input name=""submit"" value=""Submit"" type=""submit""/>","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","숨겨진 폼 필드가 AuthBypass.html의 56 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6D8,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java","SqlInjectionLesson5.java",65,"    @PostMapping(""/SqlInjection/attack5"")
    @ResponseBody
    public AttackResult completed(String query) {
        createUser();
        return injectableQuery(query);",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java","SqlInjectionLesson5.java",73,"        try (Connection connection = dataSource.getConnection()) {
            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
                statement.executeQuery(query);
                if (checkSolution(connection)) {
                    return success(this).build();","java.sql.Statement.executeQuery()","SqlInjectionLesson5.java의 73 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",5732568640D15D8C8500307C1C619EC5,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",54,"    @PostMapping(""/SqlInjection/attack8"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",66,"                Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
                log(connection, query);
                ResultSet results = statement.executeQuery(query);

                if (results.getStatement() != null) {","java.sql.Statement.executeQuery()","SqlInjectionLesson8.java의 66 줄에서 injectableQueryConfidentiality() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E2A91A2DB501E815808B69C9773BB394,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",76,"    public List<Map<String, Object>> invoke() {
        NodeList nodes = null;
        File d = new File(webGoatHomeDirectory, ""ClientSideFiltering/employees.xml"");
        XPathFactory factory = XPathFactory.newInstance();
        XPath path = factory.newXPath();","Read this.webGoatHomeDirectory()","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",107,"            log.error(""Unable to parse xml"", e);
        } catch (IOException e) {
            log.error(""Unable to read employees.xml at location: '{}'"", d);
        }
        return json;","org.slf4j.Logger.error()","Salaries.java의 invoke() 메서드는 확인되지 않은 사용자 입력을 107 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",960DC0BBFA4CA80AB81A19179ECCD1AE,9667C493-BADE-4668-87D9-BF3CCA799FD9,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(1),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",76,"                    PreparedStatement preparedStatement = connection.prepareStatement(""INSERT INTO sql_challenge_users VALUES (?, ?, ?)"");
                    preparedStatement.setString(1, username_reg);
                    preparedStatement.setString(2, email_reg);
                    preparedStatement.setString(3, password_reg);
                    preparedStatement.execute();","java.sql.PreparedStatement.setString()","적절한 access control 없이 SqlInjectionChallenge.java의 registerNewUser() 메서드는 공격자가 제어하는 기본 키를 포함하는 76 줄의 SQL 문을 실행하면 공격자가 허가 받지 않은 레코드에 접근할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",C9C0BF806ADD65AD9E511076560730CB,A53E6ED8-2131-4F10-B320-4158B7238CFA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(1),"src/main/resources/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",17,"                <div class=""form-group"">
                    <label for=""password"" class=""control-label"">Password</label>
                    <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                           name='password'/>
                </div>","java.sql.PreparedStatement.setString()","webwolfPasswordReset.html의 폼은 17 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",55D1A18A9BD791C88450CC9ADDC6F9AA,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(1),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",202,"            </i>
          </span>
                                        <input class=""form-control"" placeholder=""Password"" name=""password""
                                               type=""password""
                                               value="""" required=""""/>","java.sql.PreparedStatement.setString()","PasswordReset.html의 형식은 202 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",1FD01115EAF3814E42D3ACAD5387EC77,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",103,"        File changeIndicatorFile = new File(destinationDir, user.getUsername() + ""_changed"");
        if (changeIndicatorFile.exists()) {
            modelAndView.addObject(""uploadSuccess"", request.getParameter(""uploadSuccess""));
        }
        changeIndicatorFile.delete();","javax.servlet.ServletRequest.getParameter()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",103,"        File changeIndicatorFile = new File(destinationDir, user.getUsername() + ""_changed"");
        if (changeIndicatorFile.exists()) {
            modelAndView.addObject(""uploadSuccess"", request.getParameter(""uploadSuccess""));
        }
        changeIndicatorFile.delete();","org.springframework.web.servlet.ModelAndView.addObject()","FileServer.java의 getFiles() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8A68D2CB06A161706F3A9F29E9B63F73,80137882-8F75-45DA-A3FF-C83A4E1981B1,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",103,"        File changeIndicatorFile = new File(destinationDir, user.getUsername() + ""_changed"");
        if (changeIndicatorFile.exists()) {
            modelAndView.addObject(""uploadSuccess"", request.getParameter(""uploadSuccess""));
        }
        changeIndicatorFile.delete();","javax.servlet.ServletRequest.getParameter()","src/main/resources/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",22,"
            <input type=""text"" value="""" name=""username"" placeholder=""username""/>
            <input type=""password"" value="""" name=""password"" placeholder=""password""/>
            <input type=""submit"" value=""Submit""/>
","org.springframework.web.servlet.ModelAndView.addObject()","LogSpoofing.html의 형식은 22 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2C8FF083DC2CECBC075A446DA48FBF29,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",42,"
	public static String getBasicAuth(String username, String password) {
    	return Base64.getEncoder().encodeToString(username.concat("":"").concat(password).getBytes());
    }
	",Read password(),"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",145,"        Locale browserLocale = (Locale) request.getSession().getAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME);
        if (null != browserLocale) {
            log.debug(""browser locale {}"", browserLocale);
            return browserLocale.getLanguage();
        } else {","org.slf4j.Logger.debug()","AsciiDoctorTemplateResolver.java의 determineLanguage() 메서드는 기밀 정보를 잘못 취급합니다. 이는 사용자 개인 정보를 침해할 수 있고 불법인 경우도 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F97D18FD7BA6A30FB205CA279EF6BDC0,BAADF2C8-89C1-415D-BAA0-7FA62199BC83,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",42,"
	public static String getBasicAuth(String username, String password) {
    	return Base64.getEncoder().encodeToString(username.concat("":"").concat(password).getBytes());
    }
	",Read password(),"src/main/resources/lessons/challenges/html/Challenge5.html","Challenge5.html",34,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_login"" id=""password4"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","org.slf4j.Logger.debug()","Challenge5.html의 형식은 34 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",98D912EA082C47CBEA03DCDDAD03DA7A,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson4.java","CrossSiteScriptingLesson4.java",44,"    @PostMapping(""/CrossSiteScripting/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String editor2) {

        String editor = editor2.replaceAll(""\\<.*?>"", """");",completed(0),"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson4.java","CrossSiteScriptingLesson4.java",47,"
        String editor = editor2.replaceAll(""\\<.*?>"", """");
        log.debug(editor);

        if ((editor.contains(""Policy.getInstance(\""antisamy-slashdot.xml\"""") || editor.contains("".scan(newComment, \""antisamy-slashdot.xml\"""") || editor.contains("".scan(newComment, new File(\""antisamy-slashdot.xml\"")"")) &&","org.slf4j.Logger.debug()","CrossSiteScriptingLesson4.java의 completed() 메서드는 확인되지 않은 사용자 입력을 47 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E8C6AFF756E92D9EA35687B36CDEC017,61D4418B-F788-4C54-BFE4-D05E4769E29B,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson4.java","CrossSiteScriptingLesson4.java",44,"    @PostMapping(""/CrossSiteScripting/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String editor2) {

        String editor = editor2.replaceAll(""\\<.*?>"", """");",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",81,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>","org.slf4j.Logger.debug()","Challenge6.html의 형식은 81 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F93F98330B2AC2A31772911B07034F67,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson4.java","CrossSiteScriptingLesson4.java",44,"    @PostMapping(""/CrossSiteScripting/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String editor2) {

        String editor = editor2.replaceAll(""\\<.*?>"", """");",completed(0),"target/classes/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",14,"            <form role=""form"" method=""GET"" th:action=""${webwolfUrl}"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                <input type=""hidden"" name=""uniqueCode"" th:value=""${uniqueCode}""/>
                <div class=""form-group"">
                    <label for=""password"" class=""control-label"">Password</label>","org.slf4j.Logger.debug()","숨겨진 폼 필드가 webwolfPasswordReset.html의 14 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4F0374CF97C72D5FEE04BD47E6BB5A7D,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson4.java","CrossSiteScriptingLesson4.java",44,"    @PostMapping(""/CrossSiteScripting/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String editor2) {

        String editor = editor2.replaceAll(""\\<.*?>"", """");",completed(0),"target/classes/lessons/challenges/html/Challenge5.html","Challenge5.html",34,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_login"" id=""password4"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","org.slf4j.Logger.debug()","Challenge5.html의 형식은 34 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",98D912EA082C47CBEA03DCDDAD03DA7B,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson4.java","CrossSiteScriptingLesson4.java",44,"    @PostMapping(""/CrossSiteScripting/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String editor2) {

        String editor = editor2.replaceAll(""\\<.*?>"", """");",completed(0),"target/classes/webgoat/templates/registration.html","registration.html",50,"                            password</label>
                        <div class=""col-sm-4"">
                            <input type=""password"" class=""form-control"" id=""matchingPassword"" th:placeholder=""#{password}""
                                   name='matchingPassword' th:value=""*{matchingPassword}""/>
                        </div>","org.slf4j.Logger.debug()","registration.html의 형식은 50 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549C1,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",138,"        try {
            Statement statement = connection.createStatement(TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);
            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());","java.sql.Statement.executeUpdate()","SqlInjectionLesson8.java의 138 줄에서 log() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",299A26DFCE70BE25D6F4CC8CC7F3DECB,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",129,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","java.sql.Statement.executeUpdate()","SqlInjectionAdvanced.html의 폼은 129 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",00922BA91B78F39B43486FB9A7B6911F,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",51,"
                <p>Password:</p>
                <input name=""newPassword"" value="""" type=""password"" /><br/>

                <p>Confirm Password:</p>","java.sql.Statement.executeUpdate()","AuthBypass.html의 형식은 51 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F26FE4CAF8C7528EED062E6D872E7BA3,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java","WebSecurityConfig.java",51,"
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry security = http
                .authorizeRequests()",Function: configure(),"CSP(Content Security Policy)가 구성되지 않았습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",293B5E0E47755C64ED0E7881FA4249E4,46B482B2-3EA4-4634-8ECA-BD7C83C7E84C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java","LabelAndHintIntegrationTest.java",134,"            }
            if (!jsonPath.getString(ESCAPE_JSON_PATH_CHAR+key+ESCAPE_JSON_PATH_CHAR).equals(propsLang.get(key))) {
                System.out.println(""key: "" + key + "" in ("" +lang+"") has incorrect translation in label service"");
                System.out.println(""actual:""+jsonPath.getString(ESCAPE_JSON_PATH_CHAR+key+ESCAPE_JSON_PATH_CHAR));
                System.out.println(""expected: ""+propsLang.getProperty(key));",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",6F7791AB8C62746F4D5FEDEC90614C17,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",55,"    @PostMapping(""/SqlInjection/attack9"")
    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }",completed(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",37,"                <input type=""hidden"" name=""jsEnabled"" value=""1"" />
                <input type=""hidden"" name=""verifyMethod"" value=""SEC_QUESTIONS"" />
                <input type=""hidden"" name=""userId"" value=""12309746"" />

                <input name=""submit"" value=""Submit"" type=""submit""/>",FunctionCall: println(),"숨겨진 폼 필드가 AuthBypass.html의 37 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6DB,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",77,"        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));
        log.debug(""File saved to {}"", new File(destinationDir, myFile.getOriginalFilename()));

        return new ModelAndView(","org.slf4j.Logger.debug()","FileServer.java의 importFile() 메서드는 확인되지 않은 사용자 입력을 77 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",DF5E5124CF49F39FD2BE5D55D40FB268,61D4418B-F788-4C54-BFE4-D05E4769E29B,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",133,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>","org.slf4j.Logger.debug()","SqlInjectionAdvanced.html의 폼은 133 줄에서 HTTP GET 요청의 일부로 암호를 제출하면 암호가 브라우저 캐시에 표시, 기록 및 저장될 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",00922BA91B78F39B43486FB9A7B69122,F6D9F544-4E31-498A-A71D-1ACC374A9AA8,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",78,"                </tr>
            </table>
            <input type=""hidden"" name=""network_num"" id=""networkNumCopy"" value=""foo"" />
        </form>
        <div class=""attack-feedback""></div>","org.slf4j.Logger.debug()","숨겨진 폼 필드가 ChromeDevTools.html의 78 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4D4E3F29FD6DBA7A281702847EA47ECA,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",35,"                <input name=""secQuestion1"" value="""" type=""TEXT"" /><br/><br />

                <input type=""hidden"" name=""jsEnabled"" value=""1"" />
                <input type=""hidden"" name=""verifyMethod"" value=""SEC_QUESTIONS"" />
                <input type=""hidden"" name=""userId"" value=""12309746"" />","org.slf4j.Logger.debug()","숨겨진 폼 필드가 AuthBypass.html의 35 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AFF0B335FB28FB67ACA9A987B508B6D9,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",21,"          successCallback=""""
          action=""/WebGoat/csrf/basic-get-flag"">
        <input name=""csrf"" type=""hidden"" value=""false""/>
        <input type=""submit"" name=""submit""/>
","org.slf4j.Logger.debug()","숨겨진 폼 필드가 CSRF.html의 21 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B0DF8DB7D4369C6F17CBE67DA2AD15C9,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"target/classes/lessons/ssrf/html/SSRF.html","SSRF.html",18,"                <table>
                    <tr>
                        <td><input type=""hidden"" id=""url1"" name=""url"" value=""images/tom.png""/></td>

                        <td><input","org.slf4j.Logger.debug()","숨겨진 폼 필드가 SSRF.html의 18 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E6F8598ADC56CACB263A11487CB5FCBA,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",62,"            query = ""SELECT * FROM user_data WHERE first_name = 'John' and last_name = '"" + accountName + ""'"";
            try (Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
                ResultSet results = statement.executeQuery(query);

                if ((results != null) && (results.first())) {","java.sql.Statement.executeQuery()","SqlInjectionLesson5a.java의 62 줄에서 injectableQuery() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",EDBAAB5108597B4451A27BDFF5AA4B0C,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",129,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""password_reg"" id=""password"" tabindex=""2""
                                                   class=""form-control"" placeholder=""Password""/>
                                        </div>","java.sql.Statement.executeQuery()","SqlInjectionAdvanced.html의 형식은 129 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7C9548FA80341DC23622D7D388D93D6,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge7.html","Challenge7.html",49,"                                        </div>

                                        <input type=""hidden"" class=""hide"" name=""token"" id=""token"" value=""""/>
                                    </form>
","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 Challenge7.html의 49 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",75600F22027A5E2C274C88ADB1F5ACD0,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/resources/webgoat/templates/registration.html","registration.html",50,"                            password</label>
                        <div class=""col-sm-4"">
                            <input type=""password"" class=""form-control"" id=""matchingPassword"" th:placeholder=""#{password}""
                                   name='matchingPassword' th:value=""*{matchingPassword}""/>
                        </div>","java.sql.Statement.executeQuery()","registration.html의 형식은 50 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",2F939FC13B8AA1EC949756EDFCB549BD,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"target/classes/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",64,"						webgoat.customjs.assignRandomVal();
					</script>
					<input type=""hidden"" name=""magic_num"" id=""magic_num"" value=""foo"" />
					<table>
						<tr>","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 HttpBasics.html의 64 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",8BA31261E60311C8E10B6F0B3EAC9B89,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
High,High,API Abuse,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignment.java","ResetLinkAssignment.java",107,"    
    @PostMapping(""/PasswordReset/reset/change-password"")
    public ModelAndView changePassword(@ModelAttribute(""form"") PasswordChangeForm form, BindingResult bindingResult) {
    	ModelAndView modelAndView = new ModelAndView();
        if (!org.springframework.util.StringUtils.hasText(form.getPassword())) {",Function: changePassword(),"모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",0BC1E9B47FC4F781006F0C99537902CF,DD6C050E-5BB0-429C-8F5F-EBE6C3AB93F1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"target/classes/lessons/passwordreset/templates/password_reset.html","password_reset.html",12,"    <div class=""row"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"">
            <form role=""form"" method=""POST"" action=""/WebGoat/PasswordReset/reset/change-password"" th:object=""${form}"" novalidate=""novalidate"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                    <div class=""form-group"" th:classappend=""${#fields.hasErrors('password')}? 'has-error'"">",Function: changePassword(),"입력 폼 필드의 HTML5 검증이 비활성화됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F63D7EBBF13CE7E531ADC35E4F0FB671,F9E9799A-2A81-4BFE-837D-17F73AC1EDD6,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentForgotPassword.java","ResetLinkAssignmentForgotPassword.java",40,"import java.util.UUID;

/**
 * Part of the password reset assignment. Used to send the e-mail.
 *",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",F37427E77DF6D3DB885A16B84CC6D0A6,720E3A66-55AC-4D2D-8DB9-DC30E120A52F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",53,"    @PostMapping(""/SqlInjection/assignment5a"")
    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }",completed(0),"src/main/resources/lessons/passwordreset/templates/password_reset.html","password_reset.html",17,"                        <input type=""hidden"" name=""resetLink"" th:field=""*{resetLink}"" />
                        <label for=""password"" class=""control-label"" th:text=""#{password}"">Password</label>
                        <input type=""password"" class=""form-control"" id=""password"" placeholder=""Password""
                               name='password' th:value=""*{password}""/>
                        <span th:if=""${#fields.hasErrors('password')}"" th:errors=""*{password}"">Password error</span>",Comment(),"password_reset.html의 형식은 17 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",4527DD070AD14C14AACC180940E12BC2,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",52,"    @PostMapping(""/SqlInjection/attack10"")
    @ResponseBody
    public AttackResult completed(@RequestParam String action_string) {
        return injectableQueryAvailability(action_string);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",63,"            try {
                Statement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
                ResultSet results = statement.executeQuery(query);

                if (results.getStatement() != null) {","java.sql.Statement.executeQuery()","SqlInjectionLesson10.java의 63 줄에서 injectableQueryAvailability() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FBBDDE6C4DB5F6B56E0BB6101ED07D15,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",52,"    @PostMapping(""/SqlInjection/attack10"")
    @ResponseBody
    public AttackResult completed(@RequestParam String action_string) {
        return injectableQueryAvailability(action_string);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",133,"                                        </div>
                                        <div class=""form-group"">
                                            <input type=""password"" name=""confirm_password_reg"" id=""confirm-password""
                                                   tabindex=""2"" class=""form-control"" placeholder=""Confirm Password""/>
                                        </div>","java.sql.Statement.executeQuery()","SqlInjectionAdvanced.html의 형식은 133 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E7C9548FA80341DC23622D7D388D93D7,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",52,"    @PostMapping(""/SqlInjection/attack10"")
    @ResponseBody
    public AttackResult completed(@RequestParam String action_string) {
        return injectableQueryAvailability(action_string);
    }",completed(0),"src/main/resources/lessons/ssrf/html/SSRF.html","SSRF.html",18,"                <table>
                    <tr>
                        <td><input type=""hidden"" id=""url1"" name=""url"" value=""images/tom.png""/></td>

                        <td><input","java.sql.Statement.executeQuery()","숨겨진 폼 필드가 SSRF.html의 18 줄에 사용됩니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",E6F8598ADC56CACB263A11487CB5FCB8,811489B8-AA5B-494C-9074-926A810A1421,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",148,"            return browserLocale.getLanguage();
        } else {
            String langHeader = request.getHeader(Headers.ACCEPT_LANGUAGE_STRING);
            if (null != langHeader) {
                log.debug(""browser locale {}"", langHeader);","javax.servlet.http.HttpServletRequest.getHeader()","src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",150,"            String langHeader = request.getHeader(Headers.ACCEPT_LANGUAGE_STRING);
            if (null != langHeader) {
                log.debug(""browser locale {}"", langHeader);
                return langHeader.substring(0,2);
            } else {","org.slf4j.Logger.debug()","AsciiDoctorTemplateResolver.java의 determineLanguage() 메서드는 확인되지 않은 사용자 입력을 150 줄에 있는 로그에 기록합니다. 공격자가 이 동작을 이용하여 로그 항목을 위조하거나 악성 내용을 로그에 삽입할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",75703A9EEFEDEE22D151D158148E4F00,61D4418B-F788-4C54-BFE4-D05E4769E29B,,,,Fri May 31 16:52:25 KST 2024,
High,High,API Abuse,<none>,"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",148,"            return browserLocale.getLanguage();
        } else {
            String langHeader = request.getHeader(Headers.ACCEPT_LANGUAGE_STRING);
            if (null != langHeader) {
                log.debug(""browser locale {}"", langHeader);","javax.servlet.http.HttpServletRequest.getHeader()","src/main/java/org/owasp/webgoat/lessons/idor/IDOREditOtherProfiile.java","IDOREditOtherProfiile.java",45,"    @PutMapping(path = ""/IDOR/profile/{userId}"", consumes = ""application/json"")
    @ResponseBody
    public AttackResult completed(@PathVariable(""userId"") String userId, @RequestBody UserProfile userSubmittedProfile) {

        String authUserId = (String) userSessionData.getValue(""idor-authenticated-user-id"");",Function: completed(),"모델 클래스에 대한 HTTP 요청 매개 변수 바인딩에 사용되는 프레임워크 바인더가 특정 속성을 허용하거나 허용하지 않도록 명백하게 구성되어 있지 않습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",B1485DBE2C527320E4E7D9AA979BA9AB,66F1C785-3EDF-4CF2-9217-3275D7BC5DB7,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,<none>,"src/main/java/org/owasp/webgoat/container/AsciiDoctorTemplateResolver.java","AsciiDoctorTemplateResolver.java",148,"            return browserLocale.getLanguage();
        } else {
            String langHeader = request.getHeader(Headers.ACCEPT_LANGUAGE_STRING);
            if (null != langHeader) {
                log.debug(""browser locale {}"", langHeader);","javax.servlet.http.HttpServletRequest.getHeader()","src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",258,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordZipSlip"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",Function: completed(),"PathTraversal.html의 형식은 258 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",565948E1F3F89F46542CB6F98232CD14,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",65,"                String checkUserQuery = ""select userid from sql_challenge_users where userid = '"" + username_reg + ""'"";
                Statement statement = connection.createStatement();
                ResultSet resultSet = statement.executeQuery(checkUserQuery);

                if (resultSet.next()) {","java.sql.Statement.executeQuery()","SqlInjectionChallenge.java의 65 줄에서 registerNewUser() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",AA6350CFFFB75E79ADDD323BCE2003B4,9B5F0161-88EC-4104-B70B-0182FEB53BF2,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,<none>,"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"target/classes/webgoat/static/js/libs/jquery.form.js","jquery.form.js",931,"};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.",Comment(),"암호 또는 암호 세부 정보를 시스템 또는 시스템 코드 안에 일반 텍스트로 저장하는 것은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println(""hello world"");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 ""운용 전"" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.","System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info(""hello world"");
  ...
}
","1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.",FA1668F9C81061945FC2B459758FEFCE,9DC93E75-BA94-4FA1-A177-ED1201EB29BC,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Time and State,"07.02. 취약한 API 사용","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",93,"            System.out.println(""- Error downloading"");
            e.printStackTrace();
            System.exit(1);
        }
    }",exit(),"MavenWrapperDownloader.java의 93 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.","MavenWrapperDownloader.java의 89 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.","웹 응용 프로그램을 통해 응용 프로그램 컨테이너를 종료하려 하는 것은 좋은 방법이 아닙니다. 종료 메서드 호출은 제거되지 않은 leftover debug code의 일부분이거나 Non-J2EE 응용 프로그램에서 가져온 코드일 것입니다.","웹 응용 프로그램 내에서 종료 메서드를 호출하지 마십시오. J2EE 응용 프로그램에 그와 같은 메서드 호출이 있으면 소프트웨어 상태가 불량해지므로 제거하는 것이 좋습니다. 인식 가능한 위험성 존재 여부를 떠나 그런 코드를 응용 프로그램에 남겨둘 합당한 이유를 찾기가 어렵습니다.","1. J2EE 응용 프로그램에 exit() 또는 halt() 호출이 있으면 다른 문제가 나타날 수 있습니다. exit() 또는 halt() 호출을 발견하면 개발자가 성급했거나 Non-J2EE 코드의 상당 부분이 보안 또는 품질 문제를 고려하지 않고 응용 프로그램에 도입되었다는 다른 증거도 찾아야 합니다.

2. J2EE가 아닌 Java 응용 프로그램을 감사하는 경우 J2EE의 부적절한 사례 범주가 사용자 환경에 적용되지 않을 수 있습니다. 이런 경우 Audit Guide를 사용하여 이러한 문제를 억제할 수 있습니다.",FD1EDFF91BC971672F2619B9711638B7,9D479AB5-B986-492C-B1F0-C11F2FD623F7,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Time and State,"07.02. 취약한 API 사용","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",89,"            downloadFileFromURL(url, outputFile);
            System.out.println(""Done"");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println(""- Error downloading"");",exit(),"MavenWrapperDownloader.java의 89 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.","MavenWrapperDownloader.java의 89 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.","웹 응용 프로그램을 통해 응용 프로그램 컨테이너를 종료하려 하는 것은 좋은 방법이 아닙니다. 종료 메서드 호출은 제거되지 않은 leftover debug code의 일부분이거나 Non-J2EE 응용 프로그램에서 가져온 코드일 것입니다.","웹 응용 프로그램 내에서 종료 메서드를 호출하지 마십시오. J2EE 응용 프로그램에 그와 같은 메서드 호출이 있으면 소프트웨어 상태가 불량해지므로 제거하는 것이 좋습니다. 인식 가능한 위험성 존재 여부를 떠나 그런 코드를 응용 프로그램에 남겨둘 합당한 이유를 찾기가 어렵습니다.","1. J2EE 응용 프로그램에 exit() 또는 halt() 호출이 있으면 다른 문제가 나타날 수 있습니다. exit() 또는 halt() 호출을 발견하면 개발자가 성급했거나 Non-J2EE 코드의 상당 부분이 보안 또는 품질 문제를 고려하지 않고 응용 프로그램에 도입되었다는 다른 증거도 찾아야 합니다.

2. J2EE가 아닌 Java 응용 프로그램을 감사하는 경우 J2EE의 부적절한 사례 범주가 사용자 환경에 적용되지 않을 수 있습니다. 이런 경우 Audit Guide를 사용하여 이러한 문제를 억제할 수 있습니다.",6434CC262765E1D95877D4B5BBB103D7,9D479AB5-B986-492C-B1F0-C11F2FD623F7,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Time and State,"07.02. 취약한 API 사용","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java","SqlInjectionChallenge.java",56,"    //assignment path is bounded to class so we use different http method :-)
    @ResponseBody
    public AttackResult registerNewUser(@RequestParam String username_reg, @RequestParam String email_reg, @RequestParam String password_reg) throws Exception {
        AttackResult attackResult = checkArguments(username_reg, email_reg, password_reg);
",registerNewUser(0),"src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",36,"        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");
            System.exit(1);
        }
        String username = args[0];",exit(),"PasswordResetLink.java의 36 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.","MavenWrapperDownloader.java의 89 줄, main()에 있는 exit() 호출은 웹 응용 프로그램 컨테이너를 종료합니다. 웹 응용 프로그램은 컨테이너를 종료하면 안됩니다.","웹 응용 프로그램을 통해 응용 프로그램 컨테이너를 종료하려 하는 것은 좋은 방법이 아닙니다. 종료 메서드 호출은 제거되지 않은 leftover debug code의 일부분이거나 Non-J2EE 응용 프로그램에서 가져온 코드일 것입니다.","웹 응용 프로그램 내에서 종료 메서드를 호출하지 마십시오. J2EE 응용 프로그램에 그와 같은 메서드 호출이 있으면 소프트웨어 상태가 불량해지므로 제거하는 것이 좋습니다. 인식 가능한 위험성 존재 여부를 떠나 그런 코드를 응용 프로그램에 남겨둘 합당한 이유를 찾기가 어렵습니다.","1. J2EE 응용 프로그램에 exit() 또는 halt() 호출이 있으면 다른 문제가 나타날 수 있습니다. exit() 또는 halt() 호출을 발견하면 개발자가 성급했거나 Non-J2EE 코드의 상당 부분이 보안 또는 품질 문제를 고려하지 않고 응용 프로그램에 도입되었다는 다른 증거도 찾아야 합니다.

2. J2EE가 아닌 Java 응용 프로그램을 감사하는 경우 J2EE의 부적절한 사례 범주가 사용자 환경에 적용되지 않을 수 있습니다. 이런 경우 Audit Guide를 사용하여 이러한 문제를 억제할 수 있습니다.",3B5E1A4BB33F797EF5F471F33309B061,9D479AB5-B986-492C-B1F0-C11F2FD623F7,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"05.05. 신뢰할 수 없는 데이터의 역직렬화","src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java","VulnerableComponentsLesson.java",41,"    @PostMapping(""/VulnerableComponents/attack1"")
    public @ResponseBody
    AttackResult completed(@RequestParam String payload) {
        XStream xstream = new XStream();
        xstream.setClassLoader(Contact.class.getClassLoader());",completed(0),"src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java","VulnerableComponentsLesson.java",52,"                payload = payload.replace(""+"", """").replace(""\r"", """").replace(""\n"", """").replace(""> "", "">"").replace("" <"", ""<"");
            }
            contact = (Contact) xstream.fromXML(payload);
        } catch (Exception ex) {
            return failed(this).feedback(""vulnerable-components.close"").output(ex.getMessage()).build();","com.thoughtworks.xstream.XStream.fromXML()","VulnerableComponentsLesson.java 파일은 52 줄에서 XStream을 사용하여 확인되지 않은 XML 입력을 역직렬화합니다. 런타임 시 사용자가 제어하는 XML 문서를 역직렬화하면 공격자가 서버에서 악성 코드를 실행할 수 있습니다.","런타임 시 사용자가 제어하는 개체 스트림을 역직렬화하면 공격자가 서버에서 임의의 코드를 실행하거나, 응용 프로그램 로직을 남용하거나, DOS(Denial of Service)를 일으킬 수 있습니다.","Java 직렬화는 개체 그래프를 개체 자체와 필요한 메타데이터를 포함한 바이트 스트림으로 바꿔 바이트 스트림에서 이를 재생성합니다. 개발자는 사용자 지정 코드를 생성하여 Java 개체 역직렬화 프로세스에 도움을 줄 수 있습니다. 이 프로세스에서는 역직렬화된 개체를 다른 개체 또는 프록시로 대체할 수 있습니다. 개체가 응용 프로그램으로 돌아가고 예상한 유형으로 지정되기 전에 재생성되는 동안 사용자 지정 역직렬화 프로세스가 발생합니다. 개발자가 예상한 유형을 적용하려 할 때는 이미 코드가 실행된 후일 수 있습니다. 

사용자 지정 역직렬화 루틴은 런타임 classpath에 있어야 하는 serializable 클래스에서 정의되며, 이는 공격자가 삽입할 수 없기 때문에 이러한 공격의 활용 가능성은 응용 프로그램 환경에서 사용할 수 있는 클래스에 따라 다릅니다. 유감스럽게도 일반적인 타사 클래스 또는 JDK 클래스도 JVM 리소스를 소모하거나, 악의적인 파일을 구축하거나, 임의의 코드를 실행하는 데 남용될 수 있습니다.




예제 1: 신뢰할 수 없는 개체 스트림을 역직렬화하는 응용 프로그램은 응용 프로그램을 손상시킬 수 있습니다.

InputStream is = request.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
MyObject obj = (MyObject) ois.readObject();
","가능하면 개체 스트림의 콘텐트 확인 없이 신뢰할 수 없는 데이터를 역직렬화하지 마십시오. 역직렬화 중인 클래스를 확인하려면 미리 보기 역직렬화 패턴을 사용해야 합니다. 

먼저 개체 스트림에 클래스 설명 메타데이터가 포함된 후 해당 멤버 필드의 직렬화된 바이트가 포함됩니다. Java 직렬화 프로세스를 통해 개발자는 클래스 설명을 읽고 개체의 역직렬화를 진행 또는 중단할지 여부를 결정할 수 있습니다. 그러기 위해서는 하위 클래스 java.io.ObjectInputStream을 지정하고 resolveClass(ObjectStreamClass desc) 메서드의 사용자 지정 구현을 제공해야 합니다. 여기서 클래스 검증 및 확인을 수행합니다.

Apache Commons IO(org.apache.commons.io.serialization.ValidatingObjectInputStream)와 같이 쉽게 사용 가능한 미리 보기 패턴의 기존 구현이 있습니다. 항상 엄격한 허용 목록 접근 방식을 사용하여 필요한 유형만 역직렬화해야 합니다. 공격자가 사용 가능한 여러 가젯을 사용해 거부 목록을 무시할 수 있으므로 거부 목록 접근 방식은 사용하지 않는 것이 좋습니다. 또한 코드 실행을 수행하기 위한 일부 클래스는 공개적으로 알려져 있더라도 알 수 없거나 숨겨진 클래스가 있을 수 있으므로 항상 허용 목록 접근 방식을 사용하는 것이 좋습니다. 허용 목록에서 허용되는 모든 클래스를 감사하여 역직렬화해도 안전한지를 확인해야 합니다.

역직렬화를 라이브러리 또는 프레임워크에서 수행할 경우(예: JMX, RMI, JMS, HTTP Invoker를 사용할 때) 개발자가 제어할 수 없는 상황이므로 앞선 권장 사항이 유용하지 않습니다. 그럴 경우 이러한 프로토콜이 다음 요구 사항을 충족하는지 확인해야 합니다.

- 공개적으로 노출되지 않음
- 인증 사용
- 무결성 검사 사용
- 암호화 사용

또한 Fortify Runtime에서는 응용 프로그램에서 ObjectInputStream로부터 역직렬화를 수행할 때마다 적용되는 보안 제어를 제공합니다. 이는 응용 프로그램 코드뿐 아니라 라이브러리 및 프레임워크 코드도 해당 유형의 공격으로부터 보호합니다.","1. 기존 ObjectInputStream을 구현하는 데 취약점이 있고 DoS(Denial of Service) 공격을 수행하는 데 사용될 수 있는 기본 클래스에 대한 거부 목록을 구현하는 것이 어렵기 때문에 미리 보기 ObjectInputStream이 구현되더라도 이 문제는 보고되지만 그 심각도는 Medium으로 낮춰집니다.",7F03CE88BFEC1BE527092446C93EB6D7,3B3C6BD3-2ACF-46BE-AB6B-1719C0D8940B,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Input Validation and Representation,"05.05. 신뢰할 수 없는 데이터의 역직렬화","src/main/java/org/owasp/webgoat/lessons/deserialization/InsecureDeserializationTask.java","InsecureDeserializationTask.java",46,"    @PostMapping(""/InsecureDeserialization/task"")
    @ResponseBody
    public AttackResult completed(@RequestParam String token) throws IOException {
        String b64token;
        long before;",completed(0),"src/main/java/org/owasp/webgoat/lessons/deserialization/InsecureDeserializationTask.java","InsecureDeserializationTask.java",56,"        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(b64token)))) {
            before = System.currentTimeMillis();
            Object o = ois.readObject();
            if (!(o instanceof VulnerableTaskHolder)) {
                if (o instanceof String) {","java.io.ObjectInputStream.readObject()","런타임 시 사용자가 제어하는 개체 스트림을 역직렬화하면 공격자가 서버에서 임의의 코드를 실행하거나, 응용 프로그램 로직을 남용하거나, DOS(Denial of Service)를 일으킬 수 있습니다.","런타임 시 사용자가 제어하는 개체 스트림을 역직렬화하면 공격자가 서버에서 임의의 코드를 실행하거나, 응용 프로그램 로직을 남용하거나, DOS(Denial of Service)를 일으킬 수 있습니다.","Java 직렬화는 개체 그래프를 개체 자체와 필요한 메타데이터를 포함한 바이트 스트림으로 바꿔 바이트 스트림에서 이를 재생성합니다. 개발자는 사용자 지정 코드를 생성하여 Java 개체 역직렬화 프로세스에 도움을 줄 수 있습니다. 이 프로세스에서는 역직렬화된 개체를 다른 개체 또는 프록시로 대체할 수 있습니다. 개체가 응용 프로그램으로 돌아가고 예상한 유형으로 지정되기 전에 재생성되는 동안 사용자 지정 역직렬화 프로세스가 발생합니다. 개발자가 예상한 유형을 적용하려 할 때는 이미 코드가 실행된 후일 수 있습니다. 

사용자 지정 역직렬화 루틴은 런타임 classpath에 있어야 하는 serializable 클래스에서 정의되며, 이는 공격자가 삽입할 수 없기 때문에 이러한 공격의 활용 가능성은 응용 프로그램 환경에서 사용할 수 있는 클래스에 따라 다릅니다. 유감스럽게도 일반적인 타사 클래스 또는 JDK 클래스도 JVM 리소스를 소모하거나, 악의적인 파일을 구축하거나, 임의의 코드를 실행하는 데 남용될 수 있습니다.




예제 1: 신뢰할 수 없는 개체 스트림을 역직렬화하는 응용 프로그램은 응용 프로그램을 손상시킬 수 있습니다.

InputStream is = request.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
MyObject obj = (MyObject) ois.readObject();
","가능하면 개체 스트림의 콘텐트 확인 없이 신뢰할 수 없는 데이터를 역직렬화하지 마십시오. 역직렬화 중인 클래스를 확인하려면 미리 보기 역직렬화 패턴을 사용해야 합니다. 

먼저 개체 스트림에 클래스 설명 메타데이터가 포함된 후 해당 멤버 필드의 직렬화된 바이트가 포함됩니다. Java 직렬화 프로세스를 통해 개발자는 클래스 설명을 읽고 개체의 역직렬화를 진행 또는 중단할지 여부를 결정할 수 있습니다. 그러기 위해서는 하위 클래스 java.io.ObjectInputStream을 지정하고 resolveClass(ObjectStreamClass desc) 메서드의 사용자 지정 구현을 제공해야 합니다. 여기서 클래스 검증 및 확인을 수행합니다.

Apache Commons IO(org.apache.commons.io.serialization.ValidatingObjectInputStream)와 같이 쉽게 사용 가능한 미리 보기 패턴의 기존 구현이 있습니다. 항상 엄격한 허용 목록 접근 방식을 사용하여 필요한 유형만 역직렬화해야 합니다. 공격자가 사용 가능한 여러 가젯을 사용해 거부 목록을 무시할 수 있으므로 거부 목록 접근 방식은 사용하지 않는 것이 좋습니다. 또한 코드 실행을 수행하기 위한 일부 클래스는 공개적으로 알려져 있더라도 알 수 없거나 숨겨진 클래스가 있을 수 있으므로 항상 허용 목록 접근 방식을 사용하는 것이 좋습니다. 허용 목록에서 허용되는 모든 클래스를 감사하여 역직렬화해도 안전한지를 확인해야 합니다.

역직렬화를 라이브러리 또는 프레임워크에서 수행할 경우(예: JMX, RMI, JMS, HTTP Invoker를 사용할 때) 개발자가 제어할 수 없는 상황이므로 앞선 권장 사항이 유용하지 않습니다. 그럴 경우 이러한 프로토콜이 다음 요구 사항을 충족하는지 확인해야 합니다.

- 공개적으로 노출되지 않음
- 인증 사용
- 무결성 검사 사용
- 암호화 사용

또한 Fortify Runtime에서는 응용 프로그램에서 ObjectInputStream로부터 역직렬화를 수행할 때마다 적용되는 보안 제어를 제공합니다. 이는 응용 프로그램 코드뿐 아니라 라이브러리 및 프레임워크 코드도 해당 유형의 공격으로부터 보호합니다.","1. 기존 ObjectInputStream을 구현하는 데 취약점이 있고 DoS(Denial of Service) 공격을 수행하는 데 사용될 수 있는 기본 클래스에 대한 거부 목록을 구현하는 것이 어렵기 때문에 미리 보기 ObjectInputStream이 구현되더라도 이 문제는 보고되지만 그 심각도는 Medium으로 낮춰집니다.",5C689CE7F25C670228BE531CE8A9CD5D,65F4371B-9180-4631-AC91-C06B07C5FC480,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","SqlInjectionLesson2.java",55,"    @PostMapping(""/SqlInjection/attack2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","SqlInjectionLesson2.java",68,"
            if (results.getString(""department"").equals(""Marketing"")) {
                output.append(""<span class='feedback-positive'>"" + query + ""</span>"");
                output.append(SqlInjectionLesson8.generateTable(results));
                return success(this).feedback(""sql-injection.2.success"").output(output.toString()).build();","java.lang.StringBuilder.append()","SqlInjectionLesson2.java의 줄 68에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",0AD711CD8FFBE1785BE430F839AF55F1,F2BD85B8-504E-4D52-967C-E00A043BAFAD,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",71,"                results.first();
                if (results.getString(""department"").equals(""Sales"")) {
                    output.append(""<span class='feedback-positive'>"" + query + ""</span>"");
                    output.append(SqlInjectionLesson8.generateTable(results));
                    return success(this).output(output.toString()).build();","java.lang.StringBuilder.append()","SqlInjectionLesson3.java의 줄 71에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",0A4EEC9AA038747E7040A72F6E3E6054,F2BD85B8-504E-4D52-967C-E00A043BAFAD,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",42,"
        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();",mkdirs(),"ProfileUploadBase.java의 execute() 메서드는 42 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",7D491FF9D0D8BFE3FBB61EAE932286BE,ED57A0C1-5039-43E7-B753-28128F786E8B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",56,"    @PostMapping(""/SqlInjection/attack3"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",63,"        File targetDirectory = new File(webGoatHomeDirectory, ""/ClientSideFiltering"");
        if (!targetDirectory.exists()) {
            targetDirectory.mkdir();
        }
        try {",mkdir(),"Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",14CE8995663BEEDCC400596D6B5F8C0B,ED57A0C1-5039-43E7-B753-28128F786E8B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",69,"                // user completes lesson if column phone exists
                if (results.first()) {
                    output.append(""<span class='feedback-positive'>"" + query + ""</span>"");
                    return success(this).output(output.toString()).build();
                } else {","java.lang.StringBuilder.append()","SqlInjectionLesson4.java의 줄 69에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",B039F5783386CD6B8400E6FDD4441175,F2BD85B8-504E-4D52-967C-E00A043BAFAD,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",48,"    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();
    }
",mkdirs(),"ProfileUploadRetrieval.java의 ProfileUploadRetrieval() 메서드는 48 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",6441B8225E05FBC6365476E6D2469593,ED57A0C1-5039-43E7-B753-28128F786E8B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",75,"        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());
        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));
        log.debug(""File saved to {}"", new File(destinationDir, myFile.getOriginalFilename()));",mkdirs(),"FileServer.java의 importFile() 메서드는 75 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",B789F66B6486AE3C31DCF9501F50C2D5,ED57A0C1-5039-43E7-B753-28128F786E8B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",105,"            modelAndView.addObject(""uploadSuccess"", request.getParameter(""uploadSuccess""));
        }
        changeIndicatorFile.delete();

        var uploadedFiles = new ArrayList<>();",delete(),"FileServer.java의 getFiles() 메서드는 105 줄의 delete()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",C8DD2A8D287FBA319245DBCB9C142C51,DA3D93EF-F156-436B-BC4B-4BBFB3D1404B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java","MvcConfiguration.java",63,"        File file = new File(fileLocation);
        if (!file.exists()) {
            file.mkdirs();
        }
    }",mkdirs(),"MvcConfiguration.java의 createDirectory() 메서드는 63 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",77731CD542415C4CB21FC0AD230752BF,ED57A0C1-5039-43E7-B753-28128F786E8B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",56,"    @PostMapping(""/SqlInjection/attack4"")
    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",69,"        File targetDirectory = new File(webGoatHomeDirectory, ""/XXE/"" + user.getUsername());
        if (!targetDirectory.exists()) {
            targetDirectory.mkdirs();
        }
        try {",mkdirs(),"BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 메서드는 69 줄의 mkdirs()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",27A0F6A72F0135FA7E8D05D271796843,ED57A0C1-5039-43E7-B753-28128F786E8B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"04.03. 부적절한 예외처리","src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson5a.java","CrossSiteScriptingLesson5a.java",54,"    public AttackResult completed(@RequestParam Integer QTY1,
                                  @RequestParam Integer QTY2, @RequestParam Integer QTY3,
                                  @RequestParam Integer QTY4, @RequestParam String field1,
                                  @RequestParam String field2) {
",completed(4),"src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson5a.java","CrossSiteScriptingLesson5a.java",66,"        StringBuilder cart = new StringBuilder();
        cart.append(""Thank you for shopping at WebGoat. <br />Your support is appreciated<hr />"");
        cart.append(""<p>We have charged credit card:"" + field1 + ""<br />"");
        cart.append(""                             ------------------- <br />"");
        cart.append(""                               $"" + totalSale);","java.lang.StringBuilder.append()","CrossSiteScriptingLesson5a.java의 줄 66에 있는 append() 호출은 기본 백업 배열 크기(16)로 초기화된 StringBuilder 또는 StringBuffer 인스턴스에 신뢰할 수 없는 데이터를 추가합니다. 그러면 JVM이 힙 메모리 공간을 과소비하게 될 수 있습니다.","Salaries.java의 copyFiles() 메서드는 63 줄의 mkdir()에 의해 반환된 값을 무시합니다. 이로 인해 프로프램이 예기치 못한 상태와 조건을 간과할 수도 있습니다.","Java 프로그래머가 수많은 java.io 클래스의 일부인 read() 및 관련 메서드를 잘못 해석하는 것은 드문 일이 아닙니다. Java의 대부분의 오류와 비정상적인 이벤트는 예외 발생으로 이어집니다. (이는 Java가 C 등의 언어보다 나은 장점 중 하나입니다. 예외로 인해 프로그래머는 무엇이 잘못되었는지 쉽게 판단할 수 있습니다.) 하지만 stream 및 reader 클래스는 소량의 데이터만 사용할 때는 이를 비정상이나 예외로 간주하지 않습니다. 이 클래스는 단순히 소량의 데이터를 반환 버퍼에 추가하고 반환 값을 읽어들인 바이트 수 또는 문자 수로 설정합니다. 반환되는 데이터 양이 요청한 데이터 양과 같다고 보장할 수 있습니다.

이 동작으로 인해 프로그래머가 read() 및 다른 IO 메서드의 반환 값을 검사하여 데이터를 예상한 양만큼 받도록 하는 것이 중요해집니다.



예제: 다음 코드는 사용자 집합을 차례로 돌면서 각 사용자의 개인 데이터 파일을 읽습니다. 프로그래머는 파일 크기가 항상 정확히 1KB 라고 가정하므로 read()의 반환 값을 무시합니다. 공격자가 작은 파일을 만들면 프로그램은 이전 사용자의 나머지 데이터를 재활용하여 이 데이터가 공격자의 소유인 것처럼 처리합니다.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
","
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + ""/"" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead < 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException(""file is unusually small"");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


참조: 이 문제를 해결하는 방법은 비교적 복잡하기 때문에 읽기 전에 파일 크기를 확인하는 등의 보다 간단한 방법을 사용하고자 할 수 있습니다. 그러나 이러한 방법을 사용하면 응용 프로그램이 file system race condition에 취약해져서 공격자가 파일 크기를 확인하고 파일에서 데이터를 읽기 위해 호출하는 사이에 올바른 형식의 파일을 악성 파일로 대체할 수 있습니다.","1. ""그런 일은 절대 일어날 수 없습니다. 왜냐하면...""이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.",579DBEA7BD16E59C2CDC436F61B7865D,F2BD85B8-504E-4D52-967C-E00A043BAFAD,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/jwt/JWTFinalEndpoint.java","JWTFinalEndpoint.java",118,"                }
            } catch (JwtException e) {
                return failed(this).feedback(""jwt-invalid-token"").output(e.toString()).build();
            }
        }",Read e(),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTFinalEndpoint.java","JWTFinalEndpoint.java",118,"                }
            } catch (JwtException e) {
                return failed(this).feedback(""jwt-invalid-token"").output(e.toString()).build();
            }
        }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",4F14080BF102B0976388280454DE54F1,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",81,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage() + ""<br> Your query was: "" + query).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",54,"    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",99BBC0E51399EDD6DCCD1F1D04255D2B,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",81,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage() + ""<br> Your query was: "" + query).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","target/classes/application-webwolf.properties","application-webwolf.properties",1,"server.error.include-stacktrace=always
server.error.path=/error.html
server.port=${webwolf.port:9090}","server.error.include-stacktrace()","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",37B36EAEA9DA9E85E93B2E40FC0F11F2,0DF8AF25-8291-4D4A-AD05-AB2072AD6A81,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",95,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage() + YOUR_QUERY_WAS + query).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java","SqlOnlyInputValidation.java",53,"        }
        AttackResult attackResult = lesson6a.injectableQuery(userId);
        return new AttackResult(attackResult.isLessonCompleted(), attackResult.getFeedback(), attackResult.getOutput(), getClass().getSimpleName(), true);
    }
}",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",230CF82EF62A4A10B186007C16578B7B,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/MailAssignment.java","MailAssignment.java",65,"                restTemplate.postForEntity(webWolfURL, mailEvent, Object.class);
            } catch (RestClientException e ) {
                return informationMessage(this).feedback(""webwolf.email_failed"").output(e.getMessage()).build();
            }
            return informationMessage(this).feedback(""webwolf.email_send"").feedbackArgs(email).build();","org.springframework.core.NestedRuntimeException.getMessage()","src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/MailAssignment.java","MailAssignment.java",65,"                restTemplate.postForEntity(webWolfURL, mailEvent, Object.class);
            } catch (RestClientException e ) {
                return informationMessage(this).feedback(""webwolf.email_failed"").output(e.getMessage()).build();
            }
            return informationMessage(this).feedback(""webwolf.email_send"").feedbackArgs(email).build();",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",F46F7F90507A25A5ACE7E18F7682D5DB,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",79,"
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage()).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",57,    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",D985B0C74D6F4FB372896EC8E0AC2CF8,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",95,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage() + YOUR_QUERY_WAS + query).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java","SqlOnlyInputValidationOnKeywords.java",54,"        }
        AttackResult attackResult = lesson6a.injectableQuery(userId);
        return new AttackResult(attackResult.isLessonCompleted(), attackResult.getFeedback(), attackResult.getOutput(), getClass().getSimpleName(), true);
    }
}",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",D6CB87797727C6A953EAE890D04912B7,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",92,"            } catch (SQLException sqle) {

                return failed(this).output(sqle.getMessage() + ""<br> Your query was: "" + queryString.replace(""?"", login_count)).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",52,"    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",DA62026215230969B4BE3B7C58F81DAE,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",101,"            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {
            log.error(""Image not found"", e);","java.io.File.listFiles()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",101,"            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {
            log.error(""Image not found"", e);","org.springframework.http.ResponseEntity.BodyBuilder.body()","ProfileUploadRetrieval.java의 getProfilePicture() 함수는 101 줄의 body()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. body()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",E6EA7FD618883135F8FBC0803E00BBCD,AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java","CSRFFeedback.java",71,"            objectMapper.readValue(feedback.getBytes(), Map.class);
        } catch (IOException e) {
            return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
        }
        boolean correctCSRF = requestContainsWebGoatCookie(request.getCookies()) && request.getContentType().contains(MediaType.TEXT_PLAIN_VALUE);",Read e(),"src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java","CSRFFeedback.java",71,"            objectMapper.readValue(feedback.getBytes(), Map.class);
        } catch (IOException e) {
            return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
        }
        boolean correctCSRF = requestContainsWebGoatCookie(request.getCookies()) && request.getContentType().contains(MediaType.TEXT_PLAIN_VALUE);",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",155F86F437DD35A0AC5E642E96DD9938,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java","CSRFFeedback.java",71,"            objectMapper.readValue(feedback.getBytes(), Map.class);
        } catch (IOException e) {
            return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
        }
        boolean correctCSRF = requestContainsWebGoatCookie(request.getCookies()) && request.getContentType().contains(MediaType.TEXT_PLAIN_VALUE);",Read e(),"src/main/resources/application-webwolf.properties","application-webwolf.properties",1,"server.error.include-stacktrace=always
server.error.path=/error.html
server.port=${webwolf.port:9090}","server.error.include-stacktrace()","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",37B36EAEA9DA9E85E93B2E40FC0F11F1,0DF8AF25-8291-4D4A-AD05-AB2072AD6A81,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",96,"                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
                        .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                        .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
            }","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java의 getProfilePicture() 함수는 96 줄의 location()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. location()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",929904495CB59A19ABF75D40E19D0EE4,AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",85,"
        } catch (Exception e) {
            return failed(this).output(""<span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",53,    @ResponseBody
    public AttackResult completed(@RequestParam String action_string) {
        return injectableQueryAvailability(action_string);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",39A4E35F9FDBBFDBCCED6B8DC02256A4,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",95,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage() + ""<br> Your query was: "" + queryString.replace(""?"", login_count)).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java","SqlInjectionLesson5b.java",52,"    @ResponseBody
    public AttackResult completed(@RequestParam String userid, @RequestParam String login_count, HttpServletRequest request) throws IOException {
        return injectableQuery(login_count, userid);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",B0E45353707A038DB254B8D36D2B6555,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","SpoofCookieAssignment.java",109,"        } catch (Exception e) {
            // for providing some instructive guidance, we won't return 4xx error here
            return failed(this).output(e.getMessage()).build();
        }
        if (users.containsKey(cookieUsername)) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","SpoofCookieAssignment.java",73,"            return credentialsLoginFlow(username, password, response);
        } else {
            return cookieLoginFlow(cookieValue);
        }
    }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",BAFB9F4402E6986469C40D67C47ADBA5,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",84,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage() + ""<br> Your query was: "" + query).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java","SqlInjectionLesson5a.java",54,"    @ResponseBody
    public AttackResult completed(@RequestParam String account, @RequestParam String operator, @RequestParam String injection) {
        return injectableQuery(account + "" "" + operator + "" "" + injection);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",899648E3B8C5E0BBA4F18EE9BE9F95EA,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",89,"                }
            } catch (SQLException e) {
                return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
            }
","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",55,"    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",CFEDF9F1D4880686CD27E2A1380B0302,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",77,"            }
        } catch (Exception e) {
            error = ExceptionUtils.getStackTrace(e);
        }
        return failed(this).output(error).build();",Read e(),"src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",79,"            error = ExceptionUtils.getStackTrace(e);
        }
        return failed(this).output(error).build();
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",F30016AD21C1DA8CE86D201D63BC6224,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",112,"            return ok(failed(this).feedback(""jwt-refresh-not-tom"").feedbackArgs(user).build());
        } catch (ExpiredJwtException e) {
            return ok(failed(this).output(e.getMessage()).build());
        } catch (JwtException e) {
            return ok(failed(this).feedback(""jwt-invalid-token"").build());","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",112,"            return ok(failed(this).feedback(""jwt-refresh-not-tom"").feedbackArgs(user).build());
        } catch (ExpiredJwtException e) {
            return ok(failed(this).output(e.getMessage()).build());
        } catch (JwtException e) {
            return ok(failed(this).feedback(""jwt-invalid-token"").build());",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",E030F0A7D821A420C924E25872D575A1,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",92,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage() + YOUR_QUERY_WAS + query).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidation.java","SqlOnlyInputValidation.java",53,"        }
        AttackResult attackResult = lesson6a.injectableQuery(userId);
        return new AttackResult(attackResult.isLessonCompleted(), attackResult.getFeedback(), attackResult.getOutput(), getClass().getSimpleName(), true);
    }
}",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",1FC70DF4F58351860C34349CAB34C9B4,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",112,"            return ok(failed(this).feedback(""jwt-refresh-not-tom"").feedbackArgs(user).build());
        } catch (ExpiredJwtException e) {
            return ok(failed(this).output(e.getMessage()).build());
        } catch (JwtException e) {
            return ok(failed(this).feedback(""jwt-invalid-token"").build());","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",112,"            return ok(failed(this).feedback(""jwt-refresh-not-tom"").feedbackArgs(user).build());
        } catch (ExpiredJwtException e) {
            return ok(failed(this).output(e.getMessage()).build());
        } catch (JwtException e) {
            return ok(failed(this).feedback(""jwt-invalid-token"").build());","org.springframework.http.ResponseEntity.ok()","JWTRefreshEndpoint.java의 checkout() 함수는 112 줄의 ok()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. ok()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",826C55FE4F115F012B295336392EC928,AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java","SqlInjectionLesson5.java",80,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage() + ""<br> Your query was: "" + query).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java","SqlInjectionLesson5.java",67,    public AttackResult completed(String query) {
        createUser();
        return injectableQuery(query);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",B0C24527BCD9EE675D2AA9BF9DD975BC,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java","CSRFFeedback.java",71,"            objectMapper.readValue(feedback.getBytes(), Map.class);
        } catch (IOException e) {
            return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
        }
        boolean correctCSRF = requestContainsWebGoatCookie(request.getCookies()) && request.getContentType().contains(MediaType.TEXT_PLAIN_VALUE);","org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace()","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFFeedback.java","CSRFFeedback.java",71,"            objectMapper.readValue(feedback.getBytes(), Map.class);
        } catch (IOException e) {
            return failed(this).feedback(ExceptionUtils.getStackTrace(e)).build();
        }
        boolean correctCSRF = requestContainsWebGoatCookie(request.getCookies()) && request.getContentType().contains(MediaType.TEXT_PLAIN_VALUE);",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",237BF0E8D0CC653FF9D1F2D1C252925A,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",68,    @ResponseBody
    public String getFileLocation() {
        return fileLocation;
    }
,"Read this.fileLocation()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",68,    @ResponseBody
    public String getFileLocation() {
        return fileLocation;
    }
,"Return this.fileLocation()","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",FC5039F141E4B7A6421ED6E24BF6D073,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",85,"        } catch (Exception e) {
            System.err.println(e.getMessage());
            return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",56,"    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",43F65F902B4DF03F659AEF5D9D6029D7,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",77,"            }
        } catch (Exception e) {
            error = ExceptionUtils.getStackTrace(e);
        }
        return failed(this).output(error).build();","org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace()","src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",79,"            error = ExceptionUtils.getStackTrace(e);
        }
        return failed(this).output(error).build();
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",CFA636D041B15CDDFFB5BBA5FB3653EE,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",100,"            }
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java의 getProfilePicture() 함수는 100 줄의 location()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. location()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",3100CB7E3C1438E61C17CDC86B9DB51E,AEEA9D45-DBBD-4EC2-88EA-CB2D3173FCCD0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",77,"                }
            } catch (Exception e) {
                error = ExceptionUtils.getStackTrace(e);
                attackResult = failed(this).feedback(""xxe.content.type.feedback.xml"").output(error).build();
            }","org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace()","src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",82,        }

        return attackResult;
    }
,Return attackResult(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",625D44C94264E535DCCC6CDB9DB20B0E,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",53,"
        } catch (IOException e) {
            return failed(this).output(e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java","ProfileUploadFix.java",31,"            @RequestParam(""uploadedFileFix"") MultipartFile file,
            @RequestParam(value = ""fullNameFix"", required = false) String fullName) {
        return super.execute(file, fullName != null ? fullName.replace(""../"", """") : """");
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",FD0756D23D590962CD6E84E31820F3BF,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","SqlInjectionLesson2.java",75,"            }
        } catch (SQLException sqle) {
            return failed(this).feedback(""sql-injection.2.failed"").output(sqle.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java","SqlInjectionLesson2.java",56,    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",F2852734D74FAAD385B25A516E58D462,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",78,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",57,    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",81401AE0F5A1D717DE5F4DB45481F9CD,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",92,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage() + YOUR_QUERY_WAS + query).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlOnlyInputValidationOnKeywords.java","SqlOnlyInputValidationOnKeywords.java",54,"        }
        AttackResult attackResult = lesson6a.injectableQuery(userId);
        return new AttackResult(attackResult.isLessonCompleted(), attackResult.getFeedback(), attackResult.getOutput(), getClass().getSimpleName(), true);
    }
}",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",32226568FC8924D66E6D27E364F7F756,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",78,"            } catch (SQLException e) {
                System.err.println(e.getMessage());
                return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
            }
","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",56,"    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryIntegrity(name, auth_tan);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",43F65F902B4DF03F659AEF5D9D6029D6,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",57,"                        .replaceAll(""\n"",""<br>""); // Otherwise the \n gets escaped in the response
            } catch (MalformedURLException e) {
                return getFailedResult(e.getMessage());
            } catch (IOException e) {
                //in case the external site is down, the test and lesson should still be ok","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",47,    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",4AAF31D3235605F26483E62502E5E1E4,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",53,"
        } catch (IOException e) {
            return failed(this).output(e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java","ProfileUpload.java",29,"    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFile"") MultipartFile file, @RequestParam(value = ""fullName"", required = false) String fullName) {
        return super.execute(file, fullName);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",FEEF25132260F685151FFAF38FF89026,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","JWTVotesEndpoint.java",180,"                }
            } catch (JwtException e) {
                return failed(this).feedback(""jwt-invalid-token"").output(e.toString()).build();
            }
        }",Read e(),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","JWTVotesEndpoint.java",180,"                }
            } catch (JwtException e) {
                return failed(this).feedback(""jwt-invalid-token"").output(e.toString()).build();
            }
        }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",1E995EC78E90C0B489F36536986BFC0C,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",92,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage() + YOUR_QUERY_WAS + query).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",52,"    @ResponseBody
    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --
    }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",9FECB299D077DB3FD8DCDC794E05D654,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",95,"            comments.addComment(comment, false);
        } catch (Exception e) {
            return failed(this).output(e.toString()).build();
        }
        return failed(this).build();",Read e(),"src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",95,"            comments.addComment(comment, false);
        } catch (Exception e) {
            return failed(this).output(e.toString()).build();
        }
        return failed(this).build();",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",3018975C7E2504C8E2FDF05DF73CA07D,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",82,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java","SqlInjectionLesson3.java",57,    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",D3EC6880409A0660A85E7BCB48CBC085,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",93,"
        } catch (Exception e) {
            return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",55,"    @ResponseBody
    public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {
        return injectableQueryConfidentiality(name, auth_tan);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",CFEDF9F1D4880686CD27E2A1380B0303,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",93,"
        } catch (Exception e) {
            return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }
    }","java.lang.Throwable.getMessage()","src/main/resources/application-webgoat.properties","application-webgoat.properties",1,"server.error.include-stacktrace=always
server.error.path=/error.html
server.servlet.context-path=/WebGoat","server.error.include-stacktrace()","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",7E36960DB6F36C20D6A4AA5A190380EC,0DF8AF25-8291-4D4A-AD05-AB2072AD6A81,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",78,"            } catch (SQLException e) {
                if (tableExists(connection)) {
                    return failed(this).output(""<span class='feedback-negative'>"" + e.getMessage() + ""</span><br>"" + output.toString()).build();
                } else {
                    return success(this).feedback(""sql-injection.10.success"").build();","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",53,    @ResponseBody
    public AttackResult completed(@RequestParam String action_string) {
        return injectableQueryAvailability(action_string);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",39A4E35F9FDBBFDBCCED6B8DC02256A3,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",77,"                }
            } catch (Exception e) {
                error = ExceptionUtils.getStackTrace(e);
                attackResult = failed(this).feedback(""xxe.content.type.feedback.xml"").output(error).build();
            }",Read e(),"src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",82,        }

        return attackResult;
    }
,Return attackResult(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",37A3463B8AFF5632E97F6092649F396F,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/passwordreset/SimpleMailAssignment.java","SimpleMailAssignment.java",93,"                restTemplate.postForEntity(webWolfURL, mailEvent, Object.class);
            } catch (RestClientException e) {
                return informationMessage(this).feedback(""password-reset-simple.email_failed"").output(e.getMessage()).build();
            }
            return informationMessage(this).feedback(""password-reset-simple.email_send"").feedbackArgs(email).build();","org.springframework.core.NestedRuntimeException.getMessage()","src/main/java/org/owasp/webgoat/lessons/passwordreset/SimpleMailAssignment.java","SimpleMailAssignment.java",73,"    public AttackResult resetPassword(@RequestParam String emailReset) {
        String email = ofNullable(emailReset).orElse(""unknown@webgoat.org"");
        return sendEmail(extractUsername(email), email);
    }
",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",F2B2902B7D0F5C6EAC643B1226B47429,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",75,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage()).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",57,    @ResponseBody
    public AttackResult completed(@RequestParam String query) {
        return injectableQuery(query);
    }
,Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",E2E2889F243E5FE2386BFFF46B2238A9,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java","SqlInjectionLesson4.java",75,"                }
            } catch (SQLException sqle) {
                return failed(this).output(sqle.getMessage()).build();
            }
        } catch (Exception e) {","java.lang.Throwable.getMessage()","target/classes/application-webgoat.properties","application-webgoat.properties",1,"server.error.include-stacktrace=always
server.error.path=/error.html
server.servlet.context-path=/WebGoat","server.error.include-stacktrace()","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",7E36960DB6F36C20D6A4AA5A190380ED,0DF8AF25-8291-4D4A-AD05-AB2072AD6A81,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",95,"            }
        } catch (Exception e) {
            return failed(this).output(this.getClass().getName() + "" : "" + e.getMessage() + YOUR_QUERY_WAS + query).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java","SqlInjectionLesson6a.java",52,"    @ResponseBody
    public AttackResult completed(@RequestParam(value=""userid_6a"")  String userId) {
        return injectableQuery(userId);
        // The answer: Smith' union select userid,user_name, password,cookie,cookie, cookie,userid from user_system_data --
    }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",068CD987B813838FBA185DFF60EC0673,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",67,"            return isSolved(currentImage, getProfilePictureAsBase64());
        } catch (IOException e) {
            return failed(this).output(e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",40,"            return failed(this).feedback(""path-traversal-zip-slip.no-zip"").build();
        } else {
            return processZipUpload(file);
        }
    }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",8FDA61133CF2262FD279C744209231AF,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",53,"
        } catch (IOException e) {
            return failed(this).output(e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java","ProfileUploadRemoveUserInput.java",27,"    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileRemoveUserInput"") MultipartFile file) {
        return super.execute(file, file.getOriginalFilename());
    }
}",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",CC4A1036E8A98FBBD0ED9458923FB219,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출, 06.02. 제거되지 않고 남은 디버그 코드","src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java","JWTSecretKeyEndpoint.java",92,"            }
        } catch (Exception e) {
            return failed(this).feedback(""jwt-invalid-token"").output(e.getMessage()).build();
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java","JWTSecretKeyEndpoint.java",92,"            }
        } catch (Exception e) {
            return failed(this).feedback(""jwt-invalid-token"").output(e.getMessage()).build();
        }
    }",Return(),"시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","시스템 데이터 또는 디버깅 정보가 노출되면 공격자가 시스템을 파악하고 공격 계획을 세우는 것이 수월해집니다.","외부 정보는 시스템 데이터 또는 디버그 정보가 소켓이나 네트워크 연결을 통해 프로그램에서 원격 시스템으로 이동할 때 누출됩니다. 외부 누출 시 운영 체제, 전체 경로 이름, 사용자 이름의 유무 또는 구성 파일 위치에 대한 특정 데이터가 노출되어 공격자가 보다 쉽게 공격할 수 있습니다. 또한 공격자가 접근하기 더 어려운 내부 정보가 누출되는 것보다 이 문제가 더 심각합니다.



예제 1: 다음 코드는 HTTP 응답에서 예외 정보를 누출합니다.


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


이 정보는 원격 사용자에게 노출될 수 있습니다. 경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

정보 유출은 모바일 컴퓨팅 환경에서도 문제가 됩니다. 모바일 플랫폼에서는 다양한 소스에서 다운로드된 응용 프로그램이 같은 장치에서 함께 실행됩니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 응용 프로그램 작성자는 장치에서 실행되는 다른 응용 프로그램으로 주소가 지정된 메시지에 포함하는 정보를 주의하여 선택해야 합니다.

예제 2: 다음 코드는 등록된 모든 Android 수신자에 대해 catch된 예외의 스택 추적을 브로드캐스트합니다.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    view.getContext().sendBroadcast(i);
}
...


모바일 환경과 관련된 시나리오가 하나 더 있습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 3: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""액세스 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다. 그러므로 프로그램 외부 리소스로 절대 정보를 보내지 마십시오.

예제 4: 다음 코드는 catch된 예외의 스택 추적을 응용 프로그램 내에서만 브로드캐스트하여, 시스템의 다른 응용 프로그램으로 누출될 수 없도록 합니다. 또한 이 기술은 시스템을 통해 글로벌로 브로드캐스트하는 것보다 효율적입니다.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction(""SEND_EXCEPTION"");
    i.putExtra(""exception"", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",26937F59EA6E478AD38AB039E604FABF,7D5632D9-3014-40BF-82DD-1EDC54B8EFFE0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/container/i18n/PluginMessages.java","PluginMessages.java",68,"            }
        } catch (IOException e) {
            logger.error(""Unable to read plugin message"", e);
        }
",Read e(),"src/main/java/org/owasp/webgoat/container/i18n/PluginMessages.java","PluginMessages.java",68,"            }
        } catch (IOException e) {
            logger.error(""Unable to read plugin message"", e);
        }
","org.apache.commons.logging.Log.error()","PluginMessages.java의 refreshProperties() 함수는 68 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",856A5E671B54CF4512325C44774D9FEB,79DB2AD7-A162-4148-BF74-46704F1DA5D4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java","MD5.java",56,"                    System.out.println(MD5.getHashString(new File(element)) + "" "" + element);
                } catch (IOException x) {
                    System.err.println(x.getMessage());
                }
            }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java","MD5.java",56,"                    System.out.println(MD5.getHashString(new File(element)) + "" "" + element);
                } catch (IOException x) {
                    System.err.println(x.getMessage());
                }
            }","java.io.PrintStream.println()","MD5.java의 main() 함수는 56 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",0EE8F8E2C995EF964E360D59637AD183,DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java","MD5.java",56,"                    System.out.println(MD5.getHashString(new File(element)) + "" "" + element);
                } catch (IOException x) {
                    System.err.println(x.getMessage());
                }
            }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson10b.java","SqlInjectionLesson10b.java",112,"            javaFileObject = new JavaObjectFromString(""TestClass.java"", javaFileContents.toString());
        } catch (Exception exception) {
            exception.printStackTrace();
        }
        return javaFileObject;",printStackTrace(),"SqlInjectionLesson10b.java의 getJavaFileContentsAsString() 함수는 112 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",3D8E3F1E6D855B390D358B7620CDD2E5,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java","MD5.java",56,"                    System.out.println(MD5.getHashString(new File(element)) + "" "" + element);
                } catch (IOException x) {
                    System.err.println(x.getMessage());
                }
            }","java.lang.Throwable.getMessage()","src/it/java/org/owasp/webgoat/LabelAndHintIntegrationTest.java","LabelAndHintIntegrationTest.java",119,"            prop.load(input);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return prop;",printStackTrace(),"LabelAndHintIntegrationTest.java의 getProperties() 함수는 119 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",27A7434215CF56F0786D8A51D756C8EA,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",64,"			log.info(""signe the signature with result: {}"", signature);
		} catch (Exception e) {
			log.error(""Signature signing failed"", e);
		}
",Read e(),"src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",64,"			log.info(""signe the signature with result: {}"", signature);
		} catch (Exception e) {
			log.error(""Signature signing failed"", e);
		}
","org.slf4j.Logger.error()","CryptoUtil.java의 signMessage() 함수는 64 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",1104C100A135F4F6414529D158F0EFB9,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",57,"                FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + "".jpg"")));
            } catch (Exception e) {
                log.error(""Unable to copy pictures"" + e.getMessage());
            }
        }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",57,"                FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + "".jpg"")));
            } catch (Exception e) {
                log.error(""Unable to copy pictures"" + e.getMessage());
            }
        }","org.slf4j.Logger.error()","ProfileUploadRetrieval.java의 initAssignment() 함수는 57 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",8815C0D46B5F2C1C36E6182EABBECAA0,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",57,"                FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + "".jpg"")));
            } catch (Exception e) {
                log.error(""Unable to copy pictures"" + e.getMessage());
            }
        }","java.lang.Throwable.getMessage()","src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java","CryptoIntegrationTest.java",35,"			checkAssignment4();
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
			fail();
		}",printStackTrace(),"CryptoIntegrationTest.java의 runTests() 함수는 35 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",E7271EB4A485D55EBF78079536C6D7C4,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",57,"                FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + "".jpg"")));
            } catch (Exception e) {
                log.error(""Unable to copy pictures"" + e.getMessage());
            }
        }","java.lang.Throwable.getMessage()","src/it/java/org/owasp/webgoat/CryptoIntegrationTest.java","CryptoIntegrationTest.java",42,"			checkAssignmentSigning();
		} catch (Exception e) {
			e.printStackTrace();
			fail();
		}",printStackTrace(),"CryptoIntegrationTest.java의 runTests() 함수는 42 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",E7271EB4A485D55EBF78079536C6D7C3,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",57,"                FileCopyUtils.copy(is, new FileOutputStream(new File(catPicturesDirectory, i + "".jpg"")));
            } catch (Exception e) {
                log.error(""Unable to copy pictures"" + e.getMessage());
            }
        }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java","SqlInjectionLesson6b.java",73,"                }
            } catch (SQLException sqle) {
                sqle.printStackTrace();
                // do nothing
            }",printStackTrace(),"SqlInjectionLesson6b.java의 getPassword() 함수는 73 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",EAEE204E6CE4B766CEE4C59FD4106F3B,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",76,"    public List<Map<String, Object>> invoke() {
        NodeList nodes = null;
        File d = new File(webGoatHomeDirectory, ""ClientSideFiltering/employees.xml"");
        XPathFactory factory = XPathFactory.newInstance();
        XPath path = factory.newXPath();","Read this.webGoatHomeDirectory()","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",107,"            log.error(""Unable to parse xml"", e);
        } catch (IOException e) {
            log.error(""Unable to read employees.xml at location: '{}'"", d);
        }
        return json;","org.slf4j.Logger.error()","Salaries.java의 invoke() 함수는 107 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",0163B3FB1A0662E57E51EF57D93348B6,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",64,"            return failed(this).build();
        } catch (SQLException e) {
            log.error(""Failed"", e);
            return (failed(this).build());
        }",Read e(),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson13.java","SqlInjectionLesson13.java",64,"            return failed(this).build();
        } catch (SQLException e) {
            log.error(""Failed"", e);
            return (failed(this).build());
        }","org.slf4j.Logger.error()","SqlInjectionLesson13.java의 completed() 함수는 64 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",FE7A26E94FA31AFB448B3007C02F4717,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java","ProfileUpload.java",22,"public class ProfileUpload extends ProfileUploadBase {

    public ProfileUpload(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUpload(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",42,"
        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();","java.io.File.mkdirs()","ProfileUploadBase.java의 execute() 함수는 42 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",DCF428DA8717332A1FEE420063566EB7,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",61,"    public void copyFiles() {
        ClassPathResource classPathResource = new ClassPathResource(""lessons/employees.xml"");
        File targetDirectory = new File(webGoatHomeDirectory, ""/ClientSideFiltering"");
        if (!targetDirectory.exists()) {
            targetDirectory.mkdir();","Read this.webGoatHomeDirectory()","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",63,"        File targetDirectory = new File(webGoatHomeDirectory, ""/ClientSideFiltering"");
        if (!targetDirectory.exists()) {
            targetDirectory.mkdir();
        }
        try {","java.io.File.mkdir()","Salaries.java의 copyFiles() 함수는 63 줄의 mkdir()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdir()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",79C0253D4538B21A6D60F7E600C64FB2,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java","ProfileUploadFix.java",22,"public class ProfileUploadFix extends ProfileUploadBase {

    public ProfileUploadFix(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUploadFix(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",42,"
        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();","java.io.File.mkdirs()","ProfileUploadBase.java의 execute() 함수는 42 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",39A4ED37A212CEF0CC688DCCD8764DD2,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",74,"    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());
        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));","Read this.fileLocation()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",75,"        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());
        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));
        log.debug(""File saved to {}"", new File(destinationDir, myFile.getOriginalFilename()));","java.io.File.mkdirs()","FileServer.java의 importFile() 함수는 75 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",D6F7DC5DA4BD3EFD9F33BAB730AB5AEE,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",59,"    private final Map<WebGoatUser, String> userToFileContents = new HashMap<>();

    public BlindSendFileAssignment(@Value(""${webgoat.user.directory}"") String webGoatHomeDirectory, CommentsCache comments) {
        this.webGoatHomeDirectory = webGoatHomeDirectory;
        this.comments = comments;",BlindSendFileAssignment(0),"src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",69,"        File targetDirectory = new File(webGoatHomeDirectory, ""/XXE/"" + user.getUsername());
        if (!targetDirectory.exists()) {
            targetDirectory.mkdirs();
        }
        try {","java.io.File.mkdirs()","BlindSendFileAssignment.java의 createSecretFileWithRandomContents() 함수는 69 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",011440C36FBFC5ECBAC42724AE4A1818,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",102,"            return objectMapper.writeValueAsString(t);
        } catch (JsonProcessingException e) {
            log.error(""Unable to create json"", e);
        }
        return ""No request(s) found"";",Read e(),"src/main/java/org/owasp/webgoat/webwolf/requests/Requests.java","Requests.java",102,"            return objectMapper.writeValueAsString(t);
        } catch (JsonProcessingException e) {
            log.error(""Unable to create json"", e);
        }
        return ""No request(s) found"";","org.slf4j.Logger.error()","Requests.java의 toJsonString() 함수는 102 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",352BB674010552821C3AAB2F7074B2D2,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",140,"            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());
        }
    }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",140,"            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());
        }
    }","java.io.PrintStream.println()","SqlInjectionLesson8.java의 log() 함수는 140 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",2EF7E4FFF2E149AB75FD9461CBDC430A,DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java","SqlInjectionLesson8.java",140,"            statement.executeUpdate(logQuery);
        } catch (SQLException e) {
            System.err.println(e.getMessage());
        }
    }","java.lang.Throwable.getMessage()",".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",92,"        } catch (Throwable e) {
            System.out.println(""- Error downloading"");
            e.printStackTrace();
            System.exit(1);
        }",printStackTrace(),"MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",BB8E8F3A3EC6AE905B20C5A51164BA7C,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",103,"                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {
            log.error(""Image not found"", e);
        }
",Read e(),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",103,"                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {
            log.error(""Image not found"", e);
        }
","org.slf4j.Logger.error()","ProfileUploadRetrieval.java의 getProfilePicture() 함수는 103 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",58FFE65B1753205D1A03ACFCFA758A6E,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",84,"
        } catch (Exception e) {
            System.err.println(e.getMessage());
            return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",84,"
        } catch (Exception e) {
            System.err.println(e.getMessage());
            return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
        }","java.io.PrintStream.println()","SqlInjectionLesson9.java의 injectableQueryIntegrity() 함수는 84 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",FB53F1A9B594BB88E6C0C9F3419C7413,DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/test/java/org/owasp/webgoat/lessons/cryptography/CryptoUtilTest.java","CryptoUtilTest.java",28,"			assertTrue(CryptoUtil.verifyAssignment(modulus, signature, keyPair.getPublic()));
		} catch (Exception e) {
			log.error(""signing failed"", e);;
			fail();
		}",Read e(),"src/test/java/org/owasp/webgoat/lessons/cryptography/CryptoUtilTest.java","CryptoUtilTest.java",28,"			assertTrue(CryptoUtil.verifyAssignment(modulus, signature, keyPair.getPublic()));
		} catch (Exception e) {
			log.error(""signing failed"", e);;
			fail();
		}","org.slf4j.Logger.error()","CryptoUtilTest.java의 testSigningAssignment() 함수는 28 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",F7BB69097973E19A8835204A03540C40,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",48,"    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();
    }
","java.io.File.mkdirs()","ProfileUploadRetrieval.java의 ProfileUploadRetrieval() 함수는 48 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",D2B09386B55F327F3A7A7E852B14AD6C,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",77,"                }
            } catch (SQLException e) {
                System.err.println(e.getMessage());
                return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
            }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java","SqlInjectionLesson9.java",77,"                }
            } catch (SQLException e) {
                System.err.println(e.getMessage());
                return failed(this).output(""<br><span class='feedback-negative'>"" + e.getMessage() + ""</span>"").build();
            }","java.io.PrintStream.println()","SqlInjectionLesson9.java의 injectableQueryIntegrity() 함수는 77 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",FB53F1A9B594BB88E6C0C9F3419C7412,DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java","ProfileUploadRemoveUserInput.java",20,"public class ProfileUploadRemoveUserInput extends ProfileUploadBase {

    public ProfileUploadRemoveUserInput(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUploadRemoveUserInput(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",42,"
        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();","java.io.File.mkdirs()","ProfileUploadBase.java의 execute() 함수는 42 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",669F7A0BA528F5EBC542BB1F72BF483C,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java","ProfileUploadRemoveUserInput.java",20,"public class ProfileUploadRemoveUserInput extends ProfileUploadBase {

    public ProfileUploadRemoveUserInput(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUploadRemoveUserInput(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java","SqlInjectionLesson6b.java",77,"            }
        } catch (Exception e) {
            e.printStackTrace();
            // do nothing
        }",printStackTrace(),"SqlInjectionLesson6b.java의 getPassword() 함수는 77 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",2BB04F6C58A5EFE4E81CCA9783CDE8EE,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java","MvcConfiguration.java",61,"    @PostConstruct
    public void createDirectory() {
        File file = new File(fileLocation);
        if (!file.exists()) {
            file.mkdirs();","Read this.fileLocation()","src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java","MvcConfiguration.java",63,"        File file = new File(fileLocation);
        if (!file.exists()) {
            file.mkdirs();
        }
    }","java.io.File.mkdirs()","MvcConfiguration.java의 createDirectory() 함수는 63 줄의 mkdirs()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. mkdirs()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",91C093A2B1504CAB5278B5BF40EBA2CE,A2B6B2CF-FCAA-4632-825F-D6C48C52246E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",100,"                return false;
            } else {
                System.err.println(e.getMessage());
                return false;
            }","java.lang.Throwable.getMessage()","src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java","SqlInjectionLesson10.java",100,"                return false;
            } else {
                System.err.println(e.getMessage());
                return false;
            }","java.io.PrintStream.println()","SqlInjectionLesson10.java의 tableExists() 함수는 100 줄의 println()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. println()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",E14215FFE9B2BE8C058CAF98F186EE6E,DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/server/StartupMessage.java","StartupMessage.java",26,"        if (event.getApplicationContext().getApplicationName().contains(""WebGoat"")) {
            port = event.getApplicationContext().getEnvironment().getProperty(""server.port"");
            address = event.getApplicationContext().getEnvironment().getProperty(""server.address"");
        }
    }","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/server/StartupMessage.java","StartupMessage.java",22,"    void onStartup(ApplicationReadyEvent event) {
        if (StringUtils.hasText(port) && !StringUtils.hasText(System.getProperty(""running.in.docker""))) {
            log.info(""Please browse to http://{}:{}/WebGoat to get started..."", address, port);
        }
        if (event.getApplicationContext().getApplicationName().contains(""WebGoat"")) {","org.slf4j.Logger.info()","StartupMessage.java의 onStartup() 함수는 22 줄의 info()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. info()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",097D24DFB258DBEB27C8689B4FD3ACF6,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",94,"			log.info(""Verified the signature with result: {}"", result);
		} catch (Exception e) {
			log.error(""Signature verification failed"", e);
		}
",Read e(),"src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",94,"			log.info(""Verified the signature with result: {}"", result);
		} catch (Exception e) {
			log.error(""Signature verification failed"", e);
		}
","org.slf4j.Logger.error()","CryptoUtil.java의 verifyMessage() 함수는 94 줄의 error()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. error()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",7F657B5AAC91B7B29A65E6A044135B85,B227CB65-6F20-4472-BBB7-13E157F32F6E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",94,"			log.info(""Verified the signature with result: {}"", result);
		} catch (Exception e) {
			log.error(""Signature verification failed"", e);
		}
",Read e(),"src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask1.java","SSRFTask1.java",68,"            }
        } catch (Exception e) {
            e.printStackTrace();
            return failed(this)
                    .output(e.getMessage())",printStackTrace(),"SSRFTask1.java의 stealTheCheese() 함수는 68 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","MavenWrapperDownloader.java의 main() 함수는 92 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 ""표준 오류"" 또는 ""표준 출력""에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 ""syslog"" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = ""NfcActivity"";
private static final String DATA_SPLITTER = ""__:DATA:__"";
private static final String MIME_TYPE = ""application/my.applications.mimetype"";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.","오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, ""접근 거부"" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.","1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.",78CE75F00CF67099296BB555F15EB100,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"02.15. 무결성 검사없는 코드 다운로드","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",19,"        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");
    }
}","org.springframework.web.servlet.ModelAndView.ModelAndView()","WebWolfRedirect.java의 19 줄에서 openWebWolf() 메서드는 확인되지 않은 입력으로 만들어진 경로를 사용하여 서버 쪽 전달을 호출합니다. 이로 인해 공격자는 응용 프로그램 바이너리를 다운로드하거나 보호할 수 있는 디렉터리 내 임의의 파일을 볼 수 있습니다.","WebWolfRedirect.java의 19 줄에서 openWebWolf() 메서드는 확인되지 않은 입력으로 만들어진 경로를 사용하여 서버 쪽 전달을 호출합니다. 이로 인해 공격자는 응용 프로그램 바이너리를 다운로드하거나 보호할 수 있는 디렉터리 내 임의의 파일을 볼 수 있습니다.","다음과 같은 경우 파일 공개가 발생합니다.
1. 신뢰할 수 없는 소스에서 데이터가 프로그램에 입력됩니다.


2. 데이터를 사용하여 경로를 동적으로 생성합니다. 



예제 1: 다음 코드는 신뢰할 수 없는 데이터를 취하고 이를 사용하여 서버 쪽 전달에 사용되는 경로를 빌드합니다.


...
	String returnURL = request.getParameter(""returnURL"");
	return new ModelAndView(returnURL);
	...


공격자가 민감한 파일 위치와 일치하는 요청 매개 변수를 URL에 제공한 경우, 해당 파일을 볼 수 있습니다. 예를 들어 ""http://www.yourcorp.com/webApp/logic?returnURL=WEB-INF/applicationContext.xml""에서 응용 프로그램의 applicationContext.xml을 볼 수 있습니다. 
공격자는 applicationContext.xml을 확보한 후 applicationContext.xml 또는 클래스나 jar 파일에서 참조된 다른 구성 파일을 찾아 다운로드할 수 있습니다. 그러면 공격자는 응용 프로그램에 대한 민감한 정보를 얻고 해당 정보를 대상으로 다른 유형의 공격을 할 수 있습니다.","신뢰할 수 없는 데이터를 사용하여 서버 쪽 리소스에 대한 요청을 지시하지 마십시오. 대신 위치 및 경로 간 간접 참조를 사용하십시오.
다음은 사용하지 마십시오.

< a href=""http://www.yourcorp.com/webApp/logic?nextPage=WEB-INF/signup.jsp"">New Customer</a>

다음을 사용하십시오.

< a href=""http://www.yourcorp.com/webApp/logic?nextPage=newCustomer"">New Customer</a>

서버 쪽 로직에는 키 ""newCustomer"" 아래 저장된 경로가 ""/WEB-INF/signup.jsp""인 서버 쪽 경로에 대해 로직 이름으로 입력된 맵이 있습니다.",,67B9FCACE29C49DF47831F8F435C365D,C4B02732-6AD9-49BF-96DF-1CD432D1EA1E0,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Security Features,"02.11. 부적절한 인증서 유효성 검증","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/resources/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",96,"                    <div class=""col-xs-5"" style=""border:0px solid gray"">
                        <h3>Samsung Galaxy S8</h3>
                        <h5 style=""color:#337ab7""><a href=""http://www.samsung.com"">Samsung</a> ·
                            <small style=""color:#337ab7"">(124421 reviews)</small>
                        </h5>","org.springframework.web.servlet.ModelAndView.ModelAndView()","ClientSideFiltering.html 파일의 96 줄은 암호화되지 않은 채널을 통해 타사 사이트로 연결됩니다.","ClientSideFiltering.html 파일의 96 줄은 암호화되지 않은 채널을 통해 타사 사이트로 연결됩니다.","웹 사이트를 탐색할 때 사용자가 손상되지 않도록 웹 페이지의 하이퍼링크가 보안 위치로만 연결되도록 하십시오. 링크가 비보안 프로토콜(예: HTTP)에서 보안 프로토콜(예: HTTPS)로 리디렉션되는 경우에도 암호화되지 않은 채널을 통한 초기 연결을 통해 공격자는 MiTM(Man-in-The-Middle) 공격을 수행할 수 있습니다. 이를 통해 공격자는 결과 방문 페이지를 제어할 수 있습니다.

예제: 다음과 같은 하이퍼링크를 고려하십시오.

<a href=""http://www.example.com/index.html""/>


공격자가 사용자와 서버 간의 네트워크 트래픽을 수신하는 경우 공격자는 www.example.com을 모방하거나 조작하여 자신의 웹 페이지를 로드할 수 있습니다.

타사 웹 사이트에 대한 링크는 처음에는 보안에 중요하지 않은 것으로 간주될 수 있지만 어떤 손상이든 사용자에게는 웹 페이지의 링크에서 오는 것처럼 보일 수 있으므로 플랫폼 사용에 대한 사용자의 신뢰를 떨어트릴 수 있습니다.","웹 사이트의 링크된 웹 페이지를 계속 제어하고 가능하면 링크가 항상 보안 프로토콜을 통해 로드되도록 하십시오. 대상 서버에 비보안 프로토콜이 필요한 경우 링크를 클릭하면 추가 위험이 있음을 사용자에게 알리는 경고를 제공하십시오. 가능하면 타사 사이트의 스크립트나 기타 아티팩트를 포함하지 마십시오.",,7D55110C065AF13AE8ACC939868730E5,C72A3E77-8324-4FF9-B958-74FCDDF39D17,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Security Features,"02.11. 부적절한 인증서 유효성 검증","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","target/classes/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",96,"                    <div class=""col-xs-5"" style=""border:0px solid gray"">
                        <h3>Samsung Galaxy S8</h3>
                        <h5 style=""color:#337ab7""><a href=""http://www.samsung.com"">Samsung</a> ·
                            <small style=""color:#337ab7"">(124421 reviews)</small>
                        </h5>","org.springframework.web.servlet.ModelAndView.ModelAndView()","ClientSideFiltering.html 파일의 96 줄은 암호화되지 않은 채널을 통해 타사 사이트로 연결됩니다.","ClientSideFiltering.html 파일의 96 줄은 암호화되지 않은 채널을 통해 타사 사이트로 연결됩니다.","웹 사이트를 탐색할 때 사용자가 손상되지 않도록 웹 페이지의 하이퍼링크가 보안 위치로만 연결되도록 하십시오. 링크가 비보안 프로토콜(예: HTTP)에서 보안 프로토콜(예: HTTPS)로 리디렉션되는 경우에도 암호화되지 않은 채널을 통한 초기 연결을 통해 공격자는 MiTM(Man-in-The-Middle) 공격을 수행할 수 있습니다. 이를 통해 공격자는 결과 방문 페이지를 제어할 수 있습니다.

예제: 다음과 같은 하이퍼링크를 고려하십시오.

<a href=""http://www.example.com/index.html""/>


공격자가 사용자와 서버 간의 네트워크 트래픽을 수신하는 경우 공격자는 www.example.com을 모방하거나 조작하여 자신의 웹 페이지를 로드할 수 있습니다.

타사 웹 사이트에 대한 링크는 처음에는 보안에 중요하지 않은 것으로 간주될 수 있지만 어떤 손상이든 사용자에게는 웹 페이지의 링크에서 오는 것처럼 보일 수 있으므로 플랫폼 사용에 대한 사용자의 신뢰를 떨어트릴 수 있습니다.","웹 사이트의 링크된 웹 페이지를 계속 제어하고 가능하면 링크가 항상 보안 프로토콜을 통해 로드되도록 하십시오. 대상 서버에 비보안 프로토콜이 필요한 경우 링크를 클릭하면 추가 위험이 있음을 사용자에게 알리는 경고를 제공하십시오. 가능하면 타사 사이트의 스크립트나 기타 아티팩트를 포함하지 마십시오.",,7D55110C065AF13AE8ACC939868730E6,C72A3E77-8324-4FF9-B958-74FCDDF39D17,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.09. 취약한 비밀번호 허용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java","WebSecurityConfig.java",100,"    @Bean
    public NoOpPasswordEncoder passwordEncoder() {
        return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
    }
}",FunctionCall: getInstance(),"암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.","암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.","암호 관리 이슈는 암호를 응용 프로그램의 속성 또는 구성 파일에 일반 텍스트로 저장할 때 발생합니다. 프로그래머는 base64 인코딩과 같은 인코딩 함수로 암호를 숨겨 암호 관리 문제를 해결하려고 하지만 이런 노력으로는 암호를 제대로 보호할 수 없습니다.

예제 1: 다음 코드는 속성 파일에서 암호를 읽고 이 암호를 사용하여 데이터베이스에 연결합니다.


...
Properties prop = new Properties();
prop.load(new FileInputStream(""config.properties""));
String password = Base64.decode(prop.getProperty(""password""));

DriverManager.getConnection(url, usr, password);
...


이 코드는 올바로 실행되지만 config.properties에 액세스할 수 있는 모든 사용자는 password의 값을 읽고 base64로 인코딩된 값임을 쉽게 알 수 있습니다. 비양심적인 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.

예제 2: 다음 코드는 Android WebView 저장소에서 사용자 이름과 암호를 읽은 다음 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
        String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
        String username = new String(Base64.decode(credentials[0], DEFAULT));
        String password = new String(Base64.decode(credentials[1], DEFAULT));
        handler.proceed(username, password);
  }
});
...


WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 루팅된 장치가 있거나 에뮬레이터를 사용하는 모든 사용자는 저장된 암호를 읽을 수 있습니다.

예제 3: 다음 코드는 MD5 해시 함수를 사용하여 암호를 인코딩하도록 Spring Security로 보호된 응용 프로그램을 구성합니다.

@Bean
public PasswordEncoder passwordEncoder() {
    return new MD5PasswordEncoder();
}
","암호를 일반 텍스트로 저장하지 마십시오. 암호는 시스템이 시작될 때 관리자가 입력해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 보다 안전하게 암호를 관리할 수 있다고 주장하지만 이러한 기능에 대해서는 회의적입니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리합니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다.
 
Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 투명한 256비트 AES 데이터베이스 파일 암호화를 제공합니다. 이 방법으로 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 4: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


이 예제는 android.database.sqlite.SQLiteDatabase에 대한 참조를 net.sqlcipher.database.SQLiteDatabase로 대신합니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.

Spring Security의 경우 다이제스트 기반 암호 인코딩은 안전한 것으로 간주되지 않습니다. 또한 BCryptPasswordEncoder, Pbkdf2PasswordEncoder 또는 SCryptPasswordEncoder 같은 적응형 단방향 함수를 사용합니다. 암호 업그레이드를 지원하는 DelegatingPasswordEncoder를 사용하는 것이 좋습니다. 이 지원은 제거되지 않을 예정입니다. 이는 기존에 구현된 것이며 사용하는 것이 안전하지 않은 것으로 간주되어 사용되지 않습니다.

예제 5: 다음 코드는 위임 암호 인코더를 사용하도록 Spring Security로 보호된 응용 프로그램을 구성합니다.

@Bean
public PasswordEncoder passwordEncoder() {
    PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
    return encoder; 
}
","1. Fortify Secure Coding Rulepacks는 암호를 인수로 사용하는 것으로 알려진 함수를 찾아 암호 관리 이슈를 식별합니다. 암호가 프로그램 외부에서 제공되며 식별된 난독 처리 해제 루틴을 통과하지 않고 사용되는 경우 Fortify Static Code Analyzer는 암호 관리 이슈 플래그를 지정합니다.

암호 관리 이슈를 감사하려면 암호가 시스템에 입력되는 지점부터 시작하여 암호가 사용되는 지점까지 프로그램을 추적합니다. 난독 처리 해제를 수행하는 코드를 찾습니다. 난독 처리 해제 코드가 없으면 이 이슈는 해결되지 않은 것입니다. 암호가 난독 처리 해제 함수를 통과하는 경우 암호를 보호하는 데 사용하는 알고리즘이 견고한지 확인합니다.

암호가 제대로 보호된다고 확신하면 암호가 난독 처리로 보호되고 있음을 나타내는 난독 처리 해제 루틴에 대한 사용자 지정 통과 규칙(pass-through rule)을 작성하십시오. 이 규칙을 향후 응용 프로그램 분석에 포함시키면 식별된 난독 처리 해제 루틴을 통과한 암호는 더 이상 암호 관리 취약점을 일으키지 않습니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Struts 2 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",CDDFEA05C738C7AA437DA351BB141003,211A940B-7324-4F90-BFF3-CF7ECEDE29CF,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.09. 취약한 비밀번호 허용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java","WebSecurityConfig.java",89,"    @Bean
    public NoOpPasswordEncoder passwordEncoder() {
        return (NoOpPasswordEncoder) NoOpPasswordEncoder.getInstance();
    }
}",FunctionCall: getInstance(),"암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.","암호를 감추기 위해 getInstance()을(를) 호출하면 의미 있는 보호가 제공되지 않습니다.","암호 관리 이슈는 암호를 응용 프로그램의 속성 또는 구성 파일에 일반 텍스트로 저장할 때 발생합니다. 프로그래머는 base64 인코딩과 같은 인코딩 함수로 암호를 숨겨 암호 관리 문제를 해결하려고 하지만 이런 노력으로는 암호를 제대로 보호할 수 없습니다.

예제 1: 다음 코드는 속성 파일에서 암호를 읽고 이 암호를 사용하여 데이터베이스에 연결합니다.


...
Properties prop = new Properties();
prop.load(new FileInputStream(""config.properties""));
String password = Base64.decode(prop.getProperty(""password""));

DriverManager.getConnection(url, usr, password);
...


이 코드는 올바로 실행되지만 config.properties에 액세스할 수 있는 모든 사용자는 password의 값을 읽고 base64로 인코딩된 값임을 쉽게 알 수 있습니다. 비양심적인 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.

예제 2: 다음 코드는 Android WebView 저장소에서 사용자 이름과 암호를 읽은 다음 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
        String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
        String username = new String(Base64.decode(credentials[0], DEFAULT));
        String password = new String(Base64.decode(credentials[1], DEFAULT));
        handler.proceed(username, password);
  }
});
...


WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 루팅된 장치가 있거나 에뮬레이터를 사용하는 모든 사용자는 저장된 암호를 읽을 수 있습니다.

예제 3: 다음 코드는 MD5 해시 함수를 사용하여 암호를 인코딩하도록 Spring Security로 보호된 응용 프로그램을 구성합니다.

@Bean
public PasswordEncoder passwordEncoder() {
    return new MD5PasswordEncoder();
}
","암호를 일반 텍스트로 저장하지 마십시오. 암호는 시스템이 시작될 때 관리자가 입력해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 보다 안전하게 암호를 관리할 수 있다고 주장하지만 이러한 기능에 대해서는 회의적입니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리합니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다.
 
Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 투명한 256비트 AES 데이터베이스 파일 암호화를 제공합니다. 이 방법으로 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 4: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


이 예제는 android.database.sqlite.SQLiteDatabase에 대한 참조를 net.sqlcipher.database.SQLiteDatabase로 대신합니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.

Spring Security의 경우 다이제스트 기반 암호 인코딩은 안전한 것으로 간주되지 않습니다. 또한 BCryptPasswordEncoder, Pbkdf2PasswordEncoder 또는 SCryptPasswordEncoder 같은 적응형 단방향 함수를 사용합니다. 암호 업그레이드를 지원하는 DelegatingPasswordEncoder를 사용하는 것이 좋습니다. 이 지원은 제거되지 않을 예정입니다. 이는 기존에 구현된 것이며 사용하는 것이 안전하지 않은 것으로 간주되어 사용되지 않습니다.

예제 5: 다음 코드는 위임 암호 인코더를 사용하도록 Spring Security로 보호된 응용 프로그램을 구성합니다.

@Bean
public PasswordEncoder passwordEncoder() {
    PasswordEncoder encoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();
    return encoder; 
}
","1. Fortify Secure Coding Rulepacks는 암호를 인수로 사용하는 것으로 알려진 함수를 찾아 암호 관리 이슈를 식별합니다. 암호가 프로그램 외부에서 제공되며 식별된 난독 처리 해제 루틴을 통과하지 않고 사용되는 경우 Fortify Static Code Analyzer는 암호 관리 이슈 플래그를 지정합니다.

암호 관리 이슈를 감사하려면 암호가 시스템에 입력되는 지점부터 시작하여 암호가 사용되는 지점까지 프로그램을 추적합니다. 난독 처리 해제를 수행하는 코드를 찾습니다. 난독 처리 해제 코드가 없으면 이 이슈는 해결되지 않은 것입니다. 암호가 난독 처리 해제 함수를 통과하는 경우 암호를 보호하는 데 사용하는 알고리즘이 견고한지 확인합니다.

암호가 제대로 보호된다고 확신하면 암호가 난독 처리로 보호되고 있음을 나타내는 난독 처리 해제 루틴에 대한 사용자 지정 통과 규칙(pass-through rule)을 작성하십시오. 이 규칙을 향후 응용 프로그램 분석에 포함시키면 식별된 난독 처리 해제 루틴을 통과한 암호는 더 이상 암호 관리 취약점을 일으키지 않습니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Struts 2 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",00ED5A01251FA97DED1DF10FF91B63E0,211A940B-7324-4F90-BFF3-CF7ECEDE29CF,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java","CSRFGetFlag.java",63,"            if (""true"".equals(req.getParameter(""csrf""))) {
                Random random = new Random();
                userSessionData.setValue(""csrf-get-success"", random.nextInt(65536));
                response.put(""success"", true);
                response.put(""message"", pluginMessages.getMessage(""csrf-get-null-referer.success""));",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,5F347BBC18574D08CA53545E56B2F74C,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/resources/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",59,"					    // a namespace has been assigned for it, but you can roll your own if you prefer
					    webgoat.customjs.assignRandomVal = function () {
							var x = Math.floor((Math.random() * 100) + 1);
							document.getElementById(""magic_num"").value = x;
						};",FunctionPointerCall: random(),"random()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,DF5DCE38C267401489234D76FF11C207,919BF191-6443-4239-BBFF-A7A31C108032,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",65,"
    private void createSecretFileWithRandomContents(WebGoatUser user) {
        var fileContents = ""WebGoat 8.0 rocks... ("" + randomAlphabetic(10) + "")"";
        userToFileContents.put(user, fileContents);
        File targetDirectory = new File(webGoatHomeDirectory, ""/XXE/"" + user.getUsername());",randomAlphabetic(),"randomAlphabetic()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,385F2C255E18EF3905BE8BBDE62055EA,DBB5D0ED-E29D-4E81-8F21-43672B2C677E,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",53,"                // a namespace has been assigned for it, but you can roll your own if you prefer
                document.getElementById(""btn"").addEventListener(""click"", function() {
                    document.getElementById(""networkNum"").value = Math.random() * 100;
                    document.getElementById(""networkNumCopy"").value = document.getElementById(""networkNum"").value;
                });",FunctionPointerCall: random(),"random()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,C9718E95F889CDF7061713F2628CAA36,919BF191-6443-4239-BBFF-A7A31C108032,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",25,"        char[] a = inputString.toCharArray();
        for (int i = 0; i < a.length; i++) {
            int j = random.nextInt(a.length);
            char temp = a[i];
            a[i] = a[j];",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,44C455FC640488F1E4FFD59BD512FC14,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",90,"                .compact();
        Map<String, Object> tokenJson = new HashMap<>();
        String refreshToken = RandomStringUtils.randomAlphabetic(20);
        validRefreshTokens.add(refreshToken);
        tokenJson.put(""access_token"", token);",randomAlphabetic(),"randomAlphabetic()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,CDFD178287A8DC40970C84EE19CD89BF,DBB5D0ED-E29D-4E81-8F21-43672B2C677E,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",86,"        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");

            if (catPicture.getName().toLowerCase().contains(""path-traversal-secret.jpg"")) {",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,32E05C25A96FE0E2A029A254356816C5,07991774-F86A-4A10-B7D9-666AF337F943,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java","CSRFGetFlag.java",80,"        } else {
            Random random = new Random();
            userSessionData.setValue(""csrf-get-success"", random.nextInt(65536));
            response.put(""success"", true);
            response.put(""message"", pluginMessages.getMessage(""csrf-get-other-referer.success""));",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,5F347BBC18574D08CA53545E56B2F74A,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","target/classes/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",59,"					    // a namespace has been assigned for it, but you can roll your own if you prefer
					    webgoat.customjs.assignRandomVal = function () {
							var x = Math.floor((Math.random() * 100) + 1);
							document.getElementById(""magic_num"").value = x;
						};",FunctionPointerCall: random(),"random()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,DF5DCE38C267401489234D76FF11C208,919BF191-6443-4239-BBFF-A7A31C108032,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java","HashingAssignment.java",54,"		if (md5Hash == null) {
			
			String secret = SECRETS[new Random().nextInt(SECRETS.length)];
	         
		    MessageDigest md = MessageDigest.getInstance(""MD5"");",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,95B2FA35EA1802C3633C30D4317ABDE3,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/jwt/JWTSecretKeyEndpoint.java","JWTSecretKeyEndpoint.java",55,"
    public static final String[] SECRETS = {""victory"", ""business"", ""available"", ""shipping"", ""washington""};
    public static final String JWT_SECRET = TextCodec.BASE64.encode(SECRETS[new Random().nextInt(SECRETS.length)]);
    private static final String WEBGOAT_USER = ""WebGoat"";
    private static final List<String> expectedClaims = List.of(""iss"", ""iat"", ""exp"", ""aud"", ""sub"", ""username"", ""Email"", ""Role"");",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,2D54C8FA8F2F247459CA5178C92847E3,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/spoofcookie/encoders/EncDec.java","EncDec.java",41,"    // PoC: weak encoding method

    private static final String SALT = RandomStringUtils.randomAlphabetic(10);

    private EncDec() {",randomAlphabetic(),"randomAlphabetic()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,E52EC2750EEF5848BA05B7F4DBB62A4A,DBB5D0ED-E29D-4E81-8F21-43672B2C677E,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/csrf/CSRFGetFlag.java","CSRFGetFlag.java",69,"            } else {
                Random random = new Random();
                userSessionData.setValue(""csrf-get-success"", random.nextInt(65536));
                response.put(""success"", true);
                response.put(""message"", pluginMessages.getMessage(""csrf-get-other-referer.success""));",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,5F347BBC18574D08CA53545E56B2F74B,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","target/classes/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",53,"                // a namespace has been assigned for it, but you can roll your own if you prefer
                document.getElementById(""btn"").addEventListener(""click"", function() {
                    document.getElementById(""networkNum"").value = Math.random() * 100;
                    document.getElementById(""networkNumCopy"").value = document.getElementById(""networkNum"").value;
                });",FunctionPointerCall: random(),"random()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,C9718E95F889CDF7061713F2628CAA37,919BF191-6443-4239-BBFF-A7A31C108032,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/hijacksession/cas/HijackSessionAuthenticationProvider.java","HijackSessionAuthenticationProvider.java",51,"
    private Queue<String> sessions = new LinkedList<>();
    private static long id = new Random().nextLong() & Long.MAX_VALUE;
    protected static final int MAX_SESSIONS = 50;
",nextLong(),"nextLong()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,6A20FBE577F9345766EBA3EE6E90730B,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/container/WebWolfRedirect.java","WebWolfRedirect.java",17,"    @GetMapping(""/WebWolf"")
    public ModelAndView openWebWolf() {
        var url = applicationContext.getEnvironment().getProperty(""webwolf.url"");

        return new ModelAndView(""redirect:"" + url + ""/home"");","org.springframework.core.env.PropertyResolver.getProperty()","src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java","HashingAssignment.java",73,"		String sha256 = (String) request.getSession().getAttribute(""sha256"");
		if (sha256 == null) {
			String secret = SECRETS[new Random().nextInt(SECRETS.length)];
		    sha256 = getHash(secret, ""SHA-256"");
			request.getSession().setAttribute(""sha256Hash"", sha256);",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,0435906D7B4AE6B8ED9674812EC22E07,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",17,"        if (username.equalsIgnoreCase(""admin"")) {
            //Admin has a fix reset link
            random.setSeed(key.length());
        }
        return scramble(random, scramble(random, scramble(random, MD5.getHashString(username))));","java.util.Random.setSeed()","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,7C8B7E9A566E6F06A55432B2DE7DAE40,3CB1D23E-CE0D-47E5-B387-F1026CDA0D64,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/cryptography/EncodingAssignment.java","EncodingAssignment.java",52,"		String username = request.getUserPrincipal().getName();
		if (basicAuth == null) {
			String password = HashingAssignment.SECRETS[new Random().nextInt(HashingAssignment.SECRETS.length)];
			basicAuth = getBasicAuth(username, password);
			request.getSession().setAttribute(""basicAuth"", basicAuth);",nextInt(),"nextInt()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,80243207D6F1DE1DC47E04A8B201F48F,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.08. 적절하지 않은 난수 값 사용","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/hijacksession/cas/HijackSessionAuthenticationProvider.java","HijackSessionAuthenticationProvider.java",82,"
    protected void authorizedUserAutoLogin() {
        if (!PROBABILITY_DOUBLE_PREDICATE.test(ThreadLocalRandom.current().nextDouble())) {
            Authentication authentication = AUTHENTICATION_SUPPLIER.get();
            authentication.setAuthenticated(true);",nextDouble(),"nextDouble()에서 구현되는 난수 발생기는 암호화 공격을 차단하지 못합니다.","PasswordResetLink.java의 createPasswordReset() 함수에 시드에 대해 감염된 값이 전달됩니다. 시드가 전달되어 난수 또는 의사 난수 값을 생성하는 함수는 감염된 정수 인수로 호출해서는 안 됩니다.","Random.setSeed()는 감염된 정수 인수로 호출해서는 안 됩니다. 그렇게 하면 공격자가 의사 난수 발생기(PRNG)의 시드 생성에 사용되는 값을 제어할 수 있게 되므로 Random.nextInt(), Random.nextShort(), Random.nextLong()을 호출하여 생성되거나, Random.nextBoolean()에서 반환되거나, Random.nextBytes(byte[])에 설정되는 값(대개 정수)의 시퀀스를 예측할 수 있게 됩니다.
    ","링 발진기, 디스크 드라이브 타이밍, 열 잡음 또는 방사성 붕괴 같은 하드웨어 기반의 무작위성 소스를 사용하여 시드가 생성되는 암호화 PRNG(예: java.security.SecureRandom)를 사용하십시오.
	",,311E53334A43BDF9889C9C7A134E82E1,49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/documentation/JWT_libraries.adoc","JWT_libraries.adoc",40,"[source]
----
var token = "" eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.NFvYpuwbF6YWbPyaNAGEPw9wbhiQSovvSrD89B8K7Ng"";

Jwts.parser().setSigningKey(""test"").parseClaimsJws(token);",nextDouble(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",A15DCB09A6ADDF26090750B75ECED05F,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/goatkeystore.pkcs12","goatkeystore.pkcs12",0,0?	?^B^A^C0?	?^F	*?H??
^A^G^A??	?^D?	?0?	?0?^Ee^F	*?H??,nextDouble(),"하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",6EF3353E3CBC60508B1CE859B177817C,8FAE07A6-DBDB-443E-8601-521D3A748B5A,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",258,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordZipSlip"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",nextDouble(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF1B,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/webwolf/jwt/JWTTokenTest.java","JWTTokenTest.java",40,"    @Test
    void decodeValidSignedToken() {
        var token = JWTToken.decode(""eyJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoidGVzdCJ9.KOobRHDYyaesV_doOk11XXGKSONwzllraAaqqM4VFE4"", ""test"");

        assertThat(token.getHeader()).contains(""\""alg\"" : \""HS256\"""");",nextDouble(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",31E312C9478260C86C167EBCB0E8F445,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/goatkeystore.pkcs12","goatkeystore.pkcs12",0,0?	?^B^A^C0?	?^F	*?H??
^A^G^A??	?^D?	?0?	?0?^Ee^F	*?H??,nextDouble(),"하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",EAA1A796CE6A3057A4B82C788F08D4D2,8FAE07A6-DBDB-443E-8601-521D3A748B5A,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/it/java/org/owasp/webgoat/GeneralLessonIntegrationTest.java","GeneralLessonIntegrationTest.java",92,"        params.clear();
        params.put(""username"", ""CaptainJack"");
        params.put(""password"", ""BlackPearl"");
        checkAssignment(url(""/WebGoat/InsecureLogin/task""), params, true);
        checkResults(""/InsecureLogin/"");",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5254D15994D4835076B12E4A2AEBEDBD,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/js/jwt-refresh.js","jwt-refresh.js",10,"        url: 'JWT/refresh/login',
        contentType: ""application/json"",
        data: JSON.stringify({user: user, password: ""bm5nhSkxCXZkKRy4""})
    }).success(
        function (response) {",FieldAccess: password(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F1A9FBA783AE5967CECAC76C20C2EEEA,A79E289A-14D7-4dfd-8E34-F249133A69FE,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",123,"
	public static PrivateKey getPrivateKeyFromPEM(String privateKeyPem) throws NoSuchAlgorithmException, InvalidKeySpecException {
		privateKeyPem = privateKeyPem.replace(""-----BEGIN PRIVATE KEY-----"", """");
		privateKeyPem = privateKeyPem.replace(""-----END PRIVATE KEY-----"", """");
		privateKeyPem = privateKeyPem.replace(""\n"", """").replace(""\r"", """");",FieldAccess: password(),"하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",407753DC68B93B468246E263006C8DEF,6DBD0F5A-99EB-53B7-AB1E-D9B012E68020,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",160,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordRemoveUserInput"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FieldAccess: password(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF1E,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/documentation/JWT_decode.adoc","JWT_decode.adoc",8,"[source]
----
eyJhbGciOiJIUzI1NiJ9.ew0KICAiYXV0aG9yaXRpZXMiIDogWyAiUk9MRV9BRE1JTiIsICJST0xFX1VTRVIiIF0sDQogICJjbGllbnRfaWQiIDogIm15LWNsaWVudC13aXRoLXNlY3JldCIsDQogICJleHAiIDogMTYwNzA5OTYwOCwNCiAgImp0aSIgOiAiOWJjOTJhNDQtMGIxYS00YzVlLWJlNzAtZGE1MjA3NWI5YTg0IiwNCiAgInNjb3BlIiA6IFsgInJlYWQiLCAid3JpdGUiIF0sDQogICJ1c2VyX25hbWUiIDogInVzZXIiDQp9.9lYaULTuoIDJ86-zKDSntJQyHPpJ2mZAbnWRfel99iI
----
",FieldAccess: password(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",D8805DC8728FBF88FC6EF25AC0087F1F,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/documentation/JWT_signing_solution.adoc","JWT_signing_solution.adoc",35,"GET http://localhost:8080/WebGoat/JWT/votings/login?user=Tom HTTP/1.1

access_token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE2MDgxMjg1NjYsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.rTSX6PSXqUoGUvQQDBiqX0re2BSt7s2-X6FPf34Qly9SMpqIUSP8jykedJbjOBNlM3_CTjgk1SvUv48Pz8zIzA
----
",FieldAccess: password(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",A54414CB7BFC6262FB5D4A11EB048541,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/i18n/WebGoatLabels.properties","WebGoatLabels.properties",22,"jwt-refresh-hint2=The token from the access log is no longer valid, can you find a way to refresh it?
jwt-refresh-hint3=The endpoint for refreshing a token is 'JWT/refresh/newToken'
jwt-refresh-hint4=Use the found access token in the Authorization: Bearer header and use your own refresh token
jwt-refresh-not-tom=User is not Tom but {0}, please try again
",FieldAccess: password(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5CE8E08BC1A6626BE60DAC5369C6A8C1,6D984A17-AB12-483D-99B8-93B7F7D4A242,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/documentation/JWT_libraries.adoc","JWT_libraries.adoc",28,"[source]
----
var token = ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.NFvYpuwbF6YWbPyaNAGEPw9wbhiQSovvSrD89B8K7Ng"";

Jwts.parser().setSigningKey(""test"").parseClaimsJws(token);",FieldAccess: password(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",E555A8C5237128642B40D9817142E334,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6b.java","SqlInjectionLesson6b.java",61,"
    protected String getPassword() {
        String password = ""dave"";
        try (Connection connection = dataSource.getConnection()) {
            String query = ""SELECT password FROM user_system_data WHERE user_name = 'dave'"";",VariableAccess: password,"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",14EEAFE363CCE0DDAAC2849F8E17A5C3,9C5BD1B5-C296-48d4-B5F5-5D2958661BC4,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/it/java/org/owasp/webgoat/GeneralLessonIntegrationTest.java","GeneralLessonIntegrationTest.java",102,"        Map<String, Object> params = new HashMap<>();
        params.clear();
        params.put(""password"", ""ajnaeliclm^&&@kjn."");
        checkAssignment(url(""/WebGoat/SecurePasswords/assignment""), params, true);
        checkResults(""SecurePasswords/"");",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F87DC75D61E21719332C16F6E7A88D5C,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",103,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordFix"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FunctionCall: put(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF1D,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/js/jwt-refresh.js","jwt-refresh.js",10,"        url: 'JWT/refresh/login',
        contentType: ""application/json"",
        data: JSON.stringify({user: user, password: ""bm5nhSkxCXZkKRy4""})
    }).success(
        function (response) {",FieldAccess: password(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F1A9FBA783AE5967CECAC76C20C2EEE9,A79E289A-14D7-4dfd-8E34-F249133A69FE,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java","JWTRefreshEndpointTest.java",103,"    @Test
    public void checkoutWitRandomTokenShouldFail() throws Exception {
        String accessTokenTom = ""eyJhbGciOiJIUzUxMiJ9.eyJpLXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q"";
        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/refresh/checkout"")
                .header(""Authorization"", ""Bearer "" + accessTokenTom))",FieldAccess: password(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",DC9DBE68DAFC4A0E7069026FC3E3181B,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",74,"        String password = (String) json.get(""password"");

        if (""Jerry"".equalsIgnoreCase(user) && PASSWORD.equals(password)) {
            return ok(createNewTokens(user));
        }",FunctionCall: equals(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",CC5962654F1B386AA820183318367164,F9D3C462-8D1E-4457-967F-9F082B973F88,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",103,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordFix"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FunctionCall: equals(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF19,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/webwolf/jwt/JWTTokenTest.java","JWTTokenTest.java",28,"        var token = JWTToken.encode(toString(headers), toString(payload), ""webgoat"");

        assertThat(token.getEncoded()).isEqualTo(""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoidGVzdCJ9.axNp9BkswwK_YRF2URJ5P1UejQNYZbK4qYcMnkusg6I"");
    }
",FunctionCall: equals(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",1BF7A100940C3C5B1DF91C19AA321A8C,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",49,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""password"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FunctionCall: equals(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF1C,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java","JWTRefreshEndpointTest.java",179,"        Map<String, Object> loginJson = new HashMap<>();
        loginJson.put(""user"", ""Jerry"");
        loginJson.put(""password"", PASSWORD);
        MvcResult result = mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/refresh/login"")
                .contentType(MediaType.APPLICATION_JSON)",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",DB173B36FC71C816273188257647AB10,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/documentation/JWT_decode.adoc","JWT_decode.adoc",8,"[source]
----
eyJhbGciOiJIUzI1NiJ9.ew0KICAiYXV0aG9yaXRpZXMiIDogWyAiUk9MRV9BRE1JTiIsICJST0xFX1VTRVIiIF0sDQogICJjbGllbnRfaWQiIDogIm15LWNsaWVudC13aXRoLXNlY3JldCIsDQogICJleHAiIDogMTYwNzA5OTYwOCwNCiAgImp0aSIgOiAiOWJjOTJhNDQtMGIxYS00YzVlLWJlNzAtZGE1MjA3NWI5YTg0IiwNCiAgInNjb3BlIiA6IFsgInJlYWQiLCAid3JpdGUiIF0sDQogICJ1c2VyX25hbWUiIDogInVzZXIiDQp9.9lYaULTuoIDJ86-zKDSntJQyHPpJ2mZAbnWRfel99iI
----
",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",0FBC8F7FC0EFA25299557335EAE3C1FD,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java","JWTRefreshEndpointTest.java",73,"
        //Now create a new refresh token for Tom based on Toms old access token and send the refresh token of Jerry
        String accessTokenTom = ""eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q"";
        Map<String, Object> refreshJson = new HashMap<>();
        refreshJson.put(""refresh_token"", refreshToken);",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5374953BF72624353425BACC6C6F8762,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java","JWTRefreshEndpoint.java",61,"public class JWTRefreshEndpoint extends AssignmentEndpoint {

    public static final String PASSWORD = ""bm5nhSkxCXZkKRy4"";
    private static final String JWT_PASSWORD = ""bm5n3SkxCX4kKRy4"";
    private static final List<String> validRefreshTokens = new ArrayList<>();",FieldAccess: PASSWORD(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",36B1107F97CE968D3229BA608938C9FD,C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/idor/IDORLogin.java","IDORLogin.java",46,"
        idorUserInfo.put(""tom"", new HashMap<String, String>());
        idorUserInfo.get(""tom"").put(""password"", ""cat"");
        idorUserInfo.get(""tom"").put(""id"", ""2342384"");
        idorUserInfo.get(""tom"").put(""color"", ""yellow"");",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",974335619A467F7F9B56DA3845D1ABED,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/idor/IDORLogin.java","IDORLogin.java",52,"
        idorUserInfo.put(""bill"", new HashMap<String, String>());
        idorUserInfo.get(""bill"").put(""password"", ""buffalo"");
        idorUserInfo.get(""bill"").put(""id"", ""2342388"");
        idorUserInfo.get(""bill"").put(""color"", ""brown"");",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",118412442D22D5B6238C7EED91DDC3AC,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/cryptography/CryptoUtil.java","CryptoUtil.java",42,"
    public static String getPrivateKeyInPEM(KeyPair keyPair) {
        String encodedString = ""-----BEGIN PRIVATE KEY-----\n"";
        encodedString = encodedString+new String(Base64.getEncoder().encode(keyPair.getPrivate().getEncoded()),Charset.forName(""UTF-8""))+""\n"";
        encodedString = encodedString+""-----END PRIVATE KEY-----\n"";",FunctionCall: put(),"하드코드 암호화 키는 쉽게 해결할 수 없는 방식으로 보안을 침해할 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F21A6FFA0FD07F04E14FB4050C673CF2,6DBD0F5A-99EB-53B7-AB1E-D9B012E68020,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",310,"        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/JWT/final/delete?token=eyJ0eXAiOiJKV1QiLCJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.CgZ27DzgVW8gzc0n6izOU638uUCi6UhiOJKYzoEZGE8"">
            <div class=""container-fluid"">
                <div id=""toast""></div>",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F4E67761F73C153572E806FA4760640F,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/webwolf/jwt/JWTTokenTest.java","JWTTokenTest.java",48,"    @Test
    void decodeInvalidSignedToken() {
        var token = JWTToken.decode(""eyJhbGciOiJIUzI1NiJ9.eyJ0ZXsdfdfsaasfddfasN0IjoidGVzdCJ9.KOobRHDYyaesV_doOk11XXGKSONwzllraAaqqM4VFE4"", """");

        assertThat(token.getHeader()).contains(""\""alg\"" : \""HS256\"""");",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",3FE983ABBFF7D9EB84E42186D3247067,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/challenges/SolutionConstants.java","SolutionConstants.java",34,"
    //TODO should be random generated when starting the server
    String PASSWORD = ""!!webgoat_admin_1234!!"";
    String PASSWORD_TOM = ""thisisasecretfortomonly"";
    String ADMIN_PASSWORD_LINK = ""375afe1104f4a487a73823c50a9292a2"";",FieldAccess: PASSWORD(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5A389FAFC99B8C39EF568BE638A67F07,C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java","JWTRefreshEndpointTest.java",94,"    @Test
    public void checkoutWithTomsTokenFromAccessLogShouldFail() throws Exception {
        String accessTokenTom = ""eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q"";
        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/refresh/checkout"")
                .header(""Authorization"", ""Bearer "" + accessTokenTom))",FieldAccess: PASSWORD(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F5FDC2F3375EAD672BEEF2FC1685A76F,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",160,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordRemoveUserInput"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FieldAccess: PASSWORD(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF1A,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/xxe/User.java","User.java",31,"
    private String username = """";
    private String password = """";

    public String getPassword() {",FieldAccess: password(),"빈 암호는 쉽게 해결할 수 없는 방식으로 시스템 보안을 침해할 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",74F1E8AD635A457A4F9E96B9052D094D,8bd01c50-a769-11de-8a39-0800200c9a66,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpointTest.java","JWTRefreshEndpointTest.java",156,"        Map<String, Object> loginJson = new HashMap<>();
        loginJson.put(""user"", ""Jerry"");
        loginJson.put(""password"", PASSWORD);
        MvcResult result = mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/refresh/login"")
                .contentType(MediaType.APPLICATION_JSON)",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",B76CA9E50E96A413857F23719AC6BC89,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/webwolf/user/UserServiceTest.java","UserServiceTest.java",73,"    public void testAddUser(){
        var username = ""guest"";
        var password = ""guest"";

        sut.addUser(username, password);",VariableAccess: password,"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",1517895363BE40D488BD049374EE96F4,9C5BD1B5-C296-48d4-B5F5-5D2958661BC4,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/webwolf/user/UserServiceTest.java","UserServiceTest.java",51,"    public void testLoadUserByUsername(){
        var username = ""guest"";
        var password = ""123"";
        WebGoatUser user = new WebGoatUser(username, password);
        when(mockUserRepository.findByUsername(username)).thenReturn(user);",VariableAccess: password,"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",BE0E0E7FD09E16F40FCAAC1B2BF7069F,9C5BD1B5-C296-48d4-B5F5-5D2958661BC4,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",310,"        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/JWT/final/delete?token=eyJ0eXAiOiJKV1QiLCJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.CgZ27DzgVW8gzc0n6izOU638uUCi6UhiOJKYzoEZGE8"">
            <div class=""container-fluid"">
                <div id=""toast""></div>",VariableAccess: password,"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",503B1FC7F063C38C33A48DD2D61E5F10,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",258,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""passwordZipSlip"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",VariableAccess: password,"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF1F,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/it/java/org/owasp/webgoat/IDORIntegrationTest.java","IDORIntegrationTest.java",48,"        params.clear();
        params.put(""username"", ""tom"");
        params.put(""password"", ""cat"");
       
    	",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",817AD0623F9246EDCB0ED24C2F124E92,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/insecurelogin/InsecureLoginTask.java","InsecureLoginTask.java",36,"    @ResponseBody
    public AttackResult completed(@RequestParam String username, @RequestParam String password) {
    	if (""CaptainJack"".equals(username) && ""BlackPearl"".equals(password)) {
    		return success(this).build();
    	}",FunctionCall: equals(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",864BA2FB17C54635573C8B5AC8D73F43,F9D3C462-8D1E-4457-967F-9F082B973F88,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/images/logs.txt","logs.txt",2,"
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] ""GET /JWT/refresh/checkout?token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q HTTP/1.1"" 401 242 ""-"" ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"" ""-""
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] ""POST /JWT/refresh/moveToCheckout HTTP/1.1"" 200 12783 ""-"" ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"" ""-""
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] ""POST /JWT/refresh/login HTTP/1.1"" 200 212 ""-"" ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"" ""-""",FunctionCall: equals(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",D987F06A2F126EDDABA124B55652B067,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/lessons/jwt/images/logs.txt","logs.txt",2,"
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] ""GET /JWT/refresh/checkout?token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q HTTP/1.1"" 401 242 ""-"" ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"" ""-""
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] ""POST /JWT/refresh/moveToCheckout HTTP/1.1"" 200 12783 ""-"" ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"" ""-""
194.201.170.15 - - [28/Jan/2016:21:28:01 +0100] ""POST /JWT/refresh/login HTTP/1.1"" 200 212 ""-"" ""Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0"" ""-""",FunctionCall: equals(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",D5211AF084B611BEF813B18E93F61722,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/documentation/JWT_signing_solution.adoc","JWT_signing_solution.adoc",35,"GET http://localhost:8080/WebGoat/JWT/votings/login?user=Tom HTTP/1.1

access_token=eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE2MDgxMjg1NjYsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.rTSX6PSXqUoGUvQQDBiqX0re2BSt7s2-X6FPf34Qly9SMpqIUSP8jykedJbjOBNlM3_CTjgk1SvUv48Pz8zIzA
----
",FunctionCall: equals(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",F14BEF692C09530DD32C660DE0D50E5E,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/documentation/JWT_libraries.adoc","JWT_libraries.adoc",28,"[source]
----
var token = ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.NFvYpuwbF6YWbPyaNAGEPw9wbhiQSovvSrD89B8K7Ng"";

Jwts.parser().setSigningKey(""test"").parseClaimsJws(token);",FunctionCall: equals(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",544C1F6CD26FA75A595A35B56526D388,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/it/java/org/owasp/webgoat/CSRFIntegrationTest.java","CSRFIntegrationTest.java",187,"        params.clear();
        params.put(""username"", ""csrf-"" + this.getUser());
        params.put(""password"", ""password"");

        //login and get the new cookie",FunctionCall: put(),"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",29FF9EC250A65E78FFAF022F815A1479,60A3A244-EAE2-415D-A054-EDFF20D3E7AA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/i18n/WebGoatLabels.properties","WebGoatLabels.properties",22,"jwt-refresh-hint2=The token from the access log is no longer valid, can you find a way to refresh it?
jwt-refresh-hint3=The endpoint for refreshing a token is 'JWT/refresh/newToken'
jwt-refresh-hint4=Use the found access token in the Authorization: Bearer header and use your own refresh token
jwt-refresh-not-tom=User is not Tom but {0}, please try again
",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",C4F210B24CE2B7093C786041FA5A31B4,6D984A17-AB12-483D-99B8-93B7F7D4A242,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",49,"                <div class=""form-group"">
                    <label>Password:</label>
                    <input class=""form-control"" type=""password"" id=""password"" name=""password"" required
                           placeholder=""Enter Password"" value=""test""/>
                    <span class=""Error""></span>",FunctionCall: put(),"HTML 폼의 암호 필드를 채우면 시스템이 손상될 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",5599D05E7D389C18D9C4E21DC428AF18,BE8D46DB-AF04-4F6A-8F32-BC2453961C40,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTFinalEndpointTest.java","JWTFinalEndpointTest.java",28,"public class JWTFinalEndpointTest extends LessonTest {

    private static final String TOKEN_JERRY = ""eyJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTNTEyIn0.eyJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImVtYWlsIjoiamVycnlAd2ViZ29hdC5jb20iLCJ1c2VybmFtZSI6IkplcnJ5In0.xBc5FFwaOcuxjdr_VJ16n8Jb7vScuaZulNTl66F2MWF1aBe47QsUosvbjWGORNcMPiPNwnMu1Yb0WZVNrp2ZXA"";

    @BeforeEach",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",05B714DB705318846C706F98A5F5D82B,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/lessons/jwt/documentation/JWT_libraries.adoc","JWT_libraries.adoc",40,"[source]
----
var token = "" eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.NFvYpuwbF6YWbPyaNAGEPw9wbhiQSovvSrD89B8K7Ng"";

Jwts.parser().setSigningKey(""test"").parseClaimsJws(token);",FunctionCall: put(),"하드코드 API 자격 증명은 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",015B9EA82739D764E7AA308BF9B27AC8,5EEF33DD-D3C6-4AD4-9A76-75981BB1BC3C,,,,Fri May 31 16:52:25 KST 2024,
High,High,Security Features,"02.06. 하드코드된 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java","SpoofCookieAssignmentTest.java",92,"    void validLoginWithoutCookieTest() throws Exception {
        String username = ""webgoat"";
        String password = ""webgoat"";

        ResultActions result = mockMvc.perform(MockMvcRequestBuilders",VariableAccess: password,"Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","Hardcoded Password는 쉽게 해결할 수 없는 방식으로 시스템 보안을 손상시킬 수 있습니다.","암호를 하드코드하는 것은 좋은 방법이 아닙니다. 암호 하드코드는 모든 프로젝트 개발자가 암호를 볼 수 있을 뿐 아니라 문제 해결을 극히 어렵게 만듭니다. 코드가 운영 단계에 들어간 후에는 소프트웨어 패치 없이는 암호를 변경할 수 없습니다. 암호로 보호되는 계정이 침해되면 시스템 소유자는 보안과 가용성 중 한 가지를 선택해야 합니다.


예제 1: 다음 코드는 하드코드된 암호를 사용하여 데이터베이스에 연결합니다.


...
DriverManager.getConnection(url, ""scott"", ""tiger"");
...


이 코드는 성공적으로 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다. 프로그램을 공개한 후에는 프로그램에 패치를 적용해야만 데이터베이스 사용자 “scott”를 암호 “tiger”로 변경할 수 있습니다. 직원이 이 정보에 대한 접근 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다. 이보다 더 나쁜 것은 공격자가 응용 프로그램의 바이트코드에 액세스하게 되면 javap -c 명령을 사용하여 사용된 암호 값이 들어갈 디스어셈블된 코드에 액세스할 수 있다는 것입니다. Example 1의 예제를 실행한 결과는 다음과 비슷합니다.


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 하드코드된 사용자 이름과 암호를 사용하여 Android WebView로 보호된 페이지를 보기 위한 인증을 설정합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed(""guest"", ""allow"");
  }
});
...


Example 1과 마찬가지로 이 코드는 정상 실행되지만 코드에 액세스할 수 있는 사용자는 암호에도 액세스할 수 있습니다.","암호는 하드코드해서는 안 되며 보통 난독 처리하여 외부 소스에서 관리해야 합니다. 시스템의 임의의 장소에 암호를 일반 텍스트로 저장하면 권한이 있는 사용자라면 누구나 암호를 읽어 남용할 가능성이 있습니다. 최소한 암호를 저장하기 전에 해시합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들어, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 이렇게 하면 자격 증명을 암호화된 데이터베이스에 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Java Annotations FortifyPassword 및 FortifyNotPassword를 사용하여 암호를 나타내는 필드 및 변수를 표시할 수 있습니다.

2. null 암호, 빈 암호 또는 Hardcoded Password를 식별할 때 기본 규칙은 password 단어를 포함하는 필드와 변수만 고려합니다. 그러나 Fortify Custom Rules Editor는 사용자가 이름을 지정한 필드 및 변수의 암호 관리 이슈 감지에 필요한 규칙을 쉽게 만들 수 있는 Password Management 마법사를 제공합니다.",73BB11B367C51576A5F497E90D73610B,9C5BD1B5-C296-48d4-B5F5-5D2958661BC4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java","SpoofCookieAssignmentTest.java",75,"    @DisplayName(""Lesson completed"")
    void success() throws Exception {
        Cookie cookie = new Cookie(COOKIE_NAME, ""NjI2MTcwNGI3YTQxNGE1OTU2NzQ2ZDZmNzQ="");

        ResultActions result = mockMvc.perform(MockMvcRequestBuilders","cookie = new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,5C6C933BC6EFA2D878862CE7A905EA14,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",175,"    public void guestShouldNotBeAbleToVote() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/votings/Admin lost password"")
                .cookie(new Cookie(""access_token"", """")))
                .andExpect(status().isUnauthorized());
    }","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,F6DDDC8CC281E1C7E3BC5D355C326A78,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/csrf/CSRFFeedbackTest.java","CSRFFeedbackTest.java",69,"        mockMvc.perform(post(""/csrf/feedback/message"")
                .contentType(MediaType.TEXT_PLAIN)
                .cookie(new Cookie(""JSESSIONID"", ""test""))
                .header(""host"", ""localhost:8080"")
                .header(""referer"", ""webgoat.org"")","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,61FB9E587AFC7E575349CA7AF0B9CEA6,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",199,"
        mockMvc.perform(MockMvcRequestBuilders.get(""/JWT/votings/"")
                .cookie(new Cookie(""access_token"", token)))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$[0].numberOfVotes"").doesNotExist())","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,9E8418E2F076115696DA9D60E786BABC,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",73,"        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/votings"")
                .contentType(MediaType.APPLICATION_JSON)
                .cookie(new Cookie(""access_token"", token)))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$.lessonCompleted"", is(true)));","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,D544E1EEC188809D703680A4D1803783,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","JWTVotesEndpoint.java",106,"                    .compact();
            Cookie cookie = new Cookie(""access_token"", token);
            response.addCookie(cookie);
            response.setStatus(HttpStatus.OK.value());
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);",addCookie(cookie),"true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,578726F41F2BE9F4794DFE64982E3447,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
High,High,Environment,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/i18n/messages.properties","messages.properties",34,"InvalidData=Invalid Data
Go!=Go!
password=Password
password.confirm=Confirm password
username=Username",password(),"구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,668C351ACC6D2190863E12F66A0CB9CA,29C589A2-3796-4486-A12D-BCE05ADFFE11,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignmentTest.java","HijackSessionAssignmentTest.java",84,"        ReflectionTestUtils.setField(assignment, ""provider"", providerMock);

        Cookie cookie = new Cookie(COOKIE_NAME, ""value"");

        ResultActions result = mockMvc.perform(MockMvcRequestBuilders","cookie = new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,F3A07B5B51A01FDB5D0A81F49E26935E,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java","SpoofCookieAssignmentTest.java",113,"            + ""3.- Valid cookie with not known username sent "")
    void cookieLoginNotSolvedFlow(String cookieValue) throws Exception {
        Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
        mockMvc.perform(MockMvcRequestBuilders
            .post(LOGIN_CONTEXT_PATH)","cookie = new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,186F8DC1423231C38139AB4E57D52321,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
High,High,Environment,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/resources/i18n/messages.properties","messages.properties",43,"accounts.table.account=Account
accounts.table.user=User
accounts.table.password=Password
logout=Logout
version=Version","accounts.table.password()","구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,6C0BF3EFA43501984AF71CA8F5754428,29C589A2-3796-4486-A12D-BCE05ADFFE11,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","SpoofCookieAssignment.java",81,"        Cookie cookie = new Cookie(COOKIE_NAME, """");
        cookie.setMaxAge(0);
        response.addCookie(cookie);
    }
",addCookie(cookie),"true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,F64D81CA7ECEE17DF7B083ADB5DF88DA,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",105,"    public void guestShouldNotSeeNumberOfVotes() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get(""/JWT/votings"")
                .cookie(new Cookie(""access_token"", """")))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$[0].numberOfVotes"").doesNotExist())","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,0B76F21F6844615359ED8EDF218BB740,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",130,"    public void invalidTokenShouldSeeGuestView() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get(""/JWT/votings"")
                .cookie(new Cookie(""access_token"", ""abcd.efgh.ijkl"")))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$[0].numberOfVotes"").doesNotExist())","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,236B35D071E058007AFC9324F62C9208,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
High,High,Environment,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/i18n/messages.properties","messages.properties",43,"accounts.table.account=Account
accounts.table.user=User
accounts.table.password=Password
logout=Logout
version=Version","accounts.table.password()","구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,6C0BF3EFA43501984AF71CA8F5754429,29C589A2-3796-4486-A12D-BCE05ADFFE11,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","JWTVotesEndpoint.java",111,"        } else {
            Cookie cookie = new Cookie(""access_token"", """");
            response.addCookie(cookie);
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);",addCookie(cookie),"true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,578726F41F2BE9F4794DFE64982E3448,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
High,High,Environment,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"target/classes/i18n/messages.properties","messages.properties",34,"InvalidData=Invalid Data
Go!=Go!
password=Password
password.confirm=Confirm password
username=Username",password(),"구성 파일에 일반 텍스트 암호를 저장하면 시스템 침해가 발생할 수 있습니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,668C351ACC6D2190863E12F66A0CB9CB,29C589A2-3796-4486-A12D-BCE05ADFFE11,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.05. 암호화되지 않은 중요정보","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",187,"
        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/votings/Admin lost password"")
                .cookie(new Cookie(""access_token"", token)))
                .andExpect(status().isUnauthorized());
    }","new Cookie(...)","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","true로 설정된 Secure 플래그 없이 쿠키가 생성됩니다.","현재 웹 브라우저는 각 쿠키에 대해 Secure 플래그를 지원합니다. 플래그가 설정되면 브라우저는 HTTPS를 통해 쿠키를 전송하기만 합니다. 암호화되지 않은 채널을 통해 쿠키를 전송하면 네트워크 염탐 공격에 노출될 수 있으므로 안전한 플래그를 사용하는 것이 쿠키의 값 자격 증명을 유지하는 데 도움을 줍니다. 이것은 쿠키가 개인 정보를 포함하거나 세션 ID를 전하는 경우 특히 중요합니다.
  

예제 1: 다음 예에서는 Secure 플래그 설정 없이 쿠키가 응답에 추가되었습니다.

	Cookie cookie = new Cookie(""emailCookie"", email);
	response.addCookie(cookie);


응용 프로그램에서 HTTPS 및 HTTP 모두를 사용하지만 Secure 플래그를 설정하지 않는 경우, HTTPS 요청 중에 전송된 쿠키는 다음 HTTP 요청 중에도 전송됩니다. 암호화되지 않은 무선 연결을 통한 네트워크 트래픽 염탐은 공격자에게는 간단한 작업이므로 HTTP를 통한 쿠키(특히 세션 ID가 있는 쿠키) 전송은 응용 프로그램을 손상시킬 수 있습니다.","브라우저가 이러한 쿠키를 암호화하지 않고 전송하지 않도록 지시하려면 모든 새 쿠키에 대해 Secure 플래그를 설정하십시오. 이렇게 하려면 setSecure(true)를 호출합니다.

예제 2:

	Cookie cookie = new Cookie(""emailCookie"", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
",,41AD6E76BD27DA42CA4E1AE6919893FD,AC87E716-8766-4F78-8851-86354C03A13B,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.04. 취약한 암호화 알고리즘 사용","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/cryptography/HashingAssignment.java","HashingAssignment.java",56,"			String secret = SECRETS[new Random().nextInt(SECRETS.length)];
	         
		    MessageDigest md = MessageDigest.getInstance(""MD5"");
		    md.update(secret.getBytes());
		    byte[] digest = md.digest();",getInstance(),"약한 암호화 해시는 데이터의 무결성을 보장할 수 없고 보안이 중요한 컨텍스트에 사용되어서는 안 됩니다.","약한 암호화 해시는 데이터의 무결성을 보장할 수 없고 보안이 중요한 컨텍스트에 사용되어서는 안 됩니다.","MD2, MD4, MD5, RIPEMD-160 및 SHA-1은 메시지 및 기타 데이터의 무결성을 확인하는 데 흔히 사용되는 인기 있는 암호화 해시 알고리즘입니다. 하지만 최근의 암호화 연구를 통해 이러한 알고리즘에 근본적인 취약점이 있음이 밝혀졌으므로 더 이상 보안이 중요한 상황에 사용해서는 안 됩니다.

MD 및 RIPEMD 해시를 효과적으로 해체하기 위한 기법이 널리 사용되고 있으므로 보안을 위해 이러한 알고리즘을 신뢰해서는 안 됩니다. SHA-1의 경우, 현재의 기술은 여전히 상당한 계산 능력이 필요하며 구현하기 더 어렵습니다. 그러나 공격자는 알고리즘의 아킬레스 건을 찾아 이를 해결하는 기술로 심지어 더 빠른 공격을 발견할 수 있습니다.","보안이 중요한 상황에서는 데이터 확인을 위해 MD2, MD4, MD5, RIPEMD-160 및 SHA-1을 사용하지 마십시오. 현재로서는 SHA-224, SHA-256, SHA-384, SHA-512 및 SHA-3가 좋은 대안입니다. 그러나 보안 해시 알고리즘의 이러한 변형은 SHA-1만큼 세밀히 검사되지 않았으므로 이러한 알고리즘의 보안에 영향을 줄 수 있는 앞으로의 조사에 신경을 써야 합니다.",,B975F145AFDE72FB05EFB21574722586,FD6C18E2-3AD8-4842-84CD-3E3D638BCCE4,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",105,"    public void guestShouldNotSeeNumberOfVotes() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get(""/JWT/votings"")
                .cookie(new Cookie(""access_token"", """")))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$[0].numberOfVotes"").doesNotExist())","new Cookie(...)","프로그램은 JWTVotesEndpointTest.java의 105 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,8607E763B43142E5F088D27380E36E74,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",187,"
        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/votings/Admin lost password"")
                .cookie(new Cookie(""access_token"", token)))
                .andExpect(status().isUnauthorized());
    }","new Cookie(...)","프로그램은 JWTVotesEndpointTest.java의 187 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,5EA28DC9DA924A52BF0E2EBBDCED8500,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignment.java","HijackSessionAssignment.java",86,"
    private void setCookie(HttpServletResponse response, String cookieValue) {
        Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
        cookie.setPath(""/WebGoat"");
        cookie.setSecure(true);","cookie = new Cookie(...)","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,0880F0FC34F71C092509C2C3D772697C,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","SpoofCookieAssignment.java",79,"    @GetMapping(path = ""/SpoofCookie/cleanup"")
    public void cleanup(HttpServletResponse response) {
        Cookie cookie = new Cookie(COOKIE_NAME, """");
        cookie.setMaxAge(0);
        response.addCookie(cookie);","cookie = new Cookie(...)","프로그램은 SpoofCookieAssignment.java의 79 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,584E2E53AF58DAD7C2321FCFED128956,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",73,"        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/votings"")
                .contentType(MediaType.APPLICATION_JSON)
                .cookie(new Cookie(""access_token"", token)))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$.lessonCompleted"", is(true)));","new Cookie(...)","프로그램은 JWTVotesEndpointTest.java의 73 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,943242D3CE47CD77B6EF9375F2D5975F,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",175,"    public void guestShouldNotBeAbleToVote() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.post(""/JWT/votings/Admin lost password"")
                .cookie(new Cookie(""access_token"", """")))
                .andExpect(status().isUnauthorized());
    }","new Cookie(...)","프로그램은 JWTVotesEndpointTest.java의 175 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,8FA1AA629794D06700FBF50F8D52FB39,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/hijacksession/HijackSessionAssignmentTest.java","HijackSessionAssignmentTest.java",84,"        ReflectionTestUtils.setField(assignment, ""provider"", providerMock);

        Cookie cookie = new Cookie(COOKIE_NAME, ""value"");

        ResultActions result = mockMvc.perform(MockMvcRequestBuilders","cookie = new Cookie(...)","프로그램은 HijackSessionAssignmentTest.java의 84 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,39DFB59F0EB968BFEE9ED009FEB73D08,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",130,"    public void invalidTokenShouldSeeGuestView() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get(""/JWT/votings"")
                .cookie(new Cookie(""access_token"", ""abcd.efgh.ijkl"")))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$[0].numberOfVotes"").doesNotExist())","new Cookie(...)","프로그램은 JWTVotesEndpointTest.java의 130 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,22CB0C50E1EE38866121DBAB63169C59,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignment.java","SpoofCookieAssignment.java",93,"        if (!authPassword.isBlank() && authPassword.equals(password)) {
            String newCookieValue = EncDec.encode(lowerCasedUsername);
            Cookie newCookie = new Cookie(COOKIE_NAME, newCookieValue);
            newCookie.setPath(""/WebGoat"");
            newCookie.setSecure(true);","newCookie = new Cookie(...)","프로그램은 SpoofCookieAssignment.java의 93 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,19999AF3BF42CF5FB0EBE93AB2D9552F,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/csrf/CSRFFeedbackTest.java","CSRFFeedbackTest.java",69,"        mockMvc.perform(post(""/csrf/feedback/message"")
                .contentType(MediaType.TEXT_PLAIN)
                .cookie(new Cookie(""JSESSIONID"", ""test""))
                .header(""host"", ""localhost:8080"")
                .header(""referer"", ""webgoat.org"")","new Cookie(...)","프로그램은 CSRFFeedbackTest.java의 69 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,274196B165F5651EA1490EAD464DFBD5,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","JWTVotesEndpoint.java",105,"                    .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, JWT_PASSWORD)
                    .compact();
            Cookie cookie = new Cookie(""access_token"", token);
            response.addCookie(cookie);
            response.setStatus(HttpStatus.OK.value());","cookie = new Cookie(...)","프로그램은 JWTVotesEndpoint.java의 105 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,CF9AF8AAE3C4A9A3D65C21AD4C6B1330,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpointTest.java","JWTVotesEndpointTest.java",199,"
        mockMvc.perform(MockMvcRequestBuilders.get(""/JWT/votings/"")
                .cookie(new Cookie(""access_token"", token)))
                .andExpect(status().isOk())
                .andExpect(jsonPath(""$[0].numberOfVotes"").doesNotExist())","new Cookie(...)","프로그램은 JWTVotesEndpointTest.java의 199 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,DE130C18BC9EC6CEE0B1676A562BA8DB,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java","JWTVotesEndpoint.java",110,"            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        } else {
            Cookie cookie = new Cookie(""access_token"", """");
            response.addCookie(cookie);
            response.setStatus(HttpStatus.UNAUTHORIZED.value());","cookie = new Cookie(...)","프로그램은 JWTVotesEndpoint.java의 110 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,87E53A6EE89757C9CAF5C052007554DA,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java","SpoofCookieAssignmentTest.java",113,"            + ""3.- Valid cookie with not known username sent "")
    void cookieLoginNotSolvedFlow(String cookieValue) throws Exception {
        Cookie cookie = new Cookie(COOKIE_NAME, cookieValue);
        mockMvc.perform(MockMvcRequestBuilders
            .post(LOGIN_CONTEXT_PATH)","cookie = new Cookie(...)","프로그램은 SpoofCookieAssignmentTest.java의 113 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,DAD87E6A73C4974E1AEC600225DD36F3,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Security Features,"02.03. 중요한 자원에 대한 잘못된 권한 설정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/spoofcookie/SpoofCookieAssignmentTest.java","SpoofCookieAssignmentTest.java",75,"    @DisplayName(""Lesson completed"")
    void success() throws Exception {
        Cookie cookie = new Cookie(COOKIE_NAME, ""NjI2MTcwNGI3YTQxNGE1OTU2NzQ2ZDZmNzQ="");

        ResultActions result = mockMvc.perform(MockMvcRequestBuilders","cookie = new Cookie(...)","프로그램은 SpoofCookieAssignmentTest.java의 75 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","프로그램은 HijackSessionAssignment.java의 86 줄에 쿠키를 생성하지만 HttpOnly 플래그를 true로 설정하지 못합니다.","모든 주요 브라우저에서는 클라이언트 쪽 스크립트의 쿠키 액세스를 방지하는 HttpOnly 쿠키 속성을 지원합니다. Cross-Site Scripting 공격은 세션 ID 또는 인증 토큰을 도용하기 위해 쿠키에 액세스하는 경우도 있습니다. HttpOnly가 활성화되어 있지 않으면 공격자가 사용자 쿠키에 더 쉽게 액세스할 수 있습니다.


예제 1: 다음 코드는 HttpOnly 속성을 설정하지 않고 쿠키를 생성합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
// Missing a call to: cookie.setHttpOnly(true);
","쿠키를 생성할 때 HttpOnly 속성을 활성화하십시오. 이렇게 하려면 javax.servlet.http.Cookie의 경우 true 인수를 사용하여 setHttpOnly(boolean) 메서드를 호출합니다.

예제 2: 다음 코드는 Example 1의 코드와 동일한 쿠키를 생성하지만 이번에는 HttpOnly 매개 변수를 true로 설정합니다.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(""emailCookie"", email);
cookie.setHttpOnly(true);


하지만 HttpOnly가 true로 설정되었을 때 우회하는 여러 메커니즘이 개발되어 있으므로 완벽한 효과가 있는 것은 아닙니다.",,08EAF117185D240D3F5AF03A83F2E169,1733FB59-CC13-4E99-9638-3D45FEEE9BE1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,API Abuse,"01.15. 보안기능 결정에 사용되는 부적절한 입력값, 07.01. DNS lookup에 의존한 보안 결정","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/PasswordResetLink.java","PasswordResetLink.java",33,"    }

    public static void main(String[] args) {
        if (args == null || args.length != 2) {
            System.out.println(""Need a username and key"");",main(0),"src/test/java/org/owasp/webgoat/lessons/challenges/Assignment1Test.java","Assignment1Test.java",62,"    @Test
    void success() throws Exception {
        InetAddress addr = InetAddress.getLocalHost();
        String host = addr.getHostAddress();
        mockMvc.perform(MockMvcRequestBuilders.post(""/challenge/1"")",getLocalHost(),"getLocalHost()에 대한 호출로 반환된 정보는 신뢰할 수 없습니다. 공격자가 DNS 항목을 스푸핑할 수 있습니다. 보안을 DNS에 의존하지 마십시오.","getLocalHost()에 대한 호출로 반환된 정보는 신뢰할 수 없습니다. 공격자가 DNS 항목을 스푸핑할 수 있습니다. 보안을 DNS에 의존하지 마십시오.","많은 DNS 서버가 스푸핑 공격에 취약하기 때문에 언젠가는 소프트웨어가 손상된 DNS 서버가 있는 환경에서 실행될 수도 있다고 가정해야 합니다. 공격자가 DNS 업데이트를 수행할 수 있게 되면(DNS 캐시 감염(cache-poisoning)이라고도 함) 네트워크 트래픽을 자신의 시스템을 통과하도록 라우팅하거나 자신의 IP 주소가 사용자 도메인의 일부로 보이도록 만듭니다. 시스템 보안을 DNS 이름에 맡길 수 없습니다.


예제: 다음 코드는 DNS 조회를 사용하여 인바운드 요청이 신뢰할 수 있는 호스트의 것인지 여부를 결정합니다. 공격자가 DNS 캐시를 감염시키면 신뢰할 수 있는 지위를 얻게 됩니다.


 String ip = request.getRemoteAddr();
 InetAddress addr = InetAddress.getByName(ip);
 if (addr.getCanonicalHostName().endsWith(""trustme.com"")) {
 trusted = true;
 }


IP 주소는 DNS 이름보다는 신뢰할 수 있지만 역시 스푸핑될 수 있습니다. 공격자는 쉽게 자신들이 보내는 패킷의 원본 IP 주소를 위조할 수 있지만 응답 패킷은 위조된 IP 주소로 반환됩니다. 응답 패킷을 보려면 공격자는 피해자 시스템과 위조된 IP 주소 사이의 트래픽을 염탐해야 합니다. 공격자는 원하는 염탐을 수행하기 위해 보통 피해자 컴퓨터와 같은 서브넷에 있으려고 합니다. 공격자가 소스 라우팅을 사용하면 이 요구 사항을 피해 갈 수도 있지만 오늘날 인터넷의 상당 부분에서 소스 라우팅을 허용하지 않습니다. 간단히 말해, IP 주소 확인은 인증 기법의 필수적인 부분이기는 하지만 authentication에 필요한 유일한 요소는 아닙니다.","호스트의 순방향 및 역방향 DNS 엔트리가 일치하는지 확인하면 도메인 이름 조회에 대한 신뢰가 커질 것입니다. 공격자는 대상 도메인의 이름 서버를 제어하지 않고는 순방향 및 역방향 DNS 엔트리를 모두 스푸핑할 수 없습니다. 하지만 이것도 완벽한 접근 방식은 아닙니다. 공격자가 도메인 등록 기관을 속여 도메인이 악성 이름 서버에 연결되도록 할 수 있습니다. DNS 엔트리를 기반으로 한 authentication은 매우 위험한 발상입니다.

어떤 authentication 메커니즘도 완벽할 수는 없지만 호스트 기반 authentication 보다 나은 대안은 있습니다. 암호 시스템은 양호한 보안 기능을 제공하지만 잘못된 암호 선택, 안전하지 않은 암호 전송 및 잘못된 password management에 취약합니다. SSL과 같은 암호화 기법을 고려해 볼 수 있지만 이 기법은 너무 복잡해서 심각한 구현 오류의 위험이 따라다니고 항상 핵심 요소를 도난 당할 위험이 있습니다. 대부분의 경우, 물리적인 토큰을 비롯한 복수 요소 authentication은 합리적인 비용으로 최고의 보안을 보장합니다.","1. DNS 정보를 사용하는 방법을 검사하십시오. 프로그램의 authentication 메커니즘이 무너질 수 있는지 여부 외에도 DNS 가장이 사회 공학 공격에 이용될 수 있는지도 고려합니다. 예를 들어, 공격자들이 게시가 내부 시스템에서 한 것처럼 보이도록 만들면, 공격자들은 신뢰성을 얻게 될까요?",719393AB8D03F72A694AC68F67C48976,C7D64877-9D39-40E0-9510-5B7051F6E778,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.12. 서버사이드 요청 위조","src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentForgotPassword.java","ResetLinkAssignmentForgotPassword.java",69,"        String resetLink = UUID.randomUUID().toString();
        ResetLinkAssignment.resetLinks.add(resetLink);
        String host = request.getHeader(""host"");
        if (ResetLinkAssignment.TOM_EMAIL.equals(email) && (host.contains(webWolfPort) || host.contains(webWolfHost))) { //User indeed changed the host header.
            ResetLinkAssignment.userToTomResetLink.put(getWebSession().getUserName(), resetLink);","javax.servlet.http.HttpServletRequest.getHeader()","src/main/java/org/owasp/webgoat/lessons/passwordreset/ResetLinkAssignmentForgotPassword.java","ResetLinkAssignmentForgotPassword.java",99,"            HttpHeaders httpHeaders = new HttpHeaders();
            HttpEntity httpEntity = new HttpEntity(httpHeaders);
            new RestTemplate().exchange(String.format(""http://%s/PasswordReset/reset/reset-password/%s"", host, resetLink), HttpMethod.GET, httpEntity, Void.class);
        } catch (Exception e) {
            //don't care","org.springframework.web.client.RestTemplate.exchange()","99 줄의 exchange() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.","99 줄의 exchange() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.","공격자가 응용 프로그램 서버에서 설정된 네트워크 연결에 영향을 미칠 수 있을 때 SSRF(Server-Side Request Forgery)가 발생합니다. 네트워크 연결의 출처는 응용 프로그램 서버 내부 IP가 되며, 공격자는 이 연결을 이용해서 네트워크 제어를 무시하고 원래는 노출되지 않은 내부 리소스를 스캔 또는 공격할 수 있게 됩니다.



예제: 다음은 공격자가 서버가 연결하는 URL을 제어할 수 있게 되는 예입니다.


String url = request.getParameter(""url"");
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet(url);
CloseableHttpResponse response1 = httpclient.execute(httpGet);


공격자가 네트워크 연결을 하이재킹하는 능력은 해당 공격자가 제어 가능한 URI의 특정 부분 및 연결에 사용된 라이브러리에 좌우됩니다. 예를 들어, URI 스키마를 제어할 수 있게 되면 공격자는 http 또는 https와는 다른 다음 프로토콜을 사용할 수 있게 됩니다.

- up://
- ldap://
- jar://
- gopher://
- mailto://
- ssh2://
- telnet://
- expect://

이렇게 하이재킹된 네트워크 연결을 이용하여 공격자는 다음과 같은 공격을 수행할 수 있습니다.

- 인트라넷 리소스 포트 스캐닝
- 방화벽 무시
- 응용 프로그램 서버 또는 인트라넷에서 실행 중인 취약 프로그램 공격
- Injection 공격 또는 CSRF를 활용한 내/외부 웹 응용 프로그램 공격
- file:// 스키마를 활용하여 로컬 파일에 접근
- Windows 시스템에서 공격자가 file:// 스키마 및 UNC 경로를 통해 내부 공유 자료에 접근 및 스캔 가능
- DNS 캐시 감염 공격 수행","사용자 제어 데이터를 기반으로 하여 네트워크 연결을 설정하지 마십시오. 또한 요청은 예정된 대상으로 전달되는지 확인해야 합니다. 대상 URI 구축을 위해 사용자 데이터가 필요한 경우에는 다음과 같은 간접 참조를 사용하십시오. 즉, 사용자가 선택해야 하는 올바른 리소스 이름의 목록을 만듭니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.

또한 필요한 경우 사용자 입력이 대상 시스템의 지정된 리소스에만 사용되도록 하십시오. URI 스키마, 호스트, 포트는 응용 프로그램이 제어하도록 해야 합니다. 이런 방식을 통해 공격자가 가할 수 있는 피해를 크게 줄일 수 있습니다.",,8424887FE95EE2851407A54D8639617B,6236DDEA-0E1F-4CDA-A93D-D4FA760EBB51,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.12. 서버사이드 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",53,"        if (url.matches(""http://ifconfig.pro"")) {
            String html;
            try (InputStream in = new URL(url).openStream()) {
                html = new String(in.readAllBytes(), StandardCharsets.UTF_8)
                        .replaceAll(""\n"",""<br>""); // Otherwise the \n gets escaped in the response","java.net.URL.openStream()","53 줄의 openStream() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.","99 줄의 exchange() 함수는 리소스 URI에 사용자 제어 데이터를 사용하여 타사 시스템과의 네트워크 연결을 시작합니다. 공격자는 이 취약점을 활용하여 응용 프로그램 서버 대신 요청을 보낼 수 있습니다. 해당 요청의 출처는 응용 프로그램 서버 내부 IP 주소이기 때문입니다.","공격자가 응용 프로그램 서버에서 설정된 네트워크 연결에 영향을 미칠 수 있을 때 SSRF(Server-Side Request Forgery)가 발생합니다. 네트워크 연결의 출처는 응용 프로그램 서버 내부 IP가 되며, 공격자는 이 연결을 이용해서 네트워크 제어를 무시하고 원래는 노출되지 않은 내부 리소스를 스캔 또는 공격할 수 있게 됩니다.



예제: 다음은 공격자가 서버가 연결하는 URL을 제어할 수 있게 되는 예입니다.


String url = request.getParameter(""url"");
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet(url);
CloseableHttpResponse response1 = httpclient.execute(httpGet);


공격자가 네트워크 연결을 하이재킹하는 능력은 해당 공격자가 제어 가능한 URI의 특정 부분 및 연결에 사용된 라이브러리에 좌우됩니다. 예를 들어, URI 스키마를 제어할 수 있게 되면 공격자는 http 또는 https와는 다른 다음 프로토콜을 사용할 수 있게 됩니다.

- up://
- ldap://
- jar://
- gopher://
- mailto://
- ssh2://
- telnet://
- expect://

이렇게 하이재킹된 네트워크 연결을 이용하여 공격자는 다음과 같은 공격을 수행할 수 있습니다.

- 인트라넷 리소스 포트 스캐닝
- 방화벽 무시
- 응용 프로그램 서버 또는 인트라넷에서 실행 중인 취약 프로그램 공격
- Injection 공격 또는 CSRF를 활용한 내/외부 웹 응용 프로그램 공격
- file:// 스키마를 활용하여 로컬 파일에 접근
- Windows 시스템에서 공격자가 file:// 스키마 및 UNC 경로를 통해 내부 공유 자료에 접근 및 스캔 가능
- DNS 캐시 감염 공격 수행","사용자 제어 데이터를 기반으로 하여 네트워크 연결을 설정하지 마십시오. 또한 요청은 예정된 대상으로 전달되는지 확인해야 합니다. 대상 URI 구축을 위해 사용자 데이터가 필요한 경우에는 다음과 같은 간접 참조를 사용하십시오. 즉, 사용자가 선택해야 하는 올바른 리소스 이름의 목록을 만듭니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.

또한 필요한 경우 사용자 입력이 대상 시스템의 지정된 리소스에만 사용되도록 하십시오. URI 스키마, 호스트, 포트는 응용 프로그램이 제어하도록 해야 합니다. 이런 방식을 통해 공격자가 가할 수 있는 피해를 크게 줄일 수 있습니다.",,1CE8A3993EC5BF68D0047C66EA8F9468,33DDCCB9-248C-46E8-BF4E-0A8DFA006946,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",26,"				action=""/WebGoat/HttpBasics/attack1"">
				<div id=""lessonContent"">
					<form accept-charset=""UNKNOWN"" method=""POST"" name=""form""
						action=""#attack/307/100"">
						Enter Your Name: <input name=""person"" value="""" type=""TEXT""/><input","java.net.URL.openStream()","HttpBasics.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3A8B21C95D5FED43561E579326E658FE,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",81,"        <div class=""adoc-content"" th:replace=""doc:lessons/idor/documentation/IDOR_whatDiffs.adoc""></div>
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form""
              method=""POST"" name=""diff-form""
              action=""IDOR/diff-attributes"">","java.net.URL.openStream()","IDOR.html 파일의 81 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04799,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",223,"                                Forgot your password?
                            </h4>
                            <form class=""attack-form"" accept-charset=""UNKNOWN""
                                  method=""POST"" name=""form""
                                  action=""/WebGoat/PasswordReset/ForgotPassword/create-password-reset-link""","java.net.URL.openStream()","PasswordReset.html 파일의 223 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D6,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/webwolfintroduction/html/WebWolfIntroduction.html","WebWolfIntroduction.html",19,"        
        
        <form class=""attack-form"" accept-charset=""UNKNOWN""  style=""position:relative;top:150px""
              method=""POST"" name=""form""
              action=""/WebGoat/WebWolf/mail/"">","java.net.URL.openStream()","WebWolfIntroduction.html 파일의 19 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",10C2F89FE369D1686B3089C90D179ECA,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",121,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""container-fluid"">
            <form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/JWT/quiz""","java.net.URL.openStream()","JWT.html 파일의 121 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACAB,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/missingac/html/MissingFunctionAC.html","MissingFunctionAC.html",99,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/access-control/user-hash-fix"">","java.net.URL.openStream()","MissingFunctionAC.html 파일의 99 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAC1D7F15182A02E5CF2161174770D06,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScriptingStored.html","CrossSiteScriptingStored.html",68,"		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

		<form class=""attack-form"" accept-charset=""UNKNOWN""
			  method=""POST"" name=""DOMFollowUp""
			  action=""/WebGoat/CrossSiteScripting/stored-xss-follow-up"">","java.net.URL.openStream()","CrossSiteScriptingStored.html 파일의 68 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EE063DE011B0368203272E8568B07AB3,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",16,"    <div class=""attack-container"">
        <img th:src=""@{/images/wolf-enabled.png}"" class=""webwolf-enabled""/>
        <form id=""decode"" class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/JWT/decode"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <br>","java.net.URL.openStream()","JWT.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA3,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",70,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'","java.net.URL.openStream()","PathTraversal.html 파일의 70 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD551,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",64,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack4""","java.net.URL.openStream()","SqlInjection.html 파일의 64 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE2,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",45,"    <div class=""adoc-content"" th:replace=""doc:lessons/sqlinjection/documentation/SqlInjection_jdbc_newcode.adoc""></div>
    <div class=""attack-container"" style=""border: none !important; height: 100%; min-height: 300px;"">
        <form id=""codesubmit"" style=""height: 100%; min-height: 300px;"" class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/SqlInjectionMitigations/attack10b"">
            <div>
                <div id=""editor"" style=""position: absolute; top: 0; right: 0; bottom: 0; left: 0; height: 300px;"" name=""editor""></div>","java.net.URL.openStream()","SqlInjectionMitigations.html 파일의 45 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C279,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",29,"
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 29 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",1C8BAA8A01F4D74F8BCFFED5EAD14FB4,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",65,"                                        </div>
                                    </form>
                                    <form id=""register-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""PUT"" name=""form""
                                          action=""/WebGoat/challenge/6"" style=""display: none;"" role=""form"">",FunctionPointerCall: get(),"Challenge6.html 파일의 65 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2C1A9F3ED0930D0BB75FC3067CF7FF91,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",169,"            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <div class=""container-fluid"">
                <form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                      method=""POST"" name=""form""
                      action=""/WebGoat/SqlInjectionAdvanced/quiz""",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 169 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C11,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/goatApp/support/GoatUtils.js","GoatUtils.js",56," 
                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $(""#lesson_cookies"").html(reply);
                    }, ""html"");",FunctionPointerCall: get(),"GoatUtils.js의 56 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",50A06639EB7772D5A255C110E0820C1B,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",80,"                            <div class=""row"">
                                <div class=""col-lg-12"">
                                    <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""POST"" name=""form""
                                          action=""/WebGoat/SqlInjectionAdvanced/challenge_Login""",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 80 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C14,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",FunctionPointerCall: get(),"challenge8.js의 7 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3527F5DD91FAF3B169A3354249F29F2D,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",96,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlOnlyInputValidationOnKeywords/attack""",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 96 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C281,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/goatApp/controller/LessonController.js","LessonController.js",147,"                $.ajax({
                    url:'service/restartlesson.mvc',
                    method:'GET'
                }).done(function(lessonLink) {
                    self.loadLesson(self.name);",AssignmentStatement(),"LessonController.js의 147 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BA7AFE6D4A7BC28C9963F9F3B54C6BE0,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",188,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              additionalHeaders=""addBearerToken""",AssignmentStatement(),"JWT.html 파일의 188 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",169,"		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
		<div class=""container-fluid"">
			<form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
				  method=""POST"" name=""form""
				  action=""/WebGoat/CrossSiteScripting/quiz"" role=""form"">",AssignmentStatement(),"CrossSiteScripting.html 파일의 169 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",26,"
function average() {
    $.get(""challenge/8/votes/average"", function (average) {
            for (var i = 1; i <= 5; i++) {
                var number = average[""average""];",FunctionPointerCall: get(),"challenge8.js의 26 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",000535B7CA42ECAD3BE1D2CF4F4A7549,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/insecurelogin/html/InsecureLogin.html","InsecureLogin.html",26,"            </form>
            <br></br>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
                  method=""POST""
                  action=""/WebGoat/InsecureLogin/task"">",FunctionPointerCall: get(),"InsecureLogin.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4D7BBDF1176A27BDC81D85444FDAD608,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",223,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 223 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD554,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/goatApp/goatApp.js","goatApp.js",21,"            initApp: function () {
                var locale = localStorage.getItem('locale') || 'en';
                $.getJSON('service/labels.mvc', function(data) {
                    window.polyglot = new Polyglot({phrases: data});//i18n polyglot labels
                    asyncErrorHandler.init();",FunctionPointerCall: getJSON(),"goatApp.js의 21 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7AF79A2E182123F0E8A1F1E7FF37294C,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/insecurelogin/html/InsecureLogin.html","InsecureLogin.html",18,"            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <script th:src=""@{/lesson_js/credentials.js}""></script>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
                  method=""POST""
                  action=""/WebGoat/InsecureLogin/task"">",FunctionPointerCall: getJSON(),"InsecureLogin.html 파일의 18 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4D7BBDF1176A27BDC81D85444FDAD609,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/templates/password_reset.html","password_reset.html",12,"    <div class=""row"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"">
            <form role=""form"" method=""POST"" action=""/WebGoat/PasswordReset/reset/change-password"" th:object=""${form}"" novalidate=""novalidate"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                    <div class=""form-group"" th:classappend=""${#fields.hasErrors('password')}? 'has-error'"">",FunctionPointerCall: getJSON(),"password_reset.html 파일의 12 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",D43855E84896397A44FACA8DCC70285D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/cryptography/html/Cryptography.html","Cryptography.html",48,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/encoding/xor"">
			Suppose you found the database password encoded as {xor}Oz4rPj0+LDovPiwsKDAtOw==<br/>
			What would be the actual password",FunctionPointerCall: getJSON(),"Cryptography.html 파일의 48 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA17867F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",45,"    <div class=""adoc-content"" th:replace=""doc:lessons/sqlinjection/documentation/SqlInjection_jdbc_newcode.adoc""></div>
    <div class=""attack-container"" style=""border: none !important; height: 100%; min-height: 300px;"">
        <form id=""codesubmit"" style=""height: 100%; min-height: 300px;"" class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/SqlInjectionMitigations/attack10b"">
            <div>
                <div id=""editor"" style=""position: absolute; top: 0; right: 0; bottom: 0; left: 0; height: 300px;"" name=""editor""></div>",FunctionPointerCall: getJSON(),"SqlInjectionMitigations.html 파일의 45 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C27F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",144,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/PasswordReset/SecurityQuestions"">",FunctionPointerCall: getJSON(),"PasswordReset.html 파일의 144 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D3,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webwolf/templates/files.html","files.html",37,"
            <!-- Standard Form -->
            <form th:action=""@{/fileupload}"" method=""post"" enctype=""multipart/form-data"">
                <div class=""form-inline"">
                    <div class=""form-group"">",FunctionPointerCall: getJSON(),"files.html 파일의 37 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2369EB268BC6AFC62E47098371AD7139,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/libs/ace.js","ace.js",4157,"exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {",FunctionPointerCall: open(),"ace.js의 4157 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",45BD9D7C7783F2A580D7752F1919D11A,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",213,"            </i>
        </div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""confirm-flag-feedback""
              method=""POST"" name=""form2""
              action=""/WebGoat/csrf/feedback"">",FunctionPointerCall: open(),"CSRF.html 파일의 213 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C84,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/htmltampering/html/HtmlTampering.html","HtmlTampering.html",14,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""task"" name=""task""
              method=""POST""
              action=""/WebGoat/HtmlTampering/task"">",FunctionPointerCall: open(),"HtmlTampering.html 파일의 14 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BF4A1EA0ED5D937DC6CEBF1A7550723D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",59,"
function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 59 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EEE06D34A5BE7F2EB9D6F335FB4E3930,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",189,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/assignment5b"">",FunctionPointerCall: get(),"SqlInjection.html 파일의 189 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94ADC,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",73,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlOnlyInputValidation/attack""",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 73 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C280,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",188,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              additionalHeaders=""addBearerToken""",FunctionPointerCall: get(),"JWT.html 파일의 188 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACAD,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",154,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/JWT/secret"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"JWT.html 파일의 154 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA6,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",187,"                        </h4>
                        <div style=""padding: 20px;"" id=""password-login"">
                            <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                  method=""POST"" name=""form""
                                  action=""/WebGoat/PasswordReset/reset/login""",FunctionPointerCall: get(),"PasswordReset.html 파일의 187 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D5,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",46,"
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 46 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0975B6FFE681C553C928AA3206415535,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",21,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjectionAdvanced/attack6a"">",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 21 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C12,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/bypassrestrictions/html/BypassRestrictions.html","BypassRestrictions.html",66,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

        <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""frontendValidation""
              id=""frontendValidation""
              method=""POST""",FunctionPointerCall: get(),"BypassRestrictions.html 파일의 66 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A6651197000B5D91E5655D74A0987409,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/securepasswords/html/SecurePasswords.html","SecurePasswords.html",21,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SecurePasswords/assignment""",FunctionPointerCall: get(),"SecurePasswords.html 파일의 21 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",096013ED86D3805FFA8D87ED74171F1D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/goatApp/controller/LessonController.js","LessonController.js",147,"                $.ajax({
                    url:'service/restartlesson.mvc',
                    method:'GET'
                }).done(function(lessonLink) {
                    self.loadLesson(self.name);",AssignmentStatement(),"LessonController.js의 147 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BA7AFE6D4A7BC28C9963F9F3B54C6BE1,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",FunctionPointerCall: get(),"challenge8.js의 7 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3527F5DD91FAF3B169A3354249F29F2C,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",135,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""view-other""
              method=""GET"" name=""view-other-profile""
              action=""/WebGoat/IDOR/profile/{userId}"">",FunctionPointerCall: get(),"IDOR.html 파일의 135 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E0479B,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/insecurelogin/js/credentials.js","credentials.js",3,"function submit_secret_credentials() {
    var xhttp = new XMLHttpRequest();
    xhttp['open']('POST', 'InsecureLogin/login', true);
	//sending the request is obfuscated, to descourage js reading
	var _0xb7f9=[""\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B"",""\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C"",""\x73\x74\x72\x69\x6E\x67\x69\x66\x79"",""\x73\x65\x6E\x64""];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]]({username:_0xb7f9[0],password:_0xb7f9[1]}))",FunctionPointerCall: open(),"credentials.js의 3 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EECDCB57ABDA2D41DC802D2361085A04,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/cryptography/html/Cryptography.html","Cryptography.html",113,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/secure/defaults"">
			What is the unencrypted message<br/>
			<input name=""secretText"" value="""" type=""TEXT""/><br/>",FunctionPointerCall: open(),"Cryptography.html 파일의 113 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178687,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",176,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/PasswordReset/reset/login"">",FunctionPointerCall: open(),"PasswordReset.html 파일의 176 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D4,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webwolf/templates/webwolf-login.html","webwolf-login.html",17,"    <div class=""row"" style=""margin-top:20px"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"" th:style=""'background:url(' + @{/images/wolf.png} + ') no-repeat right;'"">
            <form th:action=""@{/login}"" method=""post"">
                <fieldset>
                    <h2>Sign in</h2>",FunctionPointerCall: open(),"webwolf-login.html 파일의 17 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",474384F066BFF762CC18ED271982CF67,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",23,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/IDOR/login"">",FunctionPointerCall: open(),"IDOR.html 파일의 23 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04791,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",53,"
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 53 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",525FB32CE4551ACE423E582CDE3E7169,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",125,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjectionMitigations/attack12a"">",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 125 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C27C,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",102,"        </div>
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge6.html 파일의 102 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2C1A9F3ED0930D0BB75FC3067CF7FF92,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/httpproxies/html/HttpProxies.html","HttpProxies.html",25,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""intercept-request""
                  method=""POST""
                  action=""/WebGoat/HttpProxies/intercept-request"">",FunctionPointerCall: get(),"HttpProxies.html 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",56A9484F62E8C34353C055FCB0BB44C6,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",17,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
              method=""POST""
              action=""/WebGoat/LogSpoofing/log-spoofing"">",FunctionPointerCall: get(),"LogSpoofing.html 파일의 17 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",964EA60A840D419BB41C3E8CB1728B10,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge8.html","Challenge8.html",234,"
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge8.html 파일의 234 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A2D9870E3A1E9581F592DACF90D88236,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/missingac/html/MissingFunctionAC.html","MissingFunctionAC.html",99,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/access-control/user-hash-fix"">",FunctionPointerCall: get(),"MissingFunctionAC.html 파일의 99 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAC1D7F15182A02E5CF2161174770D09,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",192,"
            <br/>
            <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/PathTraversal/random"">
                <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
                <div class=""form-group"">",FunctionPointerCall: get(),"PathTraversal.html 파일의 192 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD54E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/lessontemplate/html/LessonTemplate.html","LessonTemplate.html",48,"
            <!-- modify the action to point to the intended endpoint and set other attributes as desired -->
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/lesson-template/sample-attack"">",FunctionPointerCall: get(),"LessonTemplate.html 파일의 48 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",5398CF5729860E51D8F37DAF248E5965,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",144,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/assignment5a"">",FunctionPointerCall: get(),"SqlInjection.html 파일의 144 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE4,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",134,"	<div class=""attack-container"">
		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
		<form class=""attack-form"" accept-charset=""UNKNOWN""
			  method=""POST"" name=""DOMTestRoute""
			  action=""/WebGoat/CrossSiteScripting/attack6a"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 134 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448AA,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",70,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 70 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD54C,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",125,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 125 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD54D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java","WebSecurityConfig.java",74,"        security.and()
                .logout().deleteCookies(""JSESSIONID"").invalidateHttpSession(true);
        security.and().csrf().disable();

        http.headers().cacheControl().disable();",FunctionCall: disable(),"WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F440379C0474B4FB9528D4884CF46526,E1187028-6481-47EC-B923-5E91EB7178EB,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/authbypass/js/bypass.js","bypass.js",11,"    console.warn(""on view profile activated"")
    webgoat.customjs.jquery.ajax({
        method: ""GET"",
        url: ""/WebGoat/IDOR/profile"",
        contentType: 'application/json; charset=UTF-8'",AssignmentStatement(),"bypass.js의 11 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",155AFEDD4076DF24A7A417B4F655C031,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/authbypass/js/bypass.js","bypass.js",11,"    console.warn(""on view profile activated"")
    webgoat.customjs.jquery.ajax({
        method: ""GET"",
        url: ""/WebGoat/IDOR/profile"",
        contentType: 'application/json; charset=UTF-8'",AssignmentStatement(),"bypass.js의 11 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",155AFEDD4076DF24A7A417B4F655C02E,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",187,"                        </h4>
                        <div style=""padding: 20px;"" id=""password-login"">
                            <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                  method=""POST"" name=""form""
                                  action=""/WebGoat/PasswordReset/reset/login""",AssignmentStatement(),"PasswordReset.html 파일의 187 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167CD,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",46,"
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 46 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0975B6FFE681C553C928AA3206415536,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/cryptography/html/Cryptography.html","Cryptography.html",65,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/hashing"">
			Which password belongs to this hash: <div id=""md5token"" ></div>
			<input name=""answer_pwd1"" value="""" type=""TEXT""/><br/>",FunctionPointerCall: get(),"Cryptography.html 파일의 65 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178680,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",43,"            </form>

            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""change-password-form""
                  method=""POST"" name=""form""
                  successCallback=""onBypassResponse""",FunctionPointerCall: get(),"AuthBypass.html 파일의 43 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",74DEE5421CC7E4BC873EBC9C15A1AF2A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",23,"            <!-- modify the action to point to the intended endpoint and set other attributes as desired -->
            <script th:src=""@{/lesson_js/bypass.js}"" />
            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""verify-account-form""
                  method=""POST"" name=""form""
                  successCallback=""onBypassResponse""",FunctionPointerCall: get(),"AuthBypass.html 파일의 23 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",74DEE5421CC7E4BC873EBC9C15A1AF29,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/js/challenge8.js","challenge8.js",26,"
function average() {
    $.get(""challenge/8/votes/average"", function (average) {
            for (var i = 1; i <= 5; i++) {
                var number = average[""average""];",FunctionPointerCall: get(),"challenge8.js의 26 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",000535B7CA42ECAD3BE1D2CF4F4A754A,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xxe/js/xxe.js","xxe.js",72,"
function getComments(field) {
    $.get(""xxe/comments"", function (result, status) {
        $(field).empty();
        for (var i = 0; i < result.length; i++) {",FunctionPointerCall: get(),"xxe.js의 72 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7AC94BE1C2E42CE6539F660CA103980A,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/deserialization/html/InsecureDeserialization.html","InsecureDeserialization.html",26,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
                  method=""POST""
                  action=""/WebGoat/InsecureDeserialization/task"">",FunctionPointerCall: get(),"InsecureDeserialization.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",B5110FF449C669AE89E8F7C54648FA3A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xxe/html/XXE.html","XXE.html",92,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              prepareData=""contentTypeXXE""",FunctionPointerCall: get(),"XXE.html 파일의 92 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E17C19FEC3217C8FA0FC00684D6C2C5E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/securepasswords/html/SecurePasswords.html","SecurePasswords.html",21,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SecurePasswords/assignment""",FunctionPointerCall: get(),"SecurePasswords.html 파일의 21 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",096013ED86D3805FFA8D87ED74171F1E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",13,"	<div class=""attack-container"">
		<div id=""lessonContent"">
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				  method=""POST"" name=""form""
				  action=""/WebGoat/CrossSiteScripting/attack1"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 13 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A3,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",121,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""container-fluid"">
            <form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/JWT/quiz""",FunctionPointerCall: get(),"JWT.html 파일의 121 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA5,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",189,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/assignment5b"">",FunctionPointerCall: get(),"SqlInjection.html 파일의 189 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE5,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",93,"                    <div class=""post-footer"">
                        <div class=""input-group"">
                            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""csrf-review""
                                  method=""POST"" name=""review-form""
                                  successCallback=""""",FunctionPointerCall: get(),"CSRF.html 파일의 93 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C82,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",17,"
function ajaxFunction(userId) {
    $.get(""clientSideFiltering/salaries?userId="" + userId, function (result, status) {
        var html = ""<table border = '1' width = '90%' align = 'center'"";
        html = html + '<tr>';",FunctionPointerCall: get(),"clientSideFiltering.js의 17 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6AE026590F66DE6BCB75D754A72D34E,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",134,"	<div class=""attack-container"">
		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
		<form class=""attack-form"" accept-charset=""UNKNOWN""
			  method=""POST"" name=""DOMTestRoute""
			  action=""/WebGoat/CrossSiteScripting/attack6a"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 134 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A5,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",24,"	<div class=""adoc-content"" th:replace=""doc:lessons/xss/documentation/CrossSiteScripting_content8b.adoc""></div>
	<div class=""attack-container"" style=""height: 100%; border: none !important;min-height: 450px;"">
		<form id=""codesubmit"" style=""height: 100%; min-height: 350px;"" class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/CrossSiteScripting/attack3"">
			<div>
				<div id=""editor"" style=""position: absolute; top: 0; right: 0; bottom: 0; left: 0; height: 350px;"" name=""editor""></div>",FunctionPointerCall: get(),"CrossSiteScriptingMitigation.html 파일의 24 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E6C77171CECEF2D0FFDF88B32948F92E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/cryptography/html/Cryptography.html","Cryptography.html",31,"			Now suppose you have intercepted the following header:<br/>
			<div id=""basicauthtoken"" ></div><br/>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/encoding/basic-auth"">
			Then what was the username 
			<input name=""answer_user"" value="""" type=""TEXT""/>",FunctionPointerCall: get(),"Cryptography.html 파일의 31 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA17867E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",159,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""edit-other""
              method=""GET"" name=""edit-other-profile""
              action=""/WebGoat/IDOR/profile/{userId}"">",FunctionPointerCall: get(),"IDOR.html 파일의 159 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04796,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",64,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack4""",FunctionPointerCall: get(),"SqlInjection.html 파일의 64 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AD9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/insecurelogin/html/InsecureLogin.html","InsecureLogin.html",18,"            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <script th:src=""@{/lesson_js/credentials.js}""></script>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
                  method=""POST""
                  action=""/WebGoat/InsecureLogin/task"">",FunctionPointerCall: get(),"InsecureLogin.html 파일의 18 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4D7BBDF1176A27BDC81D85444FDAD607,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",125,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjectionMitigations/attack12a"">",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 125 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C282,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/js/stored-xss.js","stored-xss.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('CrossSiteScripting/stored-xss', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",FunctionPointerCall: get(),"stored-xss.js의 35 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",9024A8FFC6D92B54297613DA3037936A,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/cryptography/html/Cryptography.html","Cryptography.html",48,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/encoding/xor"">
			Suppose you found the database password encoded as {xor}Oz4rPj0+LDovPiwsKDAtOw==<br/>
			What would be the actual password",FunctionPointerCall: get(),"Cryptography.html 파일의 48 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178684,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/templates/registration.html","registration.html",26,"            <fieldset>
                <legend th:text=""#{register.title}"">Please Sign Up</legend>
                <form class=""form-horizontal"" action=""#"" th:action=""@{/register.mvc}"" th:object=""${userForm}""
                      method='POST'>
",FunctionPointerCall: get(),"registration.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8163F475A4C2DD0B7EBACD25DAA6D714,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/csrf/js/csrf-review.js","csrf-review.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('csrf/review', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",FunctionPointerCall: get(),"csrf-review.js의 35 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8D43711D3B053D3BF99623CA6B92BF58,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",116,"                                        </div>
                                    </form>
                                    <form id=""register-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""PUT"" name=""form""
                                          action=""/WebGoat/SqlInjectionAdvanced/challenge""",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 116 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C15,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",81,"        <div class=""adoc-content"" th:replace=""doc:lessons/idor/documentation/IDOR_whatDiffs.adoc""></div>
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form""
              method=""POST"" name=""diff-form""
              action=""IDOR/diff-attributes"">",FunctionPointerCall: get(),"IDOR.html 파일의 81 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04793,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge5.html","Challenge5.html",26,"                            <div class=""row"">
                                <div class=""col-lg-12"">
                                    <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""POST"" name=""form""
                                          action=""/WebGoat/challenge/5"" role=""form"">",FunctionPointerCall: get(),"Challenge5.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E8B846BE88EA23B5B0EE7FB3F002C2EC,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/js/jwt-voting.js","jwt-voting.js",43,"function getVotings() {
    $(""#votesList"").empty();
    $.get(""JWT/votings"", function (result, status) {
        for (var i = 0; i < result.length; i++) {
            var voteTemplate = html.replace('IMAGE_SMALL', result[i].imageSmall);",FunctionPointerCall: get(),"jwt-voting.js의 43 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8A8C421594BE93B011596EC0C47EE46D,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",144,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/assignment5a"">",FunctionPointerCall: get(),"SqlInjection.html 파일의 144 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94ADB,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",102,"        </div>
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge6.html 파일의 102 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2C1A9F3ED0930D0BB75FC3067CF7FF95,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/ssrf/js/credentials.js","credentials.js",3,"function submit_secret_credentials() {
    var xhttp = new XMLHttpRequest();
    xhttp['open']('POST', '#attack/307/100', true);
	//sending the request is obfuscated, to descourage js reading
	var _0xb7f9=[""\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B"",""\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C"",""\x73\x74\x72\x69\x6E\x67\x69\x66\x79"",""\x73\x65\x6E\x64""];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]]({username:_0xb7f9[0],password:_0xb7f9[1]}))",FunctionPointerCall: open(),"credentials.js의 3 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",AFC587ECB9060D79D73793E5BDA09B6A,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",23,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/IDOR/login"">",FunctionPointerCall: open(),"IDOR.html 파일의 23 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04797,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/cryptography/html/Cryptography.html","Cryptography.html",31,"			Now suppose you have intercepted the following header:<br/>
			<div id=""basicauthtoken"" ></div><br/>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/encoding/basic-auth"">
			Then what was the username 
			<input name=""answer_user"" value="""" type=""TEXT""/>",FunctionPointerCall: open(),"Cryptography.html 파일의 31 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178683,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/webwolfintroduction/html/WebWolfIntroduction.html","WebWolfIntroduction.html",40,"        <br/>
        <!-- <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>-->
        <form class=""attack-form"" accept-charset=""UNKNOWN""  style=""position:relative;top:-50px""
              method=""POST"" name=""secondform""
              action=""/WebGoat/WebWolf/mail/send"">",FunctionPointerCall: open(),"WebWolfIntroduction.html 파일의 40 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",10C2F89FE369D1686B3089C90D179ECB,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",25,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""DOMFollowUp""
              action=""/WebGoat/ChromeDevTools/dummy"">",FunctionPointerCall: open(),"ChromeDevTools.html 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F72EADE1B421BCEC4CC3620163389B67,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",22,"            <!-- you can write your own custom forms, but standard form submission will take you to your endpoint and outside of the WebGoat framework -->
            <!-- of course, you can write your own ajax submission /handling in your own javascript if you like -->
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				method=""POST"" name=""form""
				action=""/WebGoat/HttpBasics/attack1"">",FunctionPointerCall: open(),"HttpBasics.html 파일의 22 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3A8B21C95D5FED43561E579326E658FD,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",12,"    <div class=""row"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"">
            <form role=""form"" method=""GET"" th:action=""${webwolfUrl}"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                <input type=""hidden"" name=""uniqueCode"" th:value=""${uniqueCode}""/>",FunctionPointerCall: open(),"webwolfPasswordReset.html 파일의 12 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2EB580B676BFEC4BDA4F6BDCE94CB0F9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/webwolfintroduction/templates/webwolfPasswordReset.html","webwolfPasswordReset.html",12,"    <div class=""row"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"">
            <form role=""form"" method=""GET"" th:action=""${webwolfUrl}"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                <input type=""hidden"" name=""uniqueCode"" th:value=""${uniqueCode}""/>",FunctionPointerCall: open(),"webwolfPasswordReset.html 파일의 12 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2EB580B676BFEC4BDA4F6BDCE94CB0FA,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",24,"	<div class=""adoc-content"" th:replace=""doc:lessons/xss/documentation/CrossSiteScripting_content8b.adoc""></div>
	<div class=""attack-container"" style=""height: 100%; border: none !important;min-height: 450px;"">
		<form id=""codesubmit"" style=""height: 100%; min-height: 350px;"" class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/CrossSiteScripting/attack3"">
			<div>
				<div id=""editor"" style=""position: absolute; top: 0; right: 0; bottom: 0; left: 0; height: 350px;"" name=""editor""></div>",FunctionPointerCall: open(),"CrossSiteScriptingMitigation.html 파일의 24 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E6C77171CECEF2D0FFDF88B32948F930,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",146,"                    <div class=""col-md-8"">
                        <div class=""well well-sm"">
                            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""csrf-feedback""
                                  method=""POST""
                                  prepareData=""feedback""",FunctionPointerCall: open(),"CSRF.html 파일의 146 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C88,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",23,"            <!-- modify the action to point to the intended endpoint and set other attributes as desired -->
            <script th:src=""@{/lesson_js/bypass.js}"" />
            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""verify-account-form""
                  method=""POST"" name=""form""
                  successCallback=""onBypassResponse""",FunctionPointerCall: open(),"AuthBypass.html 파일의 23 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",74DEE5421CC7E4BC873EBC9C15A1AF27,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge5.html","Challenge5.html",69,"        </div>
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: open(),"Challenge5.html 파일의 69 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E8B846BE88EA23B5B0EE7FB3F002C2EF,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",213,"            </i>
        </div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""confirm-flag-feedback""
              method=""POST"" name=""form2""
              action=""/WebGoat/csrf/feedback"">",FunctionPointerCall: open(),"CSRF.html 파일의 213 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C89,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",245,"        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });",FunctionPointerCall: get(),"jquery.form.js의 245 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",929C8B558F230608D9005501BE679096,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/spoofcookie/templates/spoofcookieform.html","spoofcookieform.html",3,"<div class=""row"">
	<div class=""col-md-4"">
		<form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST""
			action=""/WebGoat/SpoofCookie/login"">
			<div style=""padding: 20px;"" id=""password-login"">",FunctionPointerCall: get(),"spoofcookieform.html 파일의 3 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3408AEF62EAB4CD3FDDEFA217B5F1844,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/js/assignment13.js","assignment13.js",43,"
function getServers(column) {
    $.get(""SqlInjectionMitigations/servers?column="" + column, function (result, status) {
        $(""#servers"").empty();
        for (var i = 0; i < result.length; i++) {",FunctionPointerCall: get(),"assignment13.js의 43 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0701A528EAAE2A5BA30B7FD6266F9037,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScriptingStored.html","CrossSiteScriptingStored.html",68,"		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

		<form class=""attack-form"" accept-charset=""UNKNOWN""
			  method=""POST"" name=""DOMFollowUp""
			  action=""/WebGoat/CrossSiteScripting/stored-xss-follow-up"">",FunctionPointerCall: get(),"CrossSiteScriptingStored.html 파일의 68 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EE063DE011B0368203272E8568B07AB4,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/js/idor.js","idor.js",14,"    console.warn(""on view profile activated"")
    webgoat.customjs.jquery.ajax({
        method: ""GET"",
        url: ""/WebGoat/IDOR/profile"",
        contentType: 'application/json; charset=UTF-8'",AssignmentStatement(),"idor.js의 14 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",155AFEDD4076DF24A7A417B4F655C032,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/libs/jquery.form.js","jquery.form.js",245,"        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });",FunctionPointerCall: get(),"jquery.form.js의 245 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",929C8B558F230608D9005501BE679099,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/lessontemplate/js/idor.js","idor.js",14,"    console.warn(""on view profile activated"")
    webgoat.customjs.jquery.ajax({
        method: ""GET"",
        url: ""/WebGoat/IDOR/profile"",
        contentType: 'application/json; charset=UTF-8'",AssignmentStatement(),"idor.js의 14 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",155AFEDD4076DF24A7A417B4F655C033,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/ssrf/html/SSRF.html","SSRF.html",13,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/SSRF/task1"">",AssignmentStatement(),"SSRF.html 파일의 13 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",1A6B881205B407A5B00C4056916C4795,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webwolf/templates/registration.html","registration.html",15,"    <fieldset>
        <legend th:text=""#{register.title}"">Please Sign Up</legend>
        <form class=""form-horizontal"" action=""#"" th:action=""@{/register.mvc}"" th:object=""${userForm}""
              method='POST'>
",AssignmentStatement(),"registration.html 파일의 15 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8163F475A4C2DD0B7EBACD25DAA6D717,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",16,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack2""",AssignmentStatement(),"SqlInjection.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AD7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/deserialization/html/InsecureDeserialization.html","InsecureDeserialization.html",26,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
                  method=""POST""
                  action=""/WebGoat/InsecureDeserialization/task"">",AssignmentStatement(),"InsecureDeserialization.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",B5110FF449C669AE89E8F7C54648FA39,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",29,"
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 29 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",1C8BAA8A01F4D74F8BCFFED5EAD14FB3,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge8.html","Challenge8.html",234,"
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge8.html 파일의 234 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A2D9870E3A1E9581F592DACF90D88235,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/ssrf/js/credentials.js","credentials.js",3,"function submit_secret_credentials() {
    var xhttp = new XMLHttpRequest();
    xhttp['open']('POST', '#attack/307/100', true);
	//sending the request is obfuscated, to descourage js reading
	var _0xb7f9=[""\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B"",""\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C"",""\x73\x74\x72\x69\x6E\x67\x69\x66\x79"",""\x73\x65\x6E\x64""];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]]({username:_0xb7f9[0],password:_0xb7f9[1]}))",FunctionPointerCall: open(),"credentials.js의 3 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",AFC587ECB9060D79D73793E5BDA09B6B,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",308,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/JWT/final/delete?token=eyJ0eXAiOiJKV1QiLCJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.CgZ27DzgVW8gzc0n6izOU638uUCi6UhiOJKYzoEZGE8"">",FunctionPointerCall: open(),"JWT.html 파일의 308 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA8,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/ssrf/html/SSRF.html","SSRF.html",35,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/SSRF/task2"">",FunctionPointerCall: open(),"SSRF.html 파일의 35 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",1A6B881205B407A5B00C4056916C4794,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",17,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
              method=""POST""
              action=""/WebGoat/LogSpoofing/log-spoofing"">",FunctionPointerCall: open(),"LogSpoofing.html 파일의 17 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",964EA60A840D419BB41C3E8CB1728B0E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",35,"        </div>
        <br/>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""confirm-flag-1""
              method=""POST"" name=""form2""
              successCallback=""""",FunctionPointerCall: open(),"CSRF.html 파일의 35 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C81,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",13,"
webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 13 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4E2C7371CCCFC93F2BB6BBA28CCCF3DE,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/vulnerablecomponents/html/VulnerableComponents.html","VulnerableComponents.html",100,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				method=""POST"" name=""form""
				action=""/WebGoat/VulnerableComponents/attack1"">",FunctionPointerCall: get(),"VulnerableComponents.html 파일의 100 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A998AEA7FB5D225D1AB1029BD7793544,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge1.html","Challenge1.html",40,"        </div>

        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge1.html 파일의 40 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",42B1723944590BD3FA2F5788A020D580,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",65,"                                        </div>
                                    </form>
                                    <form id=""register-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""PUT"" name=""form""
                                          action=""/WebGoat/challenge/6"" style=""display: none;"" role=""form"">",FunctionPointerCall: get(),"Challenge6.html 파일의 65 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2C1A9F3ED0930D0BB75FC3067CF7FF94,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/webwolfintroduction/html/WebWolfIntroduction.html","WebWolfIntroduction.html",77,"        <br/>
        <br/>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/WebWolf/landing/"">",FunctionPointerCall: get(),"WebWolfIntroduction.html 파일의 77 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",10C2F89FE369D1686B3089C90D179EC9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",113,"                        <a class=""float-right btn btn-outline-primary"">Login</a>
                        <h4 class=""card-title mb-4 mt-1"">WebGoat Password Recovery</h4>
                        <form>
                            <div class=""form-group"">
                                <label>Your username</label>",FunctionPointerCall: get(),"PasswordReset.html 파일의 113 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167CA,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/htmltampering/html/HtmlTampering.html","HtmlTampering.html",14,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""task"" name=""task""
              method=""POST""
              action=""/WebGoat/HtmlTampering/task"">",FunctionPointerCall: get(),"HtmlTampering.html 파일의 14 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BF4A1EA0ED5D937DC6CEBF1A7550723C,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/vulnerablecomponents/html/VulnerableComponents.html","VulnerableComponents.html",104,"				action=""/WebGoat/VulnerableComponents/attack1"">
				<div id=""lessonContent"">
					<form accept-charset=""UNKNOWN"" method=""POST"" name=""form""
						action=""#attack/307/100"">
						<table>",FunctionPointerCall: get(),"VulnerableComponents.html 파일의 104 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A998AEA7FB5D225D1AB1029BD7793543,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/insecurelogin/js/credentials.js","credentials.js",3,"function submit_secret_credentials() {
    var xhttp = new XMLHttpRequest();
    xhttp['open']('POST', 'InsecureLogin/login', true);
	//sending the request is obfuscated, to descourage js reading
	var _0xb7f9=[""\x43\x61\x70\x74\x61\x69\x6E\x4A\x61\x63\x6B"",""\x42\x6C\x61\x63\x6B\x50\x65\x61\x72\x6C"",""\x73\x74\x72\x69\x6E\x67\x69\x66\x79"",""\x73\x65\x6E\x64""];xhttp[_0xb7f9[3]](JSON[_0xb7f9[2]]({username:_0xb7f9[0],password:_0xb7f9[1]}))",FunctionPointerCall: open(),"credentials.js의 3 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EECDCB57ABDA2D41DC802D2361085A05,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",154,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/JWT/secret"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: open(),"JWT.html 파일의 154 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACAC,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/quiz.js","quiz.js",15,"    var client = new XMLHttpRequest();
    var quiz_id = document.getElementById(""quiz_id"").getAttribute(""data-quiz_id"");
    client.open('GET', '/WebGoat/lesson_js/questions_' + quiz_id + '.json');
    client.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {",FunctionPointerCall: open(),"quiz.js의 15 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7B6725ADE521695E5E8C60F6853E339D,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/goatApp/goatApp.js","goatApp.js",21,"            initApp: function () {
                var locale = localStorage.getItem('locale') || 'en';
                $.getJSON('service/labels.mvc', function(data) {
                    window.polyglot = new Polyglot({phrases: data});//i18n polyglot labels
                    asyncErrorHandler.init();",FunctionPointerCall: getJSON(),"goatApp.js의 21 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7AF79A2E182123F0E8A1F1E7FF37294D,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",116,"                                        </div>
                                    </form>
                                    <form id=""register-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""PUT"" name=""form""
                                          action=""/WebGoat/SqlInjectionAdvanced/challenge""",FunctionPointerCall: getJSON(),"SqlInjectionAdvanced.html 파일의 116 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C10,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",113,"                        <a class=""float-right btn btn-outline-primary"">Login</a>
                        <h4 class=""card-title mb-4 mt-1"">WebGoat Password Recovery</h4>
                        <form>
                            <div class=""form-group"">
                                <label>Your username</label>",FunctionPointerCall: getJSON(),"PasswordReset.html 파일의 113 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D2,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge6.html","Challenge6.html",30,"                            <div class=""row"">
                                <div class=""col-lg-12"">
                                    <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""POST"" name=""form""
                                          action=""/WebGoat/challenge/6"" role=""form"">",FunctionPointerCall: getJSON(),"Challenge6.html 파일의 30 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2C1A9F3ED0930D0BB75FC3067CF7FF90,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",84,"
        <div class=""container-fluid"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/clientSideFiltering/getItForFree"">",FunctionPointerCall: getJSON(),"ClientSideFiltering.html 파일의 84 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F53EFD8415F9E3D7771A18D1B169FC86,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",58,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""GET"" name=""form""
              action=""/WebGoat/IDOR/profile"">",FunctionPointerCall: getJSON(),"IDOR.html 파일의 58 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04792,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/webwolfintroduction/html/WebWolfIntroduction.html","WebWolfIntroduction.html",40,"        <br/>
        <!-- <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>-->
        <form class=""attack-form"" accept-charset=""UNKNOWN""  style=""position:relative;top:-50px""
              method=""POST"" name=""secondform""
              action=""/WebGoat/WebWolf/mail/send"">",FunctionPointerCall: getJSON(),"WebWolfIntroduction.html 파일의 40 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",10C2F89FE369D1686B3089C90D179EC8,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/bypassrestrictions/html/BypassRestrictions.html","BypassRestrictions.html",19,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""container-fluid"">
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""fieldRestrictions""
                  method=""POST""
                  action=""/WebGoat/BypassRestrictions/FieldRestrictions"">",FunctionPointerCall: getJSON(),"BypassRestrictions.html 파일의 19 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A6651197000B5D91E5655D74A098740A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webwolf/templates/jwt.html","jwt.html",32,"            </form>
        </div>
        <form id=""encodeForm"">
            <div class=""form-group"">
                <label>Decoded</label>",FunctionPointerCall: getJSON(),"jwt.html 파일의 32 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E39485BF313EA203598C306841192A70,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",46,"function doVote(stars) {
    $(""#voteResultMsg"").hide();
    $.get(""challenge/8/vote/"" + stars, function (result) {
        if (result[""error""]) {
            $(""#voteResultMsg"").addClass('alert-danger alert-dismissable');",FunctionPointerCall: get(),"challenge8.js의 46 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A4A2CCE5E6AE9F369646A9A244143610,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webwolf/templates/jwt.html","jwt.html",32,"            </form>
        </div>
        <form id=""encodeForm"">
            <div class=""form-group"">
                <label>Decoded</label>",FunctionPointerCall: get(),"jwt.html 파일의 32 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E39485BF313EA203598C306841192A6E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",245,"        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });",FunctionPointerCall: get(),"jquery.form.js의 245 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",929C8B558F230608D9005501BE679098,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",34,"            </table>
        </form>        
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjectionAdvanced/attack6b"">",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 34 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C0E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 75 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A5BAAD0A64630B9FF0DD466DC0C62584,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",47,"	<div class=""attack-container"">
		<div id=""lessonContent"">
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				  method=""GET"" name=""xss-5a""
				  action=""/WebGoat/CrossSiteScripting/attack5a"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 47 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A4,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/templates/login.html","login.html",31,"            </div>
            <br/><br/>
            <form th:action=""@{/login}"" method='POST' style=""width: 200px;"">
                <div class=""form-group"">
                    <label for=""exampleInputEmail1"" th:text=""#{username}"">Username</label>",FunctionPointerCall: get(),"login.html 파일의 31 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",94FAB8D7062649FD7643BA144C209D76,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/templates/password_reset.html","password_reset.html",12,"    <div class=""row"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"">
            <form role=""form"" method=""POST"" action=""/WebGoat/PasswordReset/reset/change-password"" th:object=""${form}"" novalidate=""novalidate"">
                <h2 class=""sign_up_title"">Reset your password</h2>
                    <div class=""form-group"" th:classappend=""${#fields.hasErrors('password')}? 'has-error'"">",FunctionPointerCall: get(),"password_reset.html 파일의 12 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",D43855E84896397A44FACA8DCC70285C,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",13,"
webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 13 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4E2C7371CCCFC93F2BB6BBA28CCCF3DF,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",16,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack2""",FunctionPointerCall: get(),"SqlInjection.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE0,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/lessontemplate/html/LessonTemplate.html","LessonTemplate.html",48,"
            <!-- modify the action to point to the intended endpoint and set other attributes as desired -->
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/lesson-template/sample-attack"">",FunctionPointerCall: get(),"LessonTemplate.html 파일의 48 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",5398CF5729860E51D8F37DAF248E5964,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge1.html","Challenge1.html",40,"        </div>

        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge1.html 파일의 40 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",42B1723944590BD3FA2F5788A020D582,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/cryptography/html/Cryptography.html","Cryptography.html",90,"			Now suppose you have the following private key:<br/>
			<pre><div id=""privatekey"" ></div></pre><br/>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/signing/verify"">
			Then what was the modulus of the public key 
			<input name=""modulus"" value="""" type=""TEXT""/>",FunctionPointerCall: get(),"Cryptography.html 파일의 90 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178681,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",22,"            <!-- you can write your own custom forms, but standard form submission will take you to your endpoint and outside of the WebGoat framework -->
            <!-- of course, you can write your own ajax submission /handling in your own javascript if you like -->
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				method=""POST"" name=""form""
				action=""/WebGoat/HttpBasics/attack1"">",FunctionPointerCall: get(),"HttpBasics.html 파일의 22 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3A8B21C95D5FED43561E579326E65900,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/js/idor.js","idor.js",14,"    console.warn(""on view profile activated"")
    webgoat.customjs.jquery.ajax({
        method: ""GET"",
        url: ""/WebGoat/IDOR/profile"",
        contentType: 'application/json; charset=UTF-8'",AssignmentStatement(),"idor.js의 14 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",155AFEDD4076DF24A7A417B4F655C02F,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/lessontemplate/js/idor.js","idor.js",14,"    console.warn(""on view profile activated"")
    webgoat.customjs.jquery.ajax({
        method: ""GET"",
        url: ""/WebGoat/IDOR/profile"",
        contentType: 'application/json; charset=UTF-8'",AssignmentStatement(),"idor.js의 14 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",155AFEDD4076DF24A7A417B4F655C030,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xxe/js/xxe.js","xxe.js",72,"
function getComments(field) {
    $.get(""xxe/comments"", function (result, status) {
        $(field).empty();
        for (var i = 0; i < result.length; i++) {",FunctionPointerCall: get(),"xxe.js의 72 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7AC94BE1C2E42CE6539F660CA103980B,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/vulnerablecomponents/html/VulnerableComponents.html","VulnerableComponents.html",104,"				action=""/WebGoat/VulnerableComponents/attack1"">
				<div id=""lessonContent"">
					<form accept-charset=""UNKNOWN"" method=""POST"" name=""form""
						action=""#attack/307/100"">
						<table>",FunctionPointerCall: get(),"VulnerableComponents.html 파일의 104 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A998AEA7FB5D225D1AB1029BD7793545,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/quiz.js","quiz.js",15,"    var client = new XMLHttpRequest();
    var quiz_id = document.getElementById(""quiz_id"").getAttribute(""data-quiz_id"");
    client.open('GET', '/WebGoat/lesson_js/questions_' + quiz_id + '.json');
    client.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {",FunctionPointerCall: open(),"quiz.js의 15 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7B6725ADE521695E5E8C60F6853E339E,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java","WebSecurityConfig.java",58,"                .antMatchers(""/files"").authenticated()
                .anyRequest().permitAll();
        security.and().csrf().disable().formLogin()
                .loginPage(""/login"").failureUrl(""/login?error=true"");
        security.and()",FunctionCall: disable(),"WebSecurityConfig.java의 58 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java###58###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3D087BCE71A0E0487A2F4974EED95946,E1187028-6481-47EC-B923-5E91EB7178EB,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/missingac/html/MissingFunctionAC.html","MissingFunctionAC.html",77,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/access-control/user-hash"">",FunctionCall: disable(),"MissingFunctionAC.html 파일의 77 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAC1D7F15182A02E5CF2161174770D05,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",274,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack10""",FunctionCall: disable(),"SqlInjection.html 파일의 274 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE8,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xxe/html/XXE.html","XXE.html",25,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              prepareData=""simpleXXE""",FunctionCall: disable(),"XXE.html 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E17C19FEC3217C8FA0FC00684D6C2C60,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",52,"                <!-- you can write your own custom forms, but standard form submission will take you to your endpoint and outside of the WebGoat framework -->
                <!-- of course, you can write your own ajax submission /handling in your own javascript if you like -->
				<form class=""attack-form"" accept-charset=""UNKNOWN"" 
					method=""POST"" name=""form""
					action=""/WebGoat/HttpBasics/attack2"">",FunctionCall: disable(),"HttpBasics.html 파일의 52 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3A8B21C95D5FED43561E579326E658FF,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",223,"                                Forgot your password?
                            </h4>
                            <form class=""attack-form"" accept-charset=""UNKNOWN""
                                  method=""POST"" name=""form""
                                  action=""/WebGoat/PasswordReset/ForgotPassword/create-password-reset-link""",FunctionCall: disable(),"PasswordReset.html 파일의 223 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167CE,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/cia/html/CIA.html","CIA.html",30,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""container-fluid"">
            <form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""cia/quiz"" role=""form"">",FunctionCall: disable(),"CIA.html 파일의 30 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",D32783402F9F662FE26F85B23730C052,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",217,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack8""",FunctionCall: disable(),"SqlInjection.html 파일의 217 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94ADD,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/cryptography/html/Cryptography.html","Cryptography.html",113,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/secure/defaults"">
			What is the unencrypted message<br/>
			<input name=""secretText"" value="""" type=""TEXT""/><br/>",FunctionCall: disable(),"Cryptography.html 파일의 113 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178682,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge1.html","Challenge1.html",18,"                </div>
                <div class=""panel-body"">
                    <form class=""attack-form"" accept-charset=""UNKNOWN""
                          method=""POST"" name=""form""
                          action=""/WebGoat/challenge/1""",FunctionCall: disable(),"Challenge1.html 파일의 18 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",42B1723944590BD3FA2F5788A020D57F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/missingac/html/MissingFunctionAC.html","MissingFunctionAC.html",77,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/access-control/user-hash"">",FunctionCall: disable(),"MissingFunctionAC.html 파일의 77 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAC1D7F15182A02E5CF2161174770D08,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/libs/text.js","text.js",270,"        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers",FunctionPointerCall: open(),"text.js의 270 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EA13DAA9FFDD611B291FFEAD05AB6D24,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",80,"                            <div class=""row"">
                                <div class=""col-lg-12"">
                                    <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""POST"" name=""form""
                                          action=""/WebGoat/SqlInjectionAdvanced/challenge_Login""",FunctionPointerCall: open(),"SqlInjectionAdvanced.html 파일의 80 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C0F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xxe/html/XXE.html","XXE.html",25,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              prepareData=""simpleXXE""",FunctionPointerCall: open(),"XXE.html 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E17C19FEC3217C8FA0FC00684D6C2C5D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",35,"        </div>
        <br/>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""confirm-flag-1""
              method=""POST"" name=""form2""
              successCallback=""""",FunctionPointerCall: open(),"CSRF.html 파일의 35 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C86,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",245,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack9""",FunctionPointerCall: open(),"SqlInjection.html 파일의 245 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",169,"		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
		<div class=""container-fluid"">
			<form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
				  method=""POST"" name=""form""
				  action=""/WebGoat/CrossSiteScripting/quiz"" role=""form"">",FunctionPointerCall: open(),"CrossSiteScripting.html 파일의 169 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448AC,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xxe/html/XXE.html","XXE.html",164,"        <img th:src=""@{/images/wolf-enabled.png}"" class=""webwolf-enabled""/>
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              prepareData=""blindXXE""",FunctionPointerCall: open(),"XXE.html 파일의 164 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E17C19FEC3217C8FA0FC00684D6C2C62,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/ssrf/html/SSRF.html","SSRF.html",35,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/SSRF/task2"">",FunctionPointerCall: open(),"SSRF.html 파일의 35 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",1A6B881205B407A5B00C4056916C4796,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",48,"                        </div>
                    </form>
                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail"">",FunctionPointerCall: open(),"PasswordReset.html 파일의 48 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167C8,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",17,"
function ajaxFunction(userId) {
    $.get(""clientSideFiltering/salaries?userId="" + userId, function (result, status) {
        var html = ""<table border = '1' width = '90%' align = 'center'"";
        html = html + '<tr>';",FunctionPointerCall: get(),"clientSideFiltering.js의 17 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6AE026590F66DE6BCB75D754A72D34F,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",135,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""view-other""
              method=""GET"" name=""view-other-profile""
              action=""/WebGoat/IDOR/profile/{userId}"">",FunctionPointerCall: get(),"IDOR.html 파일의 135 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04795,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",26,"				action=""/WebGoat/HttpBasics/attack1"">
				<div id=""lessonContent"">
					<form accept-charset=""UNKNOWN"" method=""POST"" name=""form""
						action=""#attack/307/100"">
						Enter Your Name: <input name=""person"" value="""" type=""TEXT""/><input",FunctionPointerCall: get(),"HttpBasics.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3A8B21C95D5FED43561E579326E65901,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/missingac/html/MissingFunctionAC.html","MissingFunctionAC.html",54,"
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/access-control/hidden-menu"">",FunctionPointerCall: get(),"MissingFunctionAC.html 파일의 54 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAC1D7F15182A02E5CF2161174770D07,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",44,"	<div class=""adoc-content"" th:replace=""doc:lessons/xss/documentation/CrossSiteScripting_content8c.adoc""></div>
	<div class=""attack-container"" style=""height: 100%; border: none !important;min-height: 450px;"">
		<form id=""codesubmit2"" style=""height: 100%; min-height: 350px;"" class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/CrossSiteScripting/attack4"">
			<div>
				<div id=""editor2"" style=""position: absolute; top: 0; right: 0; bottom: 0; left: 0; height: 350px;"" name=""editor2""></div>",FunctionPointerCall: get(),"CrossSiteScriptingMitigation.html 파일의 44 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E6C77171CECEF2D0FFDF88B32948F92F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",245,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack9""",FunctionPointerCall: get(),"SqlInjection.html 파일의 245 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94ADE,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/authbypass/html/AuthBypass.html","AuthBypass.html",43,"            </form>

            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""change-password-form""
                  method=""POST"" name=""form""
                  successCallback=""onBypassResponse""",FunctionPointerCall: get(),"AuthBypass.html 파일의 43 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",74DEE5421CC7E4BC873EBC9C15A1AF28,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",144,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/PasswordReset/SecurityQuestions"">",FunctionPointerCall: get(),"PasswordReset.html 파일의 144 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167CB,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/js/jwt-voting.js","jwt-voting.js",43,"function getVotings() {
    $(""#votesList"").empty();
    $.get(""JWT/votings"", function (result, status) {
        for (var i = 0; i < result.length; i++) {
            var voteTemplate = html.replace('IMAGE_SMALL', result[i].imageSmall);",FunctionPointerCall: get(),"jwt-voting.js의 43 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8A8C421594BE93B011596EC0C47EE46E,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",146,"                    <div class=""col-md-8"">
                        <div class=""well well-sm"">
                            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""csrf-feedback""
                                  method=""POST""
                                  prepareData=""feedback""",FunctionPointerCall: get(),"CSRF.html 파일의 146 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C83,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge6.html","Challenge6.html",30,"                            <div class=""row"">
                                <div class=""col-lg-12"">
                                    <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""POST"" name=""form""
                                          action=""/WebGoat/challenge/6"" role=""form"">",FunctionPointerCall: get(),"Challenge6.html 파일의 30 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2C1A9F3ED0930D0BB75FC3067CF7FF93,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",73,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlOnlyInputValidation/attack""",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 73 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C27A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",46,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/ChromeDevTools/network"">",FunctionPointerCall: get(),"ChromeDevTools.html 파일의 46 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F72EADE1B421BCEC4CC3620163389B6B,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",308,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/JWT/final/delete?token=eyJ0eXAiOiJKV1QiLCJraWQiOiJ3ZWJnb2F0X2tleSIsImFsZyI6IkhTMjU2In0.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJqZXJyeUB3ZWJnb2F0LmNvbSIsInVzZXJuYW1lIjoiSmVycnkiLCJFbWFpbCI6ImplcnJ5QHdlYmdvYXQuY29tIiwiUm9sZSI6WyJDYXQiXX0.CgZ27DzgVW8gzc0n6izOU638uUCi6UhiOJKYzoEZGE8"">",FunctionPointerCall: get(),"JWT.html 파일의 308 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACAE,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/templates/registration.html","registration.html",26,"            <fieldset>
                <legend th:text=""#{register.title}"">Please Sign Up</legend>
                <form class=""form-horizontal"" action=""#"" th:action=""@{/register.mvc}"" th:object=""${userForm}""
                      method='POST'>
",FunctionPointerCall: get(),"registration.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8163F475A4C2DD0B7EBACD25DAA6D716,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/bypassrestrictions/html/BypassRestrictions.html","BypassRestrictions.html",66,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

        <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""frontendValidation""
              id=""frontendValidation""
              method=""POST""",FunctionPointerCall: get(),"BypassRestrictions.html 파일의 66 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A6651197000B5D91E5655D74A098740B,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",59,"
function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 59 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EEE06D34A5BE7F2EB9D6F335FB4E3931,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",217,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack8""",FunctionPointerCall: get(),"SqlInjection.html 파일의 217 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE6,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",93,"                    <div class=""post-footer"">
                        <div class=""input-group"">
                            <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""csrf-review""
                                  method=""POST"" name=""review-form""
                                  successCallback=""""",FunctionPointerCall: get(),"CSRF.html 파일의 93 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C87,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",96,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlOnlyInputValidationOnKeywords/attack""",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 96 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C27B,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/httpbasics/html/HttpBasics.html","HttpBasics.html",52,"                <!-- you can write your own custom forms, but standard form submission will take you to your endpoint and outside of the WebGoat framework -->
                <!-- of course, you can write your own ajax submission /handling in your own javascript if you like -->
				<form class=""attack-form"" accept-charset=""UNKNOWN"" 
					method=""POST"" name=""form""
					action=""/WebGoat/HttpBasics/attack2"">",FunctionPointerCall: get(),"HttpBasics.html 파일의 52 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3A8B21C95D5FED43561E579326E65902,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",125,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 125 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD552,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/hijacksession/templates/hijackform.html","hijackform.html",3,"<div class=""row"">
	<div class=""col-md-4"">
		<form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST""
			action=""/WebGoat/HijackSession/login"">
			<div style=""padding: 20px;"" id=""password-login"">",FunctionPointerCall: get(),"hijackform.html 파일의 3 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",C19DBFA4B6DA13AD59D27DC557E8C4D7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",39,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
              method=""POST""
              action=""/WebGoat/LogSpoofing/log-bleeding"">",FunctionPointerCall: get(),"LogSpoofing.html 파일의 39 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",964EA60A840D419BB41C3E8CB1728B0F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/libs/ace.js","ace.js",4157,"exports.get = function (url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {",FunctionPointerCall: open(),"ace.js의 4157 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",45BD9D7C7783F2A580D7752F1919D11B,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",21,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjectionAdvanced/attack6a"">",FunctionPointerCall: open(),"SqlInjectionAdvanced.html 파일의 21 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C0D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",104,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/PasswordReset/questions"">",FunctionPointerCall: open(),"PasswordReset.html 파일의 104 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D1,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xxe/html/XXE.html","XXE.html",92,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              prepareData=""contentTypeXXE""",FunctionPointerCall: open(),"XXE.html 파일의 92 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E17C19FEC3217C8FA0FC00684D6C2C61,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/js/challenge8.js","challenge8.js",46,"function doVote(stars) {
    $(""#voteResultMsg"").hide();
    $.get(""challenge/8/vote/"" + stars, function (result) {
        if (result[""error""]) {
            $(""#voteResultMsg"").addClass('alert-danger alert-dismissable');",FunctionPointerCall: get(),"challenge8.js의 46 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A4A2CCE5E6AE9F369646A9A244143611,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",58,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""GET"" name=""form""
              action=""/WebGoat/IDOR/profile"">",FunctionPointerCall: get(),"IDOR.html 파일의 58 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04798,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/csrf/html/CSRF.html","CSRF.html",237,"            </i>
        </div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""confirm-flag-login""
              method=""POST"" name=""form2""
              action=""/WebGoat/csrf/login"">",FunctionPointerCall: get(),"CSRF.html 파일의 237 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C85,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/libs/jquery.form.js","jquery.form.js",245,"        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });",FunctionPointerCall: get(),"jquery.form.js의 245 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",929C8B558F230608D9005501BE679097,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge7.html","Challenge7.html",60,"        </div>
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge7.html 파일의 60 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",46B089B2B7403A7D982E92B74F67655F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/goatApp/view/GoatRouter.js","GoatRouter.js",68,"                console.log('phoneHome invoked');
                webgoat.customjs.jquery.ajax({
                    method: ""POST"",
                    url: ""/WebGoat/CrossSiteScripting/phone-home-xss"",
                    data: {param1: 42, param2: 24},",AssignmentStatement(),"GoatRouter.js의 68 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EBC1959590F4A6A88D5C1241A1D76B53,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 75 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A5BAAD0A64630B9FF0DD466DC0C62583,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",192,"
            <br/>
            <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/PathTraversal/random"">
                <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
                <div class=""form-group"">",FunctionPointerCall: get(),"PathTraversal.html 파일의 192 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD553,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",149,"	<div class=""attack-container"">
		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
		<form class=""attack-form"" accept-charset=""UNKNOWN""
			  method=""POST"" name=""DOMFollowUp""
			  action=""/WebGoat/CrossSiteScripting/dom-follow-up"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 149 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A6,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",67,"        </form>

        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/ChromeDevTools/network"">",FunctionPointerCall: get(),"ChromeDevTools.html 파일의 67 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F72EADE1B421BCEC4CC3620163389B6C,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",25,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""DOMFollowUp""
              action=""/WebGoat/ChromeDevTools/dummy"">",FunctionPointerCall: get(),"ChromeDevTools.html 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F72EADE1B421BCEC4CC3620163389B6A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",104,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/PasswordReset/questions"">",FunctionPointerCall: get(),"PasswordReset.html 파일의 104 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167C9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",88,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack5""",FunctionPointerCall: get(),"SqlInjection.html 파일의 88 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE3,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",26,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/SqlInjectionMitigations/attack10a"">
            <div>
                <p>Connection conn = DriverManager.<input type=""text"" name=""field1"" id=""field1"" />(DBURL, DBUSER, DBPW);</p>",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C278,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScriptingMitigation.html","CrossSiteScriptingMitigation.html",44,"	<div class=""adoc-content"" th:replace=""doc:lessons/xss/documentation/CrossSiteScripting_content8c.adoc""></div>
	<div class=""attack-container"" style=""height: 100%; border: none !important;min-height: 450px;"">
		<form id=""codesubmit2"" style=""height: 100%; min-height: 350px;"" class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/CrossSiteScripting/attack4"">
			<div>
				<div id=""editor2"" style=""position: absolute; top: 0; right: 0; bottom: 0; left: 0; height: 350px;"" name=""editor2""></div>",FunctionPointerCall: get(),"CrossSiteScriptingMitigation.html 파일의 44 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E6C77171CECEF2D0FFDF88B32948F931,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",40,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack3""",FunctionPointerCall: get(),"SqlInjection.html 파일의 40 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AE1,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",46,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/ChromeDevTools/network"">",FunctionPointerCall: get(),"ChromeDevTools.html 파일의 46 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F72EADE1B421BCEC4CC3620163389B68,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/bypassrestrictions/html/BypassRestrictions.html","BypassRestrictions.html",19,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""container-fluid"">
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""fieldRestrictions""
                  method=""POST""
                  action=""/WebGoat/BypassRestrictions/FieldRestrictions"">",FunctionPointerCall: get(),"BypassRestrictions.html 파일의 19 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A6651197000B5D91E5655D74A0987408,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",274,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack10""",FunctionPointerCall: get(),"SqlInjection.html 파일의 274 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94ADF,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",16,"    <div class=""attack-container"">
        <img th:src=""@{/images/wolf-enabled.png}"" class=""webwolf-enabled""/>
        <form id=""decode"" class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/JWT/decode"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <br>",FunctionPointerCall: get(),"JWT.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge7.html","Challenge7.html",60,"        </div>
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge7.html 파일의 60 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",46B089B2B7403A7D982E92B74F67655E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/jwt/html/JWT.html","JWT.html",49,"        <div class=""attack-output""></div>
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              successCallback=""jwtSigningCallback""",FunctionPointerCall: get(),"JWT.html 파일의 49 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACA4,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",16,"        <input type=""hidden"" id=""user_id"" value=""102""/>
        <!-- using attack-form class on your form, will allow your request to be ajaxified and stay within the display framework for webgoat -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form""
              action=""/WebGoat/clientSideFiltering/attack1"">
            <link rel=""stylesheet"" type=""text/css""",FunctionPointerCall: get(),"ClientSideFiltering.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F53EFD8415F9E3D7771A18D1B169FC85,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/spoofcookie/templates/spoofcookieform.html","spoofcookieform.html",3,"<div class=""row"">
	<div class=""col-md-4"">
		<form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST""
			action=""/WebGoat/SpoofCookie/login"">
			<div style=""padding: 20px;"" id=""password-login"">",FunctionPointerCall: get(),"spoofcookieform.html 파일의 3 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",3408AEF62EAB4CD3FDDEFA217B5F1843,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",16,"        <input type=""hidden"" id=""user_id"" value=""102""/>
        <!-- using attack-form class on your form, will allow your request to be ajaxified and stay within the display framework for webgoat -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form""
              action=""/WebGoat/clientSideFiltering/attack1"">
            <link rel=""stylesheet"" type=""text/css""",FunctionPointerCall: get(),"ClientSideFiltering.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F53EFD8415F9E3D7771A18D1B169FC87,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/goatApp/support/GoatUtils.js","GoatUtils.js",56," 
                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $(""#lesson_cookies"").html(reply);
                    }, ""html"");",FunctionPointerCall: get(),"GoatUtils.js의 56 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",50A06639EB7772D5A255C110E0820C1C,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/clientsidefiltering/html/ClientSideFiltering.html","ClientSideFiltering.html",84,"
        <div class=""container-fluid"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/clientSideFiltering/getItForFree"">",FunctionPointerCall: get(),"ClientSideFiltering.html 파일의 84 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F53EFD8415F9E3D7771A18D1B169FC88,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",16,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD550,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",34,"            </table>
        </form>        
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjectionAdvanced/attack6b"">",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 34 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C13,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webgoat/static/js/libs/text.js","text.js",270,"        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers",FunctionPointerCall: open(),"text.js의 270 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EA13DAA9FFDD611B291FFEAD05AB6D25,30DFC293-D2B8-463A-9952-257A44B5339C,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js","clientSideFilteringFree.js",41,"    $("".checkoutCode"").on(""blur"", function () {
        var checkoutCode = $("".checkoutCode"").val();
        $.get(""clientSideFiltering/challenge-store/coupons/"" + checkoutCode, function (result, status) {
            var discount = result.discount;
            if (discount > 0) {",FunctionPointerCall: get(),"clientSideFilteringFree.js의 41 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2959B630BFAD261E9318DD43EDDC1738,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xss/js/stored-xss.js","stored-xss.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('CrossSiteScripting/stored-xss', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",FunctionPointerCall: get(),"stored-xss.js의 35 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",9024A8FFC6D92B54297613DA30379369,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/missingac/html/MissingFunctionAC.html","MissingFunctionAC.html",54,"
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/access-control/hidden-menu"">",FunctionPointerCall: get(),"MissingFunctionAC.html 파일의 54 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAC1D7F15182A02E5CF2161174770D04,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",26,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST"" name=""form"" action=""/WebGoat/SqlInjectionMitigations/attack10a"">
            <div>
                <p>Connection conn = DriverManager.<input type=""text"" name=""field1"" id=""field1"" />(DBURL, DBUSER, DBPW);</p>",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C27E,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/csrf/html/CSRF.html","CSRF.html",237,"            </i>
        </div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""confirm-flag-login""
              method=""POST"" name=""form2""
              action=""/WebGoat/csrf/login"">",FunctionPointerCall: get(),"CSRF.html 파일의 237 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7641B348B68E7CA5CFD340E9B5B16C8A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webwolf/templates/jwt.html","jwt.html",26,"        <div class=""form-group"">
            <label for=""token"">Encoded</label>
            <form id=""decodeForm"">
            <textarea class=""form-control"" style=""font-size: 14pt; font-family:monospace;"" id=""token"" name=""token""
                      rows=""4""",FunctionPointerCall: get(),"jwt.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E39485BF313EA203598C306841192A6F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",47,"	<div class=""attack-container"">
		<div id=""lessonContent"">
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				  method=""GET"" name=""xss-5a""
				  action=""/WebGoat/CrossSiteScripting/attack5a"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 47 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",223,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 223 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD54F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",88,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack5""",FunctionPointerCall: get(),"SqlInjection.html 파일의 88 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94ADA,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionAdvanced.html","SqlInjectionAdvanced.html",169,"            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <div class=""container-fluid"">
                <form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                      method=""POST"" name=""form""
                      action=""/WebGoat/SqlInjectionAdvanced/quiz""",FunctionPointerCall: get(),"SqlInjectionAdvanced.html 파일의 169 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",71A245219D632AF1407C448620451C16,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",53,"
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });",FunctionPointerCall: get(),"path_traversal.js의 53 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",525FB32CE4551ACE423E582CDE3E7168,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",108,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/IDOR/profile/alt-path"">",FunctionPointerCall: get(),"IDOR.html 파일의 108 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E0479A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/webwolfintroduction/html/WebWolfIntroduction.html","WebWolfIntroduction.html",19,"        
        
        <form class=""attack-form"" accept-charset=""UNKNOWN""  style=""position:relative;top:150px""
              method=""POST"" name=""form""
              action=""/WebGoat/WebWolf/mail/"">",FunctionPointerCall: get(),"WebWolfIntroduction.html 파일의 19 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",10C2F89FE369D1686B3089C90D179EC7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/cryptography/html/Cryptography.html","Cryptography.html",65,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/hashing"">
			Which password belongs to this hash: <div id=""md5token"" ></div>
			<input name=""answer_pwd1"" value="""" type=""TEXT""/><br/>",FunctionPointerCall: get(),"Cryptography.html 파일의 65 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178685,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/idor/html/IDOR.html","IDOR.html",159,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN"" id=""edit-other""
              method=""GET"" name=""edit-other-profile""
              action=""/WebGoat/IDOR/profile/{userId}"">",FunctionPointerCall: get(),"IDOR.html 파일의 159 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E0479C,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/csrf/js/csrf-review.js","csrf-review.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('csrf/review', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",FunctionPointerCall: get(),"csrf-review.js의 35 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8D43711D3B053D3BF99623CA6B92BF57,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/hijacksession/templates/hijackform.html","hijackform.html",3,"<div class=""row"">
	<div class=""col-md-4"">
		<form class=""attack-form"" accept-charset=""UNKNOWN"" method=""POST""
			action=""/WebGoat/HijackSession/login"">
			<div style=""padding: 20px;"" id=""password-login"">",FunctionPointerCall: get(),"hijackform.html 파일의 3 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",C19DBFA4B6DA13AD59D27DC557E8C4D6,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/webwolfintroduction/html/WebWolfIntroduction.html","WebWolfIntroduction.html",77,"        <br/>
        <br/>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/WebWolf/landing/"">",FunctionPointerCall: get(),"WebWolfIntroduction.html 파일의 77 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",10C2F89FE369D1686B3089C90D179ECC,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",176,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>

        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              action=""/WebGoat/PasswordReset/reset/login"">",FunctionPointerCall: get(),"PasswordReset.html 파일의 176 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167CC,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",24,"                    

                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail/reset"">",FunctionPointerCall: get(),"PasswordReset.html 파일의 24 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167C7,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge1.html","Challenge1.html",18,"                </div>
                <div class=""panel-body"">
                    <form class=""attack-form"" accept-charset=""UNKNOWN""
                          method=""POST"" name=""form""
                          action=""/WebGoat/challenge/1""",FunctionPointerCall: get(),"Challenge1.html 파일의 18 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",42B1723944590BD3FA2F5788A020D581,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/chromedevtools/html/ChromeDevTools.html","ChromeDevTools.html",67,"        </form>

        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/ChromeDevTools/network"">",FunctionPointerCall: get(),"ChromeDevTools.html 파일의 67 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F72EADE1B421BCEC4CC3620163389B69,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/challenges/html/Challenge5.html","Challenge5.html",69,"        </div>
        <br/>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/challenge/flag"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"Challenge5.html 파일의 69 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E8B846BE88EA23B5B0EE7FB3F002C2ED,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",48,"                        </div>
                    </form>
                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail"">",FunctionPointerCall: get(),"PasswordReset.html 파일의 48 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167D0,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",149,"	<div class=""attack-container"">
		<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
		<form class=""attack-form"" accept-charset=""UNKNOWN""
			  method=""POST"" name=""DOMFollowUp""
			  action=""/WebGoat/CrossSiteScripting/dom-follow-up"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 149 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448AB,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/templates/login.html","login.html",31,"            </div>
            <br/><br/>
            <form th:action=""@{/login}"" method='POST' style=""width: 200px;"">
                <div class=""form-group"">
                    <label for=""exampleInputEmail1"" th:text=""#{username}"">Username</label>",FunctionPointerCall: get(),"login.html 파일의 31 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",94FAB8D7062649FD7643BA144C209D75,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webwolf/templates/registration.html","registration.html",15,"    <fieldset>
        <legend th:text=""#{register.title}"">Please Sign Up</legend>
        <form class=""form-horizontal"" action=""#"" th:action=""@{/register.mvc}"" th:object=""${userForm}""
              method='POST'>
",FunctionPointerCall: get(),"registration.html 파일의 15 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8163F475A4C2DD0B7EBACD25DAA6D715,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/clientsidefiltering/js/clientSideFilteringFree.js","clientSideFilteringFree.js",41,"    $("".checkoutCode"").on(""blur"", function () {
        var checkoutCode = $("".checkoutCode"").val();
        $.get(""clientSideFiltering/challenge-store/coupons/"" + checkoutCode, function (result, status) {
            var discount = result.discount;
            if (discount > 0) {",FunctionPointerCall: get(),"clientSideFilteringFree.js의 41 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2959B630BFAD261E9318DD43EDDC1739,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webwolf/templates/files.html","files.html",37,"
            <!-- Standard Form -->
            <form th:action=""@{/fileupload}"" method=""post"" enctype=""multipart/form-data"">
                <div class=""form-inline"">
                    <div class=""form-group"">",FunctionPointerCall: get(),"files.html 파일의 37 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",2369EB268BC6AFC62E47098371AD7138,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjection.html","SqlInjection.html",40,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/SqlInjection/attack3""",FunctionPointerCall: get(),"SqlInjection.html 파일의 40 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",7182225EE34955749D3E94E65BB94AD8,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/challenges/html/Challenge5.html","Challenge5.html",26,"                            <div class=""row"">
                                <div class=""col-lg-12"">
                                    <form id=""login-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                                          method=""POST"" name=""form""
                                          action=""/WebGoat/challenge/5"" role=""form"">",FunctionPointerCall: get(),"Challenge5.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E8B846BE88EA23B5B0EE7FB3F002C2EE,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/insecurelogin/html/InsecureLogin.html","InsecureLogin.html",26,"            </form>
            <br></br>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
                  method=""POST""
                  action=""/WebGoat/InsecureLogin/task"">",FunctionPointerCall: get(),"InsecureLogin.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4D7BBDF1176A27BDC81D85444FDAD60A,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/httpproxies/html/HttpProxies.html","HttpProxies.html",25,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""intercept-request""
                  method=""POST""
                  action=""/WebGoat/HttpProxies/intercept-request"">",FunctionPointerCall: get(),"HttpProxies.html 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",56A9484F62E8C34353C055FCB0BB44C5,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/cryptography/html/Cryptography.html","Cryptography.html",90,"			Now suppose you have the following private key:<br/>
			<pre><div id=""privatekey"" ></div></pre><br/>
			<form class=""attack-form"" method=""POST"" name=""form""	action=""/WebGoat/crypto/signing/verify"">
			Then what was the modulus of the public key 
			<input name=""modulus"" value="""" type=""TEXT""/>",FunctionPointerCall: get(),"Cryptography.html 파일의 90 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",4B308E8EA50E80EE2E4BD6B6CA178686,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/jwt/html/JWT.html","JWT.html",49,"        <div class=""attack-output""></div>
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST""
              successCallback=""jwtSigningCallback""",FunctionPointerCall: get(),"JWT.html 파일의 49 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A7C0D6C22D0B935C7ECC081960D9ACAA,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/passwordreset/html/PasswordReset.html","PasswordReset.html",24,"                    

                    <form class=""attack-form"" accept-charset=""UNKNOWN"" novalidate=""novalidate""
                          method=""POST""
                          action=""/WebGoat/PasswordReset/simple-mail/reset"">",FunctionPointerCall: get(),"PasswordReset.html 파일의 24 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F6D04A56B7E2A79DDEA6A5CF9CE167CF,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/xxe/html/XXE.html","XXE.html",164,"        <img th:src=""@{/images/wolf-enabled.png}"" class=""webwolf-enabled""/>
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              prepareData=""blindXXE""",FunctionPointerCall: get(),"XXE.html 파일의 164 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E17C19FEC3217C8FA0FC00684D6C2C5F,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",176,"            </div>
        </form>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/SqlInjectionMitigations/attack12a"">
            <div class=""form-group"">
                <div class=""input-group"">",FunctionPointerCall: get(),"SqlInjectionMitigations.html 파일의 176 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C27D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",16,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""upload-container"">
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  onsubmit='return false'",FunctionPointerCall: get(),"PathTraversal.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0F12814C1590A489BC6FF9DBB3FDD54B,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webgoat/static/js/goatApp/view/GoatRouter.js","GoatRouter.js",68,"                console.log('phoneHome invoked');
                webgoat.customjs.jquery.ajax({
                    method: ""POST"",
                    url: ""/WebGoat/CrossSiteScripting/phone-home-xss"",
                    data: {param1: 42, param2: 24},",AssignmentStatement(),"GoatRouter.js의 68 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",EBC1959590F4A6A88D5C1241A1D76B52,2335EF74-F5C5-4BE1-89B6-707D1B78D6B3,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/sqlinjection/html/SqlInjectionMitigations.html","SqlInjectionMitigations.html",176,"            </div>
        </form>
        <form class=""attack-form"" method=""POST"" name=""form"" action=""/WebGoat/SqlInjectionMitigations/attack12a"">
            <div class=""form-group"">
                <div class=""input-group"">",AssignmentStatement(),"SqlInjectionMitigations.html 파일의 176 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",FA5F947D4E08FC046807DADB7FB1C283,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/logging/html/LogSpoofing.html","LogSpoofing.html",39,"    <div class=""attack-container"">
        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <form class=""attack-form"" accept-charset=""UNKNOWN"" name=""task""
              method=""POST""
              action=""/WebGoat/LogSpoofing/log-bleeding"">",AssignmentStatement(),"LogSpoofing.html 파일의 39 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",964EA60A840D419BB41C3E8CB1728B11,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/webwolf/templates/webwolf-login.html","webwolf-login.html",17,"    <div class=""row"" style=""margin-top:20px"">
        <div class=""col-xs-12 col-sm-8 col-md-6 col-sm-offset-2 col-md-offset-3"" th:style=""'background:url(' + @{/images/wolf.png} + ') no-repeat right;'"">
            <form th:action=""@{/login}"" method=""post"">
                <fieldset>
                    <h2>Sign in</h2>",AssignmentStatement(),"webwolf-login.html 파일의 17 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",474384F066BFF762CC18ED271982CF68,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/webwolf/templates/jwt.html","jwt.html",26,"        <div class=""form-group"">
            <label for=""token"">Encoded</label>
            <form id=""decodeForm"">
            <textarea class=""form-control"" style=""font-size: 14pt; font-family:monospace;"" id=""token"" name=""token""
                      rows=""4""",AssignmentStatement(),"jwt.html 파일의 26 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",E39485BF313EA203598C306841192A6D,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/cia/html/CIA.html","CIA.html",30,"        <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
        <div class=""container-fluid"">
            <form id=""quiz-form"" class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""cia/quiz"" role=""form"">",AssignmentStatement(),"CIA.html 파일의 30 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",D32783402F9F662FE26F85B23730C053,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/idor/html/IDOR.html","IDOR.html",108,"
        <!-- modify the action to point to the intended endpoint -->
        <form class=""attack-form"" accept-charset=""UNKNOWN""
              method=""POST"" name=""form""
              action=""/WebGoat/IDOR/profile/alt-path"">",AssignmentStatement(),"IDOR.html 파일의 108 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",8501591645790EF262E3E71872E04794,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/vulnerablecomponents/html/VulnerableComponents.html","VulnerableComponents.html",100,"		<div class=""attack-container"">
			<div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				method=""POST"" name=""form""
				action=""/WebGoat/VulnerableComponents/attack1"">",AssignmentStatement(),"VulnerableComponents.html 파일의 100 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",A998AEA7FB5D225D1AB1029BD7793542,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/sqlinjection/js/assignment13.js","assignment13.js",43,"
function getServers(column) {
    $.get(""SqlInjectionMitigations/servers?column="" + column, function (result, status) {
        $(""#servers"").empty();
        for (var i = 0; i < result.length; i++) {",FunctionPointerCall: get(),"assignment13.js의 43 줄에 있는 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",0701A528EAAE2A5BA30B7FD6266F9036,114E5A67-3446-4DD5-B578-D0E6FDBB304E,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/resources/lessons/ssrf/html/SSRF.html","SSRF.html",13,"        <div class=""attack-container"">
            <div class=""assignment-success""><i class=""fa fa-2 fa-check hidden"" aria-hidden=""true""></i></div>
            <form class=""attack-form"" accept-charset=""UNKNOWN""
                  method=""POST"" name=""form""
                  action=""/WebGoat/SSRF/task1"">",FunctionPointerCall: get(),"SSRF.html 파일의 13 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",1A6B881205B407A5B00C4056916C4793,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"target/classes/lessons/xss/html/CrossSiteScripting.html","CrossSiteScripting.html",13,"	<div class=""attack-container"">
		<div id=""lessonContent"">
			<form class=""attack-form"" accept-charset=""UNKNOWN""
				  method=""POST"" name=""form""
				  action=""/WebGoat/CrossSiteScripting/attack1"">",FunctionPointerCall: get(),"CrossSiteScripting.html 파일의 13 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","WebSecurityConfig.java의 74 줄에서 <a href=""location://src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java###74###31###0"">disable()</a>에 의해 생성된 HTTP 요청에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같이 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  rb.sendRequest(body, new NewAccountCallback(callback));


공격자는 다음과 같은 코드를 포함하는 악성 웹 사이트를 설정할 수도 있습니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""http://www.example.com/new_user"");
  body = addToPost(body, ""attacker"";
  body = addToPost(body, ""haha"");
  rb.sendRequest(body, new NewAccountCallback(callback));


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.","1. Fortify Static Code Analyzer는 POST 작업을 수행할 가능성이 있는 모든 HTML 폼 및 모든 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 폼이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",BAE8B707D999FBBB7466A8F3FC4448A8,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.08. 부적절한 XML 외부개체 참조","src/main/java/org/owasp/webgoat/lessons/xxe/ContentTypeAssignment.java","ContentTypeAssignment.java",60,"    @PostMapping(path = ""xxe/content-type"")
    @ResponseBody
    public AttackResult createNewUser(HttpServletRequest request, @RequestBody String commentStr, @RequestHeader(""Content-Type"") String contentType) throws Exception {
        AttackResult attackResult = failed(this).build();
",createNewUser(1),"src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",102,"        }

        var xsr = xif.createXMLStreamReader(new StringReader(xml));

        var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:102에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","CommentsCache.java:102에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","XML 외부 엔터티 공격에서는 XML 기능을 활용하여 처리 시점에 동적으로 문서를 구성합니다. XML 엔터티를 사용하면 지정된 리소스에서 동적으로 데이터를 포함시킬 수 있습니다. 외부 엔터티를 사용하면 XML 문서에 외부 URI의 데이터를 포함할 수 있습니다. 다른 방식으로 처리하도록 구성하지 않은 경우 외부 엔터티는 XML 파서가 URI로 지정된 리소스(예: 로컬 컴퓨터 또는 원격 시스템의 파일)를 접근하게 만듭니다. 이 동작으로 인해 응용 프로그램이 XML 외부 엔터티(XXE) 공격에 노출되고, 이를 통해 로컬 시스템에서 denial of service를 발생시키고, 로컬 컴퓨터의 파일에 무단으로 접근하고, 원격 컴퓨터를 스캔하고, 원격 시스템에서 denial of service를 발생시킬 수 있습니다.

다음 XML 문서에서는 XXE 공격의 예를 보여 줍니다.

<?xml version=""1.0"" encoding=""ISO-8859-1""?>
 <!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM ""file:///dev/random"" >]><foo>&xxe;</foo>


이 예제에서 XML 파서가 엔터티를 /dev/random 파일의 컨텐츠로 대체하려고 시도하는 경우 서버가 중단될 수 있습니다(UNIX 시스템의 경우).","XML unmarshaller가 수신 XML 문서의 일부로 외부 엔터티를 허용하지 않도록 안전하게 구성되어야 합니다.

XXE injection을 방지하려면 XML 소스를 java.io.File, java.io.Reader 또는 java.io.InputStream으로 직접 처리하는 unmarshal 메서드를 사용하지 마십시오. 안전하게 구성된 파서로 문서를 구문 분석하고 다음 예에 표시된 것처럼 보안 파서를 XML 소스를 사용하는 unmarshal 메서드를 사용합니다.


DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(<XML Source>);
Model model = (Model) u.unmarshal(document);


StAX 파서의 경우 다음 구성이 권장됩니다.
- 외부 엔터티 확인 비활성화:

xmlInputFactory.setProperty(""javax.xml.stream.isSupportingExternalEntities"", false);


- 인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

xmlInputFactory.setProperty(""javax.xml.stream.supportDTD"", false);


- 외부 또는 로컬 엔터티 확인이 필요한 경우 안전한 리졸버(resolver)를 구축하고 XML 문서를 구문 분석하기 전에 설정합니다.

xmlInputFactory.setXMLResolver(mySafeResolver);
",,AB2722794A392B87A6C7F7F1388CAD50,D92D11B4-E03C-4B93-9DAA-402C19BE7EFC,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.08. 부적절한 XML 외부개체 참조","src/main/java/org/owasp/webgoat/lessons/xxe/SimpleXXE.java","SimpleXXE.java",68,"    @PostMapping(path = ""xxe/simple"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult createNewComment(HttpServletRequest request, @RequestBody String commentStr) {
        String error = """";
        try {",createNewComment(1),"src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",102,"        }

        var xsr = xif.createXMLStreamReader(new StringReader(xml));

        var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:102에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","CommentsCache.java:102에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","XML 외부 엔터티 공격에서는 XML 기능을 활용하여 처리 시점에 동적으로 문서를 구성합니다. XML 엔터티를 사용하면 지정된 리소스에서 동적으로 데이터를 포함시킬 수 있습니다. 외부 엔터티를 사용하면 XML 문서에 외부 URI의 데이터를 포함할 수 있습니다. 다른 방식으로 처리하도록 구성하지 않은 경우 외부 엔터티는 XML 파서가 URI로 지정된 리소스(예: 로컬 컴퓨터 또는 원격 시스템의 파일)를 접근하게 만듭니다. 이 동작으로 인해 응용 프로그램이 XML 외부 엔터티(XXE) 공격에 노출되고, 이를 통해 로컬 시스템에서 denial of service를 발생시키고, 로컬 컴퓨터의 파일에 무단으로 접근하고, 원격 컴퓨터를 스캔하고, 원격 시스템에서 denial of service를 발생시킬 수 있습니다.

다음 XML 문서에서는 XXE 공격의 예를 보여 줍니다.

<?xml version=""1.0"" encoding=""ISO-8859-1""?>
 <!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM ""file:///dev/random"" >]><foo>&xxe;</foo>


이 예제에서 XML 파서가 엔터티를 /dev/random 파일의 컨텐츠로 대체하려고 시도하는 경우 서버가 중단될 수 있습니다(UNIX 시스템의 경우).","XML unmarshaller가 수신 XML 문서의 일부로 외부 엔터티를 허용하지 않도록 안전하게 구성되어야 합니다.

XXE injection을 방지하려면 XML 소스를 java.io.File, java.io.Reader 또는 java.io.InputStream으로 직접 처리하는 unmarshal 메서드를 사용하지 마십시오. 안전하게 구성된 파서로 문서를 구문 분석하고 다음 예에 표시된 것처럼 보안 파서를 XML 소스를 사용하는 unmarshal 메서드를 사용합니다.


DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(<XML Source>);
Model model = (Model) u.unmarshal(document);


StAX 파서의 경우 다음 구성이 권장됩니다.
- 외부 엔터티 확인 비활성화:

xmlInputFactory.setProperty(""javax.xml.stream.isSupportingExternalEntities"", false);


- 인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

xmlInputFactory.setProperty(""javax.xml.stream.supportDTD"", false);


- 외부 또는 로컬 엔터티 확인이 필요한 경우 안전한 리졸버(resolver)를 구축하고 XML 문서를 구문 분석하기 전에 설정합니다.

xmlInputFactory.setXMLResolver(mySafeResolver);
",,833D5C21051DAE715A9E187F5C6D647B,D92D11B4-E03C-4B93-9DAA-402C19BE7EFC,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.08. 부적절한 XML 외부개체 참조","src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",80,"    @PostMapping(path = ""xxe/blind"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult addComment(@RequestBody String commentStr) {
        var fileContentsForUser = userToFileContents.getOrDefault(getWebSession().getUser(), """");
",addComment(0),"src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java","CommentsCache.java",102,"        }

        var xsr = xif.createXMLStreamReader(new StringReader(xml));

        var unmarshaller = jc.createUnmarshaller();","javax.xml.stream.XMLInputFactory.createXMLStreamReader()","CommentsCache.java:102에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","CommentsCache.java:102에 구성된 XML 파서는 외부 엔터티 확인을 방지하거나 제한하지 않습니다. 따라서 파서가 XML 외부 엔터티 공격에 노출될 수 있습니다.","XML 외부 엔터티 공격에서는 XML 기능을 활용하여 처리 시점에 동적으로 문서를 구성합니다. XML 엔터티를 사용하면 지정된 리소스에서 동적으로 데이터를 포함시킬 수 있습니다. 외부 엔터티를 사용하면 XML 문서에 외부 URI의 데이터를 포함할 수 있습니다. 다른 방식으로 처리하도록 구성하지 않은 경우 외부 엔터티는 XML 파서가 URI로 지정된 리소스(예: 로컬 컴퓨터 또는 원격 시스템의 파일)를 접근하게 만듭니다. 이 동작으로 인해 응용 프로그램이 XML 외부 엔터티(XXE) 공격에 노출되고, 이를 통해 로컬 시스템에서 denial of service를 발생시키고, 로컬 컴퓨터의 파일에 무단으로 접근하고, 원격 컴퓨터를 스캔하고, 원격 시스템에서 denial of service를 발생시킬 수 있습니다.

다음 XML 문서에서는 XXE 공격의 예를 보여 줍니다.

<?xml version=""1.0"" encoding=""ISO-8859-1""?>
 <!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM ""file:///dev/random"" >]><foo>&xxe;</foo>


이 예제에서 XML 파서가 엔터티를 /dev/random 파일의 컨텐츠로 대체하려고 시도하는 경우 서버가 중단될 수 있습니다(UNIX 시스템의 경우).","XML unmarshaller가 수신 XML 문서의 일부로 외부 엔터티를 허용하지 않도록 안전하게 구성되어야 합니다.

XXE injection을 방지하려면 XML 소스를 java.io.File, java.io.Reader 또는 java.io.InputStream으로 직접 처리하는 unmarshal 메서드를 사용하지 마십시오. 안전하게 구성된 파서로 문서를 구문 분석하고 다음 예에 표시된 것처럼 보안 파서를 XML 소스를 사용하는 unmarshal 메서드를 사용합니다.


DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(<XML Source>);
Model model = (Model) u.unmarshal(document);


StAX 파서의 경우 다음 구성이 권장됩니다.
- 외부 엔터티 확인 비활성화:

xmlInputFactory.setProperty(""javax.xml.stream.isSupportingExternalEntities"", false);


- 인라인 DOCTYPE 선언이 필요하지 않은 경우 다음 속성으로 완전히 비활성화할 수 있습니다.

xmlInputFactory.setProperty(""javax.xml.stream.supportDTD"", false);


- 외부 또는 로컬 엔터티 확인이 필요한 경우 안전한 리졸버(resolver)를 구축하고 XML 문서를 구문 분석하기 전에 설정합니다.

xmlInputFactory.setXMLResolver(mySafeResolver);
",,97C24C250C1B52E78F35CB2CCDFB3BDE,D92D11B4-E03C-4B93-9DAA-402C19BE7EFC,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",59,"
function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",60,"function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 60 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",7ED0D54EAD4C6C34B9DFE3553BFF8EF6,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",46,"
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",47,"webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 47 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",8CBD1AB0ECC7A07CC56E2018A088C1AD,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",53,"
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",54,"webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 54 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",5677A21185D4B327CFA0E200E97A5086,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",13,"
webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",14,"webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 14 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",F9BB79F6688F5F08EEE1B925A53E7EB4,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",96,"                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
                        .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                        .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
            }","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",963BE056C82388D8ACD280BEA6461285,6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",100,"            }
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java 파일은 100 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",9BE0CE2347F66806C7B28A2349FCC653,6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",29,"
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",30,"webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 30 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",850AAFD007E3AE63447E77148354ACCF,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",85,"        }
        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");
","javax.servlet.ServletRequest.getParameter()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",100,"            }
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java 파일은 100 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",81BB2F5BD2FB15160D5330E5579039B7,6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",76,"webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 76 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",1735E4C4B0F91C8341411C0490D4A3A9,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",53,"
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",54,"webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 54 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",5677A21185D4B327CFA0E200E97A5085,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",46,"
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",47,"webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 47 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",8CBD1AB0ECC7A07CC56E2018A088C1AC,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",13,"
webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",14,"webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 14 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",F9BB79F6688F5F08EEE1B925A53E7EB5,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",85,"        }
        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");
","javax.servlet.ServletRequest.getParameter()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",96,"                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
                        .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                        .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
            }","org.springframework.http.ResponseEntity.HeadersBuilder.location()","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",3289C6823D4F91BFA0A0194872CBA05D,6A431DA2-72CD-4A27-B3F9-1FFE5F8CCACA,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",59,"
function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",60,"function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 60 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",7ED0D54EAD4C6C34B9DFE3553BFF8EF7,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",29,"
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",30,"webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 30 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",850AAFD007E3AE63447E77148354ACD0,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.07. 신뢰되지 않는 URL 주소로 자동 접속 연결","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",76,"webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js 파일은 76 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","ProfileUploadRetrieval.java 파일은 96 줄의 HTTP 리디렉션 함수에 확인되지 않은 데이터를 전달합니다. 리디렉션에 사용된 URL을 제어하도록 확인되지 않은 입력을 허용하면 피싱 공격에 도움이 됩니다.","리디렉션은 웹 응용 프로그램이 동일한 응용 프로그램 내의 다른 페이지 또는 외부 사이트로 사용자를 안내하도록 허용합니다. 경우에 따라, 응용 프로그램은 리디렉션을 사용하여 사이트 탐색을 지원하고 사용자가 사이트를 종료하는 방법을 추적합니다. 웹 응용 프로그램이 클라이언트를 공격자가 제어할 수 있는 임의의 URL로 리디렉션할 때 open redirection 취약점이 발생합니다. 

공격자는 Open Redirection을 사용하여 사용자가 믿을 수 있는 사이트의 URL을 방문하고 있는 것으로 믿게 하고 악의적인 사이트로 리디렉션할 수 있습니다. 공격자는 URL을 인코딩하여 최종 사용자가 악의적인 리디렉션의 대상을 알기가 더 어렵도록 만들기 때문에 심지어 이 URL이 신뢰할 수 있는 사이트에 대한 URL 매개 변수로 전달됩니다. open redirection은 주로 중요한 최종 사용자의 데이터를 빼가는 피싱 사기의 일부로 남용됩니다.



예제 1: 다음 JSP 코드는 사용자가 링크를 클릭할 때 사용자의 브라우저가 dest 요청 매개 변수에서 구문 분석한 URL을 열도록 지시합니다.


    <%
        ...
        String strDest = request.getParameter(""dest"");
        pageContext.forward(strDest);
        ...
    %>


피해자가 “http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com” 링크를 따라가도록 유도하는 전자 메일을 수신한 경우, 사용자는 신뢰할 수 있는 사이트로 이동하는 것으로 믿고 링크를 클릭하게 됩니다. 하지만 피해자가 링크를 클릭하면 Example 1의 코드가 브라우저를 “http://www.wilyhacker.com”으로 리디렉션합니다.

많은 사용자들은 해당 링크가 그들이 아는 신뢰할 수 있는 사이트를 지정하는지 확인하기 위해 전자 메일에서 수신한 URL을 항상 검사하도록 교육받고 있습니다. 그러나 공격자가 의도한 피해자의 링크 목적지를 아래와 같이 헥사 인코드된 URL로 위장할 경우
""http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D""

아무리 경험 많은 최종 사용자도 링크를 따라갈 수 있습니다.","확인되지 않은 사용자 입력은 리디렉션에서 대상 URL을 제어하도록 허용해서는 안 됩니다. 대신 다음과 같이 간접적인 방법을 사용합니다. 즉, 사용자가 지정할 수 있는 올바른 URL 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이러한 방법으로 사용자가 제공한 입력 내용은 URL 리디렉션 지정에 직접 사용되지 않습니다.

예제 2: 다음 코드는 올바른 URL이 입력된 배열을 참조합니다. 사용자가 클릭하는 링크는 원하는 URL로 구성된 배열 인덱스로 전달됩니다.


    <%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter(""dest""));
            if((strDest >= 0) && (strDest <= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %>


경우에 따라, 이러한 방법은 올바른 URL 집합이 너무 크거나 추적이 어려워 실용적이지 못할 수 있습니다. 이러한 경우 사용자를 리디렉션할 수 있는 도메인을 제한하는 다른 방법을 사용하면, 적어도 사용자를 악의적인 외부 사이트로 보내는 공격을 예방할 수 있습니다.","1. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",1735E4C4B0F91C8341411C0490D4A3AA,C71A9777-B31F-4A80-ADED-0868DAE5CF760,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java","ProfileUploadFix.java",28,"    @PostMapping(value = ""/PathTraversal/profile-upload-fix"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(
            @RequestParam(""uploadedFileFix"") MultipartFile file,
            @RequestParam(value = ""fullNameFix"", required = false) String fullName) {",Function: uploadFileHandler(),"ProfileUploadFix.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,CABD92AA7667D948A7AA3D73EAE960F7,FB974E35-2FF9-4BE6-9E52-11494EA1F186,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/webwolf/templates/files.html","files.html",40,"                <div class=""form-inline"">
                    <div class=""form-group"">
                        <input type=""file"" name=""file""/>
                    </div>
                    <button type=""submit"" class=""btn btn-md btn-primary"">Upload files</button>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,3A775546B7BA012F61C039C5DC20D9CE,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/webwolf/templates/files.html","files.html",40,"                <div class=""form-inline"">
                    <div class=""form-group"">
                        <input type=""file"" name=""file""/>
                    </div>
                    <button type=""submit"" class=""btn btn-md btn-primary"">Upload files</button>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,3A775546B7BA012F61C039C5DC20D9CD,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java","ProfileUploadRemoveUserInput.java",26,"    @PostMapping(value = ""/PathTraversal/profile-upload-remove-user-input"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileRemoveUserInput"") MultipartFile file) {
        return super.execute(file, file.getOriginalFilename());
    }",Function: uploadFileHandler(),"ProfileUploadRemoveUserInput.java의 26 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,5AB130F0AF03CCE0DD576276CF785969,FB974E35-2FF9-4BE6-9E52-11494EA1F186,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",31,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile"" id=""uploadedFile""/>
                    </div>
                    <span class=""Error""></span>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133D6,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",238,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile""
                               id=""uploadedFileZipSlip""/>
                    </div>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133D9,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",45,"
    @SneakyThrows
    private AttackResult processZipUpload(MultipartFile file) {
        var tmpZipDirectory = Files.createTempDirectory(getWebSession().getUserName());
        var uploadDirectory = new File(getWebGoatHomeDirectory(), ""/PathTraversal/"" + getWebSession().getUserName());",Function: processZipUpload(),"ProfileZipSlip.java의 45 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,B07509599A3EC94B7B1656D108248E24,FB974E35-2FF9-4BE6-9E52-11494EA1F186,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",Function: importFile(),"FileServer.java의 72 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,3342BA339B8FB8DA003375965F19F40F,FB974E35-2FF9-4BE6-9E52-11494EA1F186,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",238,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile""
                               id=""uploadedFileZipSlip""/>
                    </div>",Function: importFile(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133DD,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",140,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile""
                               id=""uploadedFileRemoveUserInput""/>
                    </div>",Function: importFile(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133D8,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java","ProfileUpload.java",28,"    @PostMapping(value = ""/PathTraversal/profile-upload"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFile"") MultipartFile file, @RequestParam(value = ""fullName"", required = false) String fullName) {
        return super.execute(file, fullName);
    }",Function: uploadFileHandler(),"ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,F56190D3FC447DC50448CEE94BD84535,FB974E35-2FF9-4BE6-9E52-11494EA1F186,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",36,"    @PostMapping(value = ""/PathTraversal/zip-slip"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileZipSlip"") MultipartFile file) {
        if (!file.getOriginalFilename().toLowerCase().endsWith("".zip"")) {
            return failed(this).feedback(""path-traversal-zip-slip.no-zip"").build();",Function: uploadFileHandler(),"ProfileZipSlip.java의 36 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,EA7BC98C2530B8674DF42C330C295D20,FB974E35-2FF9-4BE6-9E52-11494EA1F186,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",85,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile"" id=""uploadedFileFix""/>
                    </div>
                    <span class=""Error""></span>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133D7,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",140,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile""
                               id=""uploadedFileRemoveUserInput""/>
                    </div>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133DC,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",31,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile"" id=""uploadedFile""/>
                    </div>
                    <span class=""Error""></span>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133DA,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,API Abuse,"01.06. 위험한 형식 파일 업로드","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/html/PathTraversal.html","PathTraversal.html",85,"                    <div class=""browse-button"">
                        <i class=""fa fa-pencil""></i>
                        <input class=""browse-input"" type=""file"" required name=""uploadedFile"" id=""uploadedFileFix""/>
                    </div>
                    <span class=""Error""></span>",Function: uploadFileHandler(),"사용자에게 파일 업로드에 대한 권한이 주어지면 공격자는 위험한 콘텐트나 악성 코드를 삽입하여 서버에서 실행할 수 있습니다.","ProfileUpload.java의 28 줄에서 org.springframework.web.multipart.MultipartFile 유형의 매개 변수는 Spring MVC 프레임워크에서 업로드된 파일을 설정하는 데 사용됩니다. 사용자의 파일 업로드를 허용하면 공격자가 위험한 콘텐트를 주입하거나 서버에서 악성 코드를 실행할 수 있습니다.","프로그램을 작성한 언어와 관계 없이 대부분의 파괴적인 공격은 원격 코드 실행과 관련이 있으며 이러한 점을 사용하여 공격자는 프로그램의 컨텍스트에 악성 코드를 실행하는 데 성공합니다. 공격자가 웹에서 접근할 수 있는 디렉터리에 파일을 업로드하여 해당 파일이 코드 인터프리터(예: JSP/ASPX/PHP)에 전달되면 이러한 파일에 포함된 악성 코드가 서버에서 실행될 수 있습니다.

예제: 다음 Spring MVC 컨트롤러에는 업로드된 파일 처리에 사용할 수 있는 매개 변수가 있습니다.

@Controller
public class MyFormController {
    ...
    @RequestMapping(""/test"")
    public String uploadFile (org.springframework.web.multipart.MultipartFile file) {
       ...
    }    ...
}


프로그램이 웹에서 접근할 수 없는 디렉터리 아래에 업로드한 파일을 저장하더라도 공격자는 악성 콘텐트를 서버 환경에 전달할 수 있는 능력을 이용하여 공격에 성공할 수 있습니다. 프로그램이 path manipulation, command injection 또는 dangerous file inclusion 취약점에 취약한 경우, 공격자는 악성 콘텐트가 포함된 파일을 업로드하여 프로그램에서 다른 취약점을 익스플로이트함으로써 해당 파일을 읽거나 실행할 수 있습니다.","피할 수 있다면 첨부를 허용하지 마십시오. 프로그램이 첨부 파일을 허용해야 하는 경우, 프로그램이 예상하는 콘텐트의 특정 유형만 허용하여 악성 콘텐트를 제공하는 공격자의 능력을 제한합니다. 업로드된 콘텐트에 의존하는 대부분의 공격을 수행하려면 공격자가 선택한 콘텐트를 제공할 수 있어야 합니다. 프로그램이 허용하는 콘텐트에 제한 사항을 두는 것은 가능한 공격의 범위를 크게 제한합니다. 응용 프로그램의 사용을 위해 모두 예상되고 허용 가능한지 확인하기 위해 파일 이름, 확장명 및 파일 콘텐트를 확인합니다. 공격자가 업로드된 파일의 이름 및 위치를 확인하기 어렵게 만듭니다. 그러한 해결책은 주로 프로그램에 따라 다르며, 프로그램이 강한 랜덤 값으로 만들어진 디렉터리에 업로드한 파일을 랜덤 값을 할당하여 저장하고, 데이터베이스를 사용한 추적을 하는 방법에 따라 다양합니다.",,56E5E81FE126C18BEDAC8971687133DB,F817CA63-FAE2-40D4-9A51-89912B5ADFC1,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.05. 운영체제 명령어 삽입","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/java/org/dummy/insecure/framework/VulnerableTaskHolder.java","VulnerableTaskHolder.java",60,"		log.info(""about to execute: {}"", taskAction);
		try {
            Process p = Runtime.getRuntime().exec(taskAction);
            BufferedReader in = new BufferedReader(
                                new InputStreamReader(p.getInputStream()));",exec(0),"VulnerableTaskHolder.java의 readObject() 메서드는 exec()을(를) 호출하여 명령을 실행합니다. 이 호출을 사용하면 공격자가 악의적인 명령을 삽입할 수 있습니다.","VulnerableTaskHolder.java의 readObject() 메서드는 exec()을(를) 호출하여 명령을 실행합니다. 이 호출을 사용하면 공격자가 악의적인 명령을 삽입할 수 있습니다.","Command injection 취약점은 두 가지 형태로 나타납니다.

- 공격자가 프로그램이 실행하는 명령을 변경합니다. 공격자가 명시적으로 명령 부분을 제어합니다.

- 공격자가 프로그램이 실행되는 환경을 변경합니다. 공격자가 암시적으로 명령의 의미를 제어합니다.

여기서는, 공격자가 환경 변수를 변경하거나 악성 실행 파일을 검색 경로에 삽입하여 명령의 의미를 변경할 수 있는 두 번째 시나리오를 중점적으로 살펴보겠습니다. 이런 종류의 command injection 취약점은 다음 경우에 발생합니다.

1. 공격자가 응용 프로그램의 환경을 수정합니다. 

2. 응용 프로그램은 절대 경로 지정 또는 수행하는 이진 파일 확인 등의 작업을 거치지 않고 명령을 실행합니다. 

3. 응용 프로그램은 명령을 실행하여 공격자에게 공격자가 다른 방법으로는 얻을 수 없는 권한 또는 기능을 부여합니다. 

예제: 다음 코드는 사용자가 시스템의 암호를 업데이트할 수 있는 인터페이스를 제공하는 웹 응용 프로그램의 일부입니다. 특정 네트워크 환경에서 암호를 업데이트하는 프로세스의 일부는 /var/yp 디렉터리에서 make 명령을 실행하는 것입니다.


...
System.Runtime.getRuntime().exec(""make"");
...


여기서 문제는 프로그램이 make의 절대 경로를 지정하지 않아 Runtime.exec() 호출을 실행하기 전에 실행 환경이 정리되지 않는다는 점입니다. 공격자가 $PATH 변수를 수정하여 make라는 악성 이진 파일을 가리키도록 하고 자신의 환경에서 프로그램을 실행하면 원하는 파일 대신 악성 이진 파일이 로드됩니다. 응용 프로그램은 그 속성 때문에 시스템 작업을 수행하는 데 필요한 권한으로 실행됩니다. 즉, 공격자의 make는 이 권한으로 실행되어 공격자에게 시스템의 완전한 제어권을 넘겨줄 수 있습니다.","공격자는 명령이 실행되는 환경을 수정하여 프로그램이 실행하는 명령을 간접적으로 제어할 수 있습니다. 실행 환경을 신뢰할 수 없으므로 공격자가 환경을 조작하여 공격을 가하는 것을 막기 위한 예방 조치를 취해야 합니다. 가급적이면 명령은 응용 프로그램에서 제어해야 하고 절대 경로를 사용하여 실행해야 합니다. 교차 플랫폼 응용 프로그램의 경우와 같이 컴파일 시 경로를 알 수 없는 경우, 실행 도중 신뢰할 수 있는 값으로 절대 경로를 만들어야 합니다. 구성 파일 또는 환경에서 읽은 명령 값 및 경로를 올바른 값을 정의해 놓은 고정 값 집합과 대조하는 안전 검사를 수행해야 합니다.

이 소스가 조작된 것인지 밝히기 위한 검사도 수행할 수 있습니다. 예를 들어, 구성 파일이 누구나 쓸 수 있는(world-writable) 파일인 경우 프로그램이 실행을 거부할 수 있습니다. 실행할 이진 파일에 대한 정보를 사전에 알고 있으면 프로그램이 이진 파일의 ID를 확인하기 위한 검사를 실시할 수 있습니다. 이진 파일을 항상 특정 사용자가 소유해야 하거나 파일에 특정 접근 권한 집합을 지정해야 하는 경우, 파일을 실행하기 전에 이런 속성을 프로그래밍 방식으로 확인할 수 있습니다.

결론적으로 프로그램은 프로그램이 실행하는 명령을 제어하려는 가상의 공격자로부터 스스로를 완벽하게 보호하는 일이 불가능합니다. 따라서 상상할 수 있는 모든 입력 값 및 환경 조작을 식별하고 예방하기 위해 노력할 수밖에 없습니다. 목표는 최대한 많은 공격을 차단하는 것입니다.","1. Windows에서는 실행되는 명령이 Windows 내부 명령인 경우 보고된 문제가 우려 대상이 아닙니다. 내부 명령은 디스크에 상주하지 않습니다. 대신 컴퓨터 시스템이 시작될 때 메모리에 로드되는 COMMAND.COM에 상주합니다. 내부 명령에는 BREAK, CALL, CHCP, CHDIR(CD), CLS, COPY, CTTY, DATE, DEL(ERASE), DIR, ECHO, EXIT, FOR, GOTO, IF, MKDIR(MD), PATH, PAUSE, PROMPT, REM, RENAME(REN), RMDIR(RD), SET, SHIFT, TIME, TYPE, VER, VERIFY, VOL이 포함됩니다. 사용 중인 시스템의 최신 내부 명령 목록은 시스템 설명서를 참조하십시오.",3D00A2EDD1CAF40F1B37BEFF6374E92A,69777D84-8507-40A7-9C2B-0B18E4A5EB0A,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",23,"
    public List<User> findAllUsers() {
        return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
    }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java","MissingFunctionACUsers.java",83,"        var currentUser = userRepository.findByUsername(webSession.getUserName());
        if (currentUser != null && currentUser.isAdmin()) {
            return ResponseEntity.ok(userRepository.findAllUsers().stream().map(user -> new DisplayUser(user, PASSWORD_SALT_ADMIN)).collect(Collectors.toList()));
        }
        return ResponseEntity.status(HttpStatus.FORBIDDEN).build();","org.springframework.http.ResponseEntity.ok()","MissingFunctionACUsers.java의 usersFixed() 메서드가 83 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",DDC5B124AE0BD076C62BC562F3E12F28,B15BA48C-C3A9-42C0-928D-B555CD29BFAD0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",13,"
webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",14,"webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 14 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",A889C22BD33750C63023B4C71B239338,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",17,"
function ajaxFunction(userId) {
    $.get(""clientSideFiltering/salaries?userId="" + userId, function (result, status) {
        var html = ""<table border = '1' width = '90%' align = 'center'"";
        html = html + '<tr>';",lambda(0),"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",38,"
        var newdiv = document.createElement(""div"");
        newdiv.innerHTML = html;
        var container = document.getElementById(""hiddenEmployeeRecords"");
        container.appendChild(newdiv);","Assignment to newdiv.innerHTML()","clientSideFiltering.js의 lambda() 메서드가 38 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",DACB0F537F0673E55AF1E553A109324D,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js","clientSideFilteringFree.js",40,"    })
    $("".checkoutCode"").on(""blur"", function () {
        var checkoutCode = $("".checkoutCode"").val();
        $.get(""clientSideFiltering/challenge-store/coupons/"" + checkoutCode, function (result, status) {
            var discount = result.discount;","~JS_Generic.val()","src/main/resources/lessons/clientsidefiltering/js/clientSideFilteringFree.js","clientSideFilteringFree.js",41,"    $("".checkoutCode"").on(""blur"", function () {
        var checkoutCode = $("".checkoutCode"").val();
        $.get(""clientSideFiltering/challenge-store/coupons/"" + checkoutCode, function (result, status) {
            var discount = result.discount;
            if (discount > 0) {","~JS_Generic.get()","clientSideFilteringFree.js의 lambda() 메서드가 41 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",11BC029AB8F16560B25048F80509F478,810167D4-74D7-4579-8122-222913D6FAE50,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",lambda(0),"target/classes/lessons/challenges/js/challenge8.js","challenge8.js",18,"                var progressBar = $('#progressBar' + i);
                progressBar.width(Math.round(percent) * 2 + '%');
                $(""#nrOfVotes"" + i).html(votes[i]);

            }","~JS_Generic.html()","challenge8.js의 lambda() 메서드가 18 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",86D6531C6F6737839E0CD291D7D3E3FD,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/csrf/js/csrf-review.js","csrf-review.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('csrf/review', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",lambda(0),"target/classes/lessons/csrf/js/csrf-review.js","csrf-review.js",41,"                comment = comment.replace('COMMENT', result[i].text);
                comment = comment.replace('STARS', result[i].stars)
                $(""#list"").append(comment);
            }
","~JS_Generic.append()","csrf-review.js의 lambda() 메서드가 41 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",3D8081EA79972992DF4D740A7973C281,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",76,"webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 76 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",CFEC1B3B2B4BB09B167A70747456A945,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/xss/js/stored-xss.js","stored-xss.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('CrossSiteScripting/stored-xss', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",lambda(0),"target/classes/lessons/xss/js/stored-xss.js","stored-xss.js",40,"                comment = comment.replace('DATETIME', result[i].dateTime);
                comment = comment.replace('COMMENT', result[i].text);
                $(""#list"").append(comment);
            }
","~JS_Generic.append()","stored-xss.js의 lambda() 메서드가 40 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",3D8081EA79972992DF4D740A7973C282,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/jwt/js/jwt-voting.js","jwt-voting.js",43,"function getVotings() {
    $(""#votesList"").empty();
    $.get(""JWT/votings"", function (result, status) {
        for (var i = 0; i < result.length; i++) {
            var voteTemplate = html.replace('IMAGE_SMALL', result[i].imageSmall);",lambda(0),"src/main/resources/lessons/jwt/js/jwt-voting.js","jwt-voting.js",63,"            voteTemplate = voteTemplate.replace(/HIDDEN_VIEW_RATING/g, hidden);

            $(""#votesList"").append(voteTemplate);
        }
    })","~JS_Generic.append()","jwt-voting.js의 lambda() 메서드가 63 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",36F3C2F37249E8226AD81102D2BA54EB,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/webgoat/static/js/libs/jquery.form.js","jquery.form.js",115,"
    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)","Read window.location()","src/main/resources/webgoat/static/js/libs/jquery.form.js","jquery.form.js",346,"            }
        };
        return $.ajax(s);
    }
","~JS_Generic.ajax()","jquery.form.js의 fileUploadXhr() 메서드가 346 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",F54D787DF80ACAF4CC63549EFED3A2E1,43F16EB5-A3E5-4A50-B1AB-B6CB5BE10F010,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",46,"function doVote(stars) {
    $(""#voteResultMsg"").hide();
    $.get(""challenge/8/vote/"" + stars, function (result) {
        if (result[""error""]) {
            $(""#voteResultMsg"").addClass('alert-danger alert-dismissable');",lambda(0),"src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",52,"            $(""#voteResultMsg"").addClass('alert-success alert-dismissable');
        }
        $(""#voteResultMsg"").html(result[""message""]);
        $(""#voteResultMsg"").show();
    })","~JS_Generic.html()","challenge8.js의 lambda() 메서드가 52 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",C2A5EBDFCA387E4BA09B4AE84F34133C,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/clientsidefiltering/js/clientSideFilteringFree.js","clientSideFilteringFree.js",40,"    })
    $("".checkoutCode"").on(""blur"", function () {
        var checkoutCode = $("".checkoutCode"").val();
        $.get(""clientSideFiltering/challenge-store/coupons/"" + checkoutCode, function (result, status) {
            var discount = result.discount;","~JS_Generic.val()","target/classes/lessons/clientsidefiltering/js/clientSideFilteringFree.js","clientSideFilteringFree.js",41,"    $("".checkoutCode"").on(""blur"", function () {
        var checkoutCode = $("".checkoutCode"").val();
        $.get(""clientSideFiltering/challenge-store/coupons/"" + checkoutCode, function (result, status) {
            var discount = result.discount;
            if (discount > 0) {","~JS_Generic.get()","clientSideFilteringFree.js의 lambda() 메서드가 41 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",11BC029AB8F16560B25048F80509F479,810167D4-74D7-4579-8122-222913D6FAE50,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/sqlinjection/js/assignment13.js","assignment13.js",43,"
function getServers(column) {
    $.get(""SqlInjectionMitigations/servers?column="" + column, function (result, status) {
        $(""#servers"").empty();
        for (var i = 0; i < result.length; i++) {",lambda(0),"src/main/resources/lessons/sqlinjection/js/assignment13.js","assignment13.js",57,"            server = server.replace('MAC', result[i].mac);
            server = server.replace('DESCRIPTION', result[i].description);
            $(""#servers"").append(server);
        }
","~JS_Generic.append()","assignment13.js의 lambda() 메서드가 57 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",016B849F15785802F74FD08FE29D2BB9,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/sqlinjection/js/assignment13.js","assignment13.js",43,"
function getServers(column) {
    $.get(""SqlInjectionMitigations/servers?column="" + column, function (result, status) {
        $(""#servers"").empty();
        for (var i = 0; i < result.length; i++) {",lambda(0),"target/classes/lessons/sqlinjection/js/assignment13.js","assignment13.js",57,"            server = server.replace('MAC', result[i].mac);
            server = server.replace('DESCRIPTION', result[i].description);
            $(""#servers"").append(server);
        }
","~JS_Generic.append()","assignment13.js의 lambda() 메서드가 57 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",016B849F15785802F74FD08FE29D2BBA,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/jwt/js/jwt-voting.js","jwt-voting.js",43,"function getVotings() {
    $(""#votesList"").empty();
    $.get(""JWT/votings"", function (result, status) {
        for (var i = 0; i < result.length; i++) {
            var voteTemplate = html.replace('IMAGE_SMALL', result[i].imageSmall);",lambda(0),"target/classes/lessons/jwt/js/jwt-voting.js","jwt-voting.js",63,"            voteTemplate = voteTemplate.replace(/HIDDEN_VIEW_RATING/g, hidden);

            $(""#votesList"").append(voteTemplate);
        }
    })","~JS_Generic.append()","jwt-voting.js의 lambda() 메서드가 63 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",36F3C2F37249E8226AD81102D2BA54EC,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",53,"
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",54,"webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 54 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",3FD1E744F7E387DC19BE49AA97B3C159,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/webgoat/static/js/goatApp/support/GoatUtils.js","GoatUtils.js",56," 
                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $(""#lesson_cookies"").html(reply);
                    }, ""html"");",lambda(0),"src/main/resources/webgoat/static/js/goatApp/support/GoatUtils.js","GoatUtils.js",57,"                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $(""#lesson_cookies"").html(reply);
                    }, ""html"");
                },","~JS_Generic.html()","GoatUtils.js의 lambda() 메서드가 57 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",5FA2450CD3CF0C6025C4756997863167,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/xxe/js/xxe.js","xxe.js",72,"
function getComments(field) {
    $.get(""xxe/comments"", function (result, status) {
        $(field).empty();
        for (var i = 0; i < result.length; i++) {",lambda(0),"target/classes/lessons/xxe/js/xxe.js","xxe.js",78,"            comment = comment.replace('DATETIME', result[i].dateTime);
            comment = comment.replace('COMMENT', result[i].text);
            $(field).append(comment);
        }
","~JS_Generic.append()","xxe.js의 lambda() 메서드가 78 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",2DEFEDB80221B9F0475DB0C5722F80AE,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",115,"
    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)","Read window.location()","target/classes/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",346,"            }
        };
        return $.ajax(s);
    }
","~JS_Generic.ajax()","jquery.form.js의 fileUploadXhr() 메서드가 346 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",F54D787DF80ACAF4CC63549EFED3A2E2,43F16EB5-A3E5-4A50-B1AB-B6CB5BE10F010,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/xss/js/stored-xss.js","stored-xss.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('CrossSiteScripting/stored-xss', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",lambda(0),"src/main/resources/lessons/xss/js/stored-xss.js","stored-xss.js",40,"                comment = comment.replace('DATETIME', result[i].dateTime);
                comment = comment.replace('COMMENT', result[i].text);
                $(""#list"").append(comment);
            }
","~JS_Generic.append()","stored-xss.js의 lambda() 메서드가 40 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",3D8081EA79972992DF4D740A7973C280,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",59,"
function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",60,"function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 60 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",1F9243720929DE42C32777C86DE4A660,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",46,"
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",47,"webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 47 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",156F1B6AFE8BFD06D3792422222C837F,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",59,"
function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",60,"function newRandomPicture() {
    $.get(""PathTraversal/random-picture"", function (result, status) {
        document.getElementById(""randomCatPicture"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 60 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",1F9243720929DE42C32777C86DE4A661,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",29,"
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",30,"webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 30 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",680B672B9A46E2388E2BA006ACEC2587,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",115,"
    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)","Read window.location()","src/main/resources/webgoat/static/js/jquery_form/jquery.form.js","jquery.form.js",346,"            }
        };
        return $.ajax(s);
    }
","~JS_Generic.ajax()","jquery.form.js의 fileUploadXhr() 메서드가 346 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",F54D787DF80ACAF4CC63549EFED3A2E0,43F16EB5-A3E5-4A50-B1AB-B6CB5BE10F010,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",29,"
webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",30,"webgoat.customjs.profileUploadCallbackFix = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewFix"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 30 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",680B672B9A46E2388E2BA006ACEC2588,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/webgoat/static/js/goatApp/support/GoatUtils.js","GoatUtils.js",56," 
                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $(""#lesson_cookies"").html(reply);
                    }, ""html"");",lambda(0),"target/classes/webgoat/static/js/goatApp/support/GoatUtils.js","GoatUtils.js",57,"                showLessonCookiesAndParams: function() {
                    $.get(goatConstants.cookieService, {}, function(reply) {
                        $(""#lesson_cookies"").html(reply);
                    }, ""html"");
                },","~JS_Generic.html()","GoatUtils.js의 lambda() 메서드가 57 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",5FA2450CD3CF0C6025C4756997863168,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",12,"    if (!dataFetched) {
        dataFetched = true;
        ajaxFunction(document.getElementById(""userID"").value);
    }
}",Read value(),"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",17,"
function ajaxFunction(userId) {
    $.get(""clientSideFiltering/salaries?userId="" + userId, function (result, status) {
        var html = ""<table border = '1' width = '90%' align = 'center'"";
        html = html + '<tr>';","~JS_Generic.get()","clientSideFiltering.js의 ajaxFunction() 메서드가 17 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",CA1DD33F43145291A714FE245733B0CA,810167D4-74D7-4579-8122-222913D6FAE50,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",75,"
webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"src/main/resources/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",76,"webgoat.customjs.profileZipSlipRetrieval = function () {
    $.get(""PathTraversal/zip-slip"", function (result, status) {
        document.getElementById(""previewZipSlip"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 76 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",CFEC1B3B2B4BB09B167A70747456A944,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/challenges/js/challenge8.js","challenge8.js",46,"function doVote(stars) {
    $(""#voteResultMsg"").hide();
    $.get(""challenge/8/vote/"" + stars, function (result) {
        if (result[""error""]) {
            $(""#voteResultMsg"").addClass('alert-danger alert-dismissable');",lambda(0),"target/classes/lessons/challenges/js/challenge8.js","challenge8.js",52,"            $(""#voteResultMsg"").addClass('alert-success alert-dismissable');
        }
        $(""#voteResultMsg"").html(result[""message""]);
        $(""#voteResultMsg"").show();
    })","~JS_Generic.html()","challenge8.js의 lambda() 메서드가 52 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",C2A5EBDFCA387E4BA09B4AE84F34133D,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",12,"    if (!dataFetched) {
        dataFetched = true;
        ajaxFunction(document.getElementById(""userID"").value);
    }
}",Read value(),"target/classes/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",17,"
function ajaxFunction(userId) {
    $.get(""clientSideFiltering/salaries?userId="" + userId, function (result, status) {
        var html = ""<table border = '1' width = '90%' align = 'center'"";
        html = html + '<tr>';","~JS_Generic.get()","clientSideFiltering.js의 ajaxFunction() 메서드가 17 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",CA1DD33F43145291A714FE245733B0CB,810167D4-74D7-4579-8122-222913D6FAE50,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/webgoat/static/js/libs/jquery.form.js","jquery.form.js",115,"
    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)","Read window.location()","target/classes/webgoat/static/js/libs/jquery.form.js","jquery.form.js",346,"            }
        };
        return $.ajax(s);
    }
","~JS_Generic.ajax()","jquery.form.js의 fileUploadXhr() 메서드가 346 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",F54D787DF80ACAF4CC63549EFED3A2E3,43F16EB5-A3E5-4A50-B1AB-B6CB5BE10F010,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/java/org/owasp/webgoat/lessons/missingac/MissingAccessControlUserRepository.java","MissingAccessControlUserRepository.java",23,"
    public List<User> findAllUsers() {
        return jdbcTemplate.query(""select username, password, admin from access_control_users"", mapper);
    }
","org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.query()","src/main/java/org/owasp/webgoat/lessons/missingac/MissingFunctionACUsers.java","MissingFunctionACUsers.java",75,"    @ResponseBody
    public ResponseEntity<List<DisplayUser>> usersService() {
        return ResponseEntity.ok(userRepository.findAllUsers().stream().map(user -> new DisplayUser(user, PASSWORD_SALT_SIMPLE)).collect(Collectors.toList()));
    }
","org.springframework.http.ResponseEntity.ok()","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",4CC0DB7730948834E7569DC29E7B48A6,B15BA48C-C3A9-42C0-928D-B555CD29BFAD0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/xxe/js/xxe.js","xxe.js",72,"
function getComments(field) {
    $.get(""xxe/comments"", function (result, status) {
        $(field).empty();
        for (var i = 0; i < result.length; i++) {",lambda(0),"src/main/resources/lessons/xxe/js/xxe.js","xxe.js",78,"            comment = comment.replace('DATETIME', result[i].dateTime);
            comment = comment.replace('COMMENT', result[i].text);
            $(field).append(comment);
        }
","~JS_Generic.append()","xxe.js의 lambda() 메서드가 78 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",2DEFEDB80221B9F0475DB0C5722F80AD,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",53,"
webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",54,"webgoat.customjs.profileUploadCallbackRetrieval = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRetrieval"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 54 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",3FD1E744F7E387DC19BE49AA97B3C15A,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",46,"
webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",47,"webgoat.customjs.profileUploadCallbackRemoveUserInput = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""previewRemoveUserInput"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 47 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",156F1B6AFE8BFD06D3792422222C8380,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",13,"
webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });",lambda(0),"target/classes/lessons/pathtraversal/js/path_traversal.js","path_traversal.js",14,"webgoat.customjs.profileUploadCallback = function () {
    $.get(""PathTraversal/profile-picture"", function (result, status) {
        document.getElementById(""preview"").src = ""data:image/png;base64,"" + result;
    });
}",Assignment to src(),"path_traversal.js의 lambda() 메서드가 14 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",A889C22BD33750C63023B4C71B239339,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",17,"
function ajaxFunction(userId) {
    $.get(""clientSideFiltering/salaries?userId="" + userId, function (result, status) {
        var html = ""<table border = '1' width = '90%' align = 'center'"";
        html = html + '<tr>';",lambda(0),"src/main/resources/lessons/clientsidefiltering/js/clientSideFiltering.js","clientSideFiltering.js",38,"
        var newdiv = document.createElement(""div"");
        newdiv.innerHTML = html;
        var container = document.getElementById(""hiddenEmployeeRecords"");
        container.appendChild(newdiv);","Assignment to newdiv.innerHTML()","clientSideFiltering.js의 lambda() 메서드가 38 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",DACB0F537F0673E55AF1E553A109324C,EC6687E2-7A2A-4B4B-8E8A-7595215D8D4E0,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",7,"
function loadVotes() {
    $.get(""challenge/8/votes/"", function (votes) {
            var totalVotes = 0;
            for (var i = 1; i <= 5; i++) {",lambda(0),"src/main/resources/lessons/challenges/js/challenge8.js","challenge8.js",18,"                var progressBar = $('#progressBar' + i);
                progressBar.width(Math.round(percent) * 2 + '%');
                $(""#nrOfVotes"" + i).html(votes[i]);

            }","~JS_Generic.html()","challenge8.js의 lambda() 메서드가 18 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",86D6531C6F6737839E0CD291D7D3E3FC,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/main/resources/lessons/csrf/js/csrf-review.js","csrf-review.js",35,"    function getChallenges() {
        $(""#list"").empty();
        $.get('csrf/review', function (result, status) {
            for (var i = 0; i < result.length; i++) {
                var comment = html.replace('USER', result[i].user);",lambda(0),"src/main/resources/lessons/csrf/js/csrf-review.js","csrf-review.js",41,"                comment = comment.replace('COMMENT', result[i].text);
                comment = comment.replace('STARS', result[i].stars)
                $(""#list"").append(comment);
            }
","~JS_Generic.append()","csrf-review.js의 lambda() 메서드가 41 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","MissingFunctionACUsers.java의 usersService() 메서드가 75 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",3D8081EA79972992DF4D740A7973C27F,D23845BE-28FC-4A70-BE22-3BB3A26746750,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java","MvcConfiguration.java",61,"    @PostConstruct
    public void createDirectory() {
        File file = new File(fileLocation);
        if (!file.exists()) {
            file.mkdirs();","Read this.fileLocation()","src/main/java/org/owasp/webgoat/webwolf/MvcConfiguration.java","MvcConfiguration.java",61,"    @PostConstruct
    public void createDirectory() {
        File file = new File(fileLocation);
        if (!file.exists()) {
            file.mkdirs();","java.io.File.File()","공격자는 MvcConfiguration.java의 61 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",D49C01075B955F42C9CD41FBFAE8DA94,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",76,"        var destinationDir = new File(fileLocation, user.getUsername());
        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));
        log.debug(""File saved to {}"", new File(destinationDir, myFile.getOriginalFilename()));
","java.io.File.File()","공격자는 FileServer.java의 76 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",A5451D6D582DE0039606DA329D686AF8,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java","ProfileUploadRemoveUserInput.java",20,"public class ProfileUploadRemoveUserInput extends ProfileUploadBase {

    public ProfileUploadRemoveUserInput(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUploadRemoveUserInput(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",36,"        }

        var uploadDirectory = new File(this.webGoatHomeDirectory, ""/PathTraversal/"" + webSession.getUserName());
        if (uploadDirectory.exists()) {
            FileSystemUtils.deleteRecursively(uploadDirectory);","java.io.File.File()","공격자는 ProfileUploadBase.java의 36 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",C1B90D31B0BB598EFA155A39BAF63788,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java","ProfileUploadFix.java",22,"public class ProfileUploadFix extends ProfileUploadBase {

    public ProfileUploadFix(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUploadFix(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",36,"        }

        var uploadDirectory = new File(this.webGoatHomeDirectory, ""/PathTraversal/"" + webSession.getUserName());
        if (uploadDirectory.exists()) {
            FileSystemUtils.deleteRecursively(uploadDirectory);","java.io.File.File()","공격자는 ProfileUploadBase.java의 36 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",E400A8B900751CC668C93B1736934608,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",85,"        }
        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");
","javax.servlet.ServletRequest.getParameter()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",96,"                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
                        .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                        .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
            }","java.net.URI.URI()","공격자는 ProfileUploadRetrieval.java의 96 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",3E0F149F2CD2A130515BC000124DE7F7,8F3B2393-5D1E-4860-A96F-0F6E0274923F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java","MD5.java",48,"     * @since ostermillerutils 1.00.00
     */
    public static void main(String[] args) {
        if (args.length == 0) {
            System.err.println(""Please specify a file."");",main(0),"src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/MD5.java","MD5.java",54,"            for (String element : args) {
                try {
                    System.out.println(MD5.getHashString(new File(element)) + "" "" + element);
                } catch (IOException x) {
                    System.err.println(x.getMessage());","java.io.File.File()","공격자는 MD5.java의 54 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",096ABF3C7F905DB581633CC80DEA4215,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",76,"    public List<Map<String, Object>> invoke() {
        NodeList nodes = null;
        File d = new File(webGoatHomeDirectory, ""ClientSideFiltering/employees.xml"");
        XPathFactory factory = XPathFactory.newInstance();
        XPath path = factory.newXPath();","Read this.webGoatHomeDirectory()","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",76,"    public List<Map<String, Object>> invoke() {
        NodeList nodes = null;
        File d = new File(webGoatHomeDirectory, ""ClientSideFiltering/employees.xml"");
        XPathFactory factory = XPathFactory.newInstance();
        XPath path = factory.newXPath();","java.io.File.File()","공격자는 Salaries.java의 76 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",7781A6373CDAD8AF0B9748FC683BC31D,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",36,"    @PostMapping(value = ""/PathTraversal/zip-slip"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileZipSlip"") MultipartFile file) {
        if (!file.getOriginalFilename().toLowerCase().endsWith("".zip"")) {
            return failed(this).feedback(""path-traversal-zip-slip.no-zip"").build();",uploadFileHandler(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",54,"        try {
            var uploadedZipFile = tmpZipDirectory.resolve(file.getOriginalFilename());
            FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());

            ZipFile zip = new ZipFile(uploadedZipFile.toFile());","java.nio.file.Path.toFile()","공격자는 ProfileZipSlip.java의 54 줄에 있는 toFile()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",B5CC4D9BFC281A19EE73A7B1FBEFCCAE,788E3752-66EE-4EE0-8C5D-9F24DBBECEE1,,,,Fri May 31 16:52:25 KST 2024,
Medium,Medium,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",60,"            while (entries.hasMoreElements()) {
                ZipEntry e = entries.nextElement();
                File f = new File(tmpZipDirectory.toFile(), e.getName());
                InputStream is = zip.getInputStream(e);
                Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);","java.util.zip.ZipEntry.getName()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",62,"                File f = new File(tmpZipDirectory.toFile(), e.getName());
                InputStream is = zip.getInputStream(e);
                Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);
            }
","java.nio.file.Files.copy()","ProfileZipSlip.java의 62 줄에서 copy()을(를) 호출하면 공격자가 시스템의 모든 위치에서 임의로 파일에 쓸 수 있습니다. ","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",BF9EB58D7A762D3401365A6BFCB1723E,13DC12CE-83A1-449A-B892-E2FB69F72C64,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java","Ping.java",52,"        String logLine = String.format(""%s %s %s"", ""GET"", userAgent, text);
        log.debug(logLine);
        File logFile = new File(webGoatHomeDirectory, ""/XXE/log"" + webSession.getUserName() + "".txt"");
        try {
            try (PrintWriter pw = new PrintWriter(logFile)) {","Read this.webGoatHomeDirectory()","src/main/java/org/owasp/webgoat/lessons/xxe/Ping.java","Ping.java",52,"        String logLine = String.format(""%s %s %s"", ""GET"", userAgent, text);
        log.debug(logLine);
        File logFile = new File(webGoatHomeDirectory, ""/XXE/log"" + webSession.getUserName() + "".txt"");
        try {
            try (PrintWriter pw = new PrintWriter(logFile)) {","java.io.File.File()","공격자는 Ping.java의 52 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",3FFAFBE7B47F00C4F83114ECCB24445A,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java","ProfileUploadFix.java",30,"    public AttackResult uploadFileHandler(
            @RequestParam(""uploadedFileFix"") MultipartFile file,
            @RequestParam(value = ""fullNameFix"", required = false) String fullName) {
        return super.execute(file, fullName != null ? fullName.replace(""../"", """") : """");
    }",uploadFileHandler(1),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",43,"        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();
            FileCopyUtils.copy(file.getBytes(), uploadedFile);","java.io.File.File()","공격자는 ProfileUploadBase.java의 43 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",E4E024548C018C8E3CA493B08C0CAF98,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",97,"        WebGoatUser user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        String username = user.getUsername();
        File destinationDir = new File(fileLocation, username);

        ModelAndView modelAndView = new ModelAndView();","Read this.fileLocation()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",97,"        WebGoatUser user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        String username = user.getUsername();
        File destinationDir = new File(fileLocation, username);

        ModelAndView modelAndView = new ModelAndView();","java.io.File.File()","공격자는 FileServer.java의 97 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",E29A3D2C3B91B0F49999CFAEB616B0D2,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입",".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",48,"    private static final String PROPERTY_NAME_WRAPPER_URL = ""wrapperUrl"";

    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);",main(0),".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",50,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());
","java.io.File.File()","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",04CDDAF9236AA4E351BC22DCC0629B39,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",85,"        }
        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");
","javax.servlet.ServletRequest.getParameter()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",86,"        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");

            if (catPicture.getName().toLowerCase().contains(""path-traversal-secret.jpg"")) {","java.io.File.File()","공격자는 ProfileUploadRetrieval.java의 86 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",BDE2F28515B34608712873BA3FA371E2,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",30,"public class ProfileZipSlip extends ProfileUploadBase {

    public ProfileZipSlip(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileZipSlip(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",75,"
    protected byte[] getProfilePictureAsBase64() {
        var profilePictureDirectory = new File(this.webGoatHomeDirectory, ""/PathTraversal/"" + webSession.getUserName());
        var profileDirectoryFiles = profilePictureDirectory.listFiles();
","java.io.File.File()","공격자는 ProfileUploadBase.java의 75 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",EA4BAA6F08FF15063329C0BB76A3DA58,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java","BlindSendFileAssignmentTest.java",89,"    @Test
    public void solve() throws Exception {
        File targetFile = new File(webGoatHomeDirectory, ""/XXE/"" + webSession.getUserName() + ""/secret.txt"");
        //Host DTD on WebWolf site
        String dtd = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +","Read this.webGoatHomeDirectory()","src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java","BlindSendFileAssignmentTest.java",89,"    @Test
    public void solve() throws Exception {
        File targetFile = new File(webGoatHomeDirectory, ""/XXE/"" + webSession.getUserName() + ""/secret.txt"");
        //Host DTD on WebWolf site
        String dtd = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +","java.io.File.File()","공격자는 BlindSendFileAssignmentTest.java의 89 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",F795B5B1EE04FFF779A105E8414FBD1D,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7.java","Assignment7.java",67,"            String username = email.substring(0, email.indexOf(""@""));
            if (StringUtils.hasText(username)) {
                URI uri = new URI(request.getRequestURL().toString());
                Email mail = Email.builder()
                        .title(""Your password reset link for challenge 7"")","javax.servlet.http.HttpServletRequest.getRequestURL()","src/main/java/org/owasp/webgoat/lessons/challenges/challenge7/Assignment7.java","Assignment7.java",67,"            String username = email.substring(0, email.indexOf(""@""));
            if (StringUtils.hasText(username)) {
                URI uri = new URI(request.getRequestURL().toString());
                Email mail = Email.builder()
                        .title(""Your password reset link for challenge 7"")","java.net.URI.URI()","공격자는 Assignment7.java의 67 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",A892F4DCC561B419CA80FF24D633A04E,8F3B2393-5D1E-4860-A96F-0F6E0274923F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/container/users/UserService.java","UserService.java",30,"    @Override
    public WebGoatUser loadUserByUsername(String username) throws UsernameNotFoundException {
        WebGoatUser webGoatUser = userRepository.findByUsername(username);
        if (webGoatUser == null) {
            throw new UsernameNotFoundException(""User not found"");","org.owasp.webgoat.container.users.UserRepository.findByUsername()","src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",67,"        var fileContents = ""WebGoat 8.0 rocks... ("" + randomAlphabetic(10) + "")"";
        userToFileContents.put(user, fileContents);
        File targetDirectory = new File(webGoatHomeDirectory, ""/XXE/"" + user.getUsername());
        if (!targetDirectory.exists()) {
            targetDirectory.mkdirs();","java.io.File.File()","공격자는 BlindSendFileAssignment.java의 67 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",67FE197BCC6A340CB397AACF6F4A6EE7,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java","ProfileUpload.java",28,"    @PostMapping(value = ""/PathTraversal/profile-upload"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFile"") MultipartFile file, @RequestParam(value = ""fullName"", required = false) String fullName) {
        return super.execute(file, fullName);
    }",uploadFileHandler(1),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",43,"        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();
            FileCopyUtils.copy(file.getBytes(), uploadedFile);","java.io.File.File()","공격자는 ProfileUploadBase.java의 43 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",F5C8050DD911AEF6197C9F97038A2BAD,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",36,"    @PostMapping(value = ""/PathTraversal/zip-slip"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileZipSlip"") MultipartFile file) {
        if (!file.getOriginalFilename().toLowerCase().endsWith("".zip"")) {
            return failed(this).feedback(""path-traversal-zip-slip.no-zip"").build();",uploadFileHandler(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",56,"            FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());

            ZipFile zip = new ZipFile(uploadedZipFile.toFile());
            Enumeration<? extends ZipEntry> entries = zip.entries();
            while (entries.hasMoreElements()) {","java.nio.file.Path.toFile()","공격자는 ProfileZipSlip.java의 56 줄에 있는 toFile()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",B5CC4D9BFC281A19EE73A7B1FBEFCCAF,788E3752-66EE-4EE0-8C5D-9F24DBBECEE1,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",59,"    private final Map<WebGoatUser, String> userToFileContents = new HashMap<>();

    public BlindSendFileAssignment(@Value(""${webgoat.user.directory}"") String webGoatHomeDirectory, CommentsCache comments) {
        this.webGoatHomeDirectory = webGoatHomeDirectory;
        this.comments = comments;",BlindSendFileAssignment(0),"src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java","BlindSendFileAssignment.java",67,"        var fileContents = ""WebGoat 8.0 rocks... ("" + randomAlphabetic(10) + "")"";
        userToFileContents.put(user, fileContents);
        File targetDirectory = new File(webGoatHomeDirectory, ""/XXE/"" + user.getUsername());
        if (!targetDirectory.exists()) {
            targetDirectory.mkdirs();","java.io.File.File()","공격자는 BlindSendFileAssignment.java의 67 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",08A9340FFDBB75BAE225CEB7DF68CDFF,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java","ProfileUpload.java",22,"public class ProfileUpload extends ProfileUploadBase {

    public ProfileUpload(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUpload(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",75,"
    protected byte[] getProfilePictureAsBase64() {
        var profilePictureDirectory = new File(this.webGoatHomeDirectory, ""/PathTraversal/"" + webSession.getUserName());
        var profileDirectoryFiles = profilePictureDirectory.listFiles();
","java.io.File.File()","공격자는 ProfileUploadBase.java의 75 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",6BE3625FBA2D75101C3662E751B074B7,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",47,"
    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();
    }","java.io.File.File()","공격자는 ProfileUploadRetrieval.java의 47 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",540A4D6982DE29B8A3F762DB51FA0058,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java","BlindSendFileAssignmentTest.java",79,"    @Test
    public void simpleXXEShouldNotWork() throws Exception {
        File targetFile = new File(webGoatHomeDirectory, ""/XXE/"" + webSession.getUserName() + ""/secret.txt"");
        String content = ""<?xml version=\""1.0\"" standalone=\""yes\"" ?><!DOCTYPE user [<!ENTITY root SYSTEM \""file:///%s\""> ]><comment><text>&root;</text></comment>"";
        mockMvc.perform(MockMvcRequestBuilders.post(""/xxe/blind"")","Read this.webGoatHomeDirectory()","src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java","BlindSendFileAssignmentTest.java",79,"    @Test
    public void simpleXXEShouldNotWork() throws Exception {
        File targetFile = new File(webGoatHomeDirectory, ""/XXE/"" + webSession.getUserName() + ""/secret.txt"");
        String content = ""<?xml version=\""1.0\"" standalone=\""yes\"" ?><!DOCTYPE user [<!ENTITY root SYSTEM \""file:///%s\""> ]><comment><text>&root;</text></comment>"";
        mockMvc.perform(MockMvcRequestBuilders.post(""/xxe/blind"")","java.io.File.File()","공격자는 BlindSendFileAssignmentTest.java의 79 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",667DCBF3D0F7FAD5EC69034B703BC25F,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/container/WebGoat.java","WebGoat.java",55,"
    @Bean(name = ""pluginTargetDirectory"")
    public File pluginTargetDirectory(@Value(""${webgoat.user.directory}"") final String webgoatHome) {
        return new File(webgoatHome);
    }",pluginTargetDirectory(0),"src/main/java/org/owasp/webgoat/container/WebGoat.java","WebGoat.java",56,"    @Bean(name = ""pluginTargetDirectory"")
    public File pluginTargetDirectory(@Value(""${webgoat.user.directory}"") final String webgoatHome) {
        return new File(webgoatHome);
    }
","java.io.File.File()","공격자는 WebGoat.java의 56 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",6371CA732CC34C9D8F1EED44315CD105,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",85,"        }
        try {
            var id = request.getParameter(""id"");
            var catPicture = new File(catPicturesDirectory, (id == null ? RandomUtils.nextInt(1, 11) : id) + "".jpg"");
","javax.servlet.ServletRequest.getParameter()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",100,"            }
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {","java.net.URI.URI()","공격자는 ProfileUploadRetrieval.java의 100 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",3E0F149F2CD2A130515BC000124DE7F8,8F3B2393-5D1E-4860-A96F-0F6E0274923F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",61,"    @GetMapping(""/WebWolf/landing/password-reset"")
    public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {
        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);","javax.servlet.http.HttpServletRequest.getRequestURL()","src/main/java/org/owasp/webgoat/lessons/webwolfintroduction/LandingAssignment.java","LandingAssignment.java",61,"    @GetMapping(""/WebWolf/landing/password-reset"")
    public ModelAndView openPasswordReset(HttpServletRequest request) throws URISyntaxException {
        URI uri = new URI(request.getRequestURL().toString());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(""webwolfUrl"", landingPageUrl);","java.net.URI.URI()","공격자는 LandingAssignment.java의 61 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",C460ABBFE2E59CBC84917717F2281335,8F3B2393-5D1E-4860-A96F-0F6E0274923F,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java","BlindSendFileAssignmentTest.java",113,"    @Test
    public void solveOnlyParamReferenceEntityInExternalDTD() throws Exception {
        File targetFile = new File(webGoatHomeDirectory, ""/XXE/"" + webSession.getUserName() + ""/secret.txt"");
        //Host DTD on WebWolf site
        String dtd = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +","Read this.webGoatHomeDirectory()","src/test/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignmentTest.java","BlindSendFileAssignmentTest.java",113,"    @Test
    public void solveOnlyParamReferenceEntityInExternalDTD() throws Exception {
        File targetFile = new File(webGoatHomeDirectory, ""/XXE/"" + webSession.getUserName() + ""/secret.txt"");
        //Host DTD on WebWolf site
        String dtd = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +","java.io.File.File()","공격자는 BlindSendFileAssignmentTest.java의 113 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",C511D47164A052A45DF59BDDE93F429A,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",57,"
            ZipFile zip = new ZipFile(uploadedZipFile.toFile());
            Enumeration<? extends ZipEntry> entries = zip.entries();
            while (entries.hasMoreElements()) {
                ZipEntry e = entries.nextElement();","java.util.zip.ZipFile.entries()","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",60,"            while (entries.hasMoreElements()) {
                ZipEntry e = entries.nextElement();
                File f = new File(tmpZipDirectory.toFile(), e.getName());
                InputStream is = zip.getInputStream(e);
                Files.copy(is, f.toPath(), StandardCopyOption.REPLACE_EXISTING);","java.io.File.File()","공격자는 ProfileZipSlip.java의 60 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",953DB6D38309B8C16197BCC4252A3920,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",30,"public class ProfileZipSlip extends ProfileUploadBase {

    public ProfileZipSlip(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileZipSlip(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",47,"    private AttackResult processZipUpload(MultipartFile file) {
        var tmpZipDirectory = Files.createTempDirectory(getWebSession().getUserName());
        var uploadDirectory = new File(getWebGoatHomeDirectory(), ""/PathTraversal/"" + getWebSession().getUserName());
        var currentImage = getProfilePictureAsBase64();
","java.io.File.File()","공격자는 ProfileZipSlip.java의 47 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",F22635C3F6187125B72EB14984B3EBF4,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",74,"    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());
        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));","Read this.fileLocation()","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",74,"    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());
        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));","java.io.File.File()","공격자는 FileServer.java의 74 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",F371FDB62617121E74498D3B3B52AFA5,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",72,"
    @PostMapping(value = ""/fileupload"")
    public ModelAndView importFile(@RequestParam(""file"") MultipartFile myFile) throws IOException {
        var user = (WebGoatUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        var destinationDir = new File(fileLocation, user.getUsername());",importFile(0),"src/main/java/org/owasp/webgoat/webwolf/FileServer.java","FileServer.java",77,"        destinationDir.mkdirs();
        myFile.transferTo(new File(destinationDir, myFile.getOriginalFilename()));
        log.debug(""File saved to {}"", new File(destinationDir, myFile.getOriginalFilename()));

        return new ModelAndView(","java.io.File.File()","공격자는 FileServer.java의 77 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",A5451D6D582DE0039606DA329D686AF9,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입",".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",62,"                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {","java.util.Properties.load()",".mvn/wrapper/MavenWrapperDownloader.java","MavenWrapperDownloader.java",108,"            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());","java.net.URL.URL()","공격자는 MavenWrapperDownloader.java의 108 줄에 있는 URL()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",B0B0614294D0FD1F5D1369365CAC184D,2DEE27D8-C41F-48FC-8B40-FA60B403AEAE,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",36,"    @PostMapping(value = ""/PathTraversal/zip-slip"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileZipSlip"") MultipartFile file) {
        if (!file.getOriginalFilename().toLowerCase().endsWith("".zip"")) {
            return failed(this).feedback(""path-traversal-zip-slip.no-zip"").build();",uploadFileHandler(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java","ProfileZipSlip.java",53,"
        try {
            var uploadedZipFile = tmpZipDirectory.resolve(file.getOriginalFilename());
            FileCopyUtils.copy(file.getBytes(), uploadedZipFile.toFile());
","java.nio.file.Path.resolve()","공격자는 ProfileZipSlip.java의 53 줄에 있는 resolve()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",D68CC19B38ECE61F9DA754BA2D186E4D,6138BBAF-C3B7-4EDC-A8CB-D44308310F85,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",61,"    public void copyFiles() {
        ClassPathResource classPathResource = new ClassPathResource(""lessons/employees.xml"");
        File targetDirectory = new File(webGoatHomeDirectory, ""/ClientSideFiltering"");
        if (!targetDirectory.exists()) {
            targetDirectory.mkdir();","Read this.webGoatHomeDirectory()","src/main/java/org/owasp/webgoat/lessons/clientsidefiltering/Salaries.java","Salaries.java",61,"    public void copyFiles() {
        ClassPathResource classPathResource = new ClassPathResource(""lessons/employees.xml"");
        File targetDirectory = new File(webGoatHomeDirectory, ""/ClientSideFiltering"");
        if (!targetDirectory.exists()) {
            targetDirectory.mkdir();","java.io.File.File()","공격자는 Salaries.java의 61 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",AD9B232BDA422C11F1E9163BF8F479DF,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUpload.java","ProfileUpload.java",22,"public class ProfileUpload extends ProfileUploadBase {

    public ProfileUpload(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUpload(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",36,"        }

        var uploadDirectory = new File(this.webGoatHomeDirectory, ""/PathTraversal/"" + webSession.getUserName());
        if (uploadDirectory.exists()) {
            FileSystemUtils.deleteRecursively(uploadDirectory);","java.io.File.File()","공격자는 ProfileUploadBase.java의 36 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",D69F0045EB16680918C01D93F48FCDF1,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
High,High,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadFix.java","ProfileUploadFix.java",22,"public class ProfileUploadFix extends ProfileUploadBase {

    public ProfileUploadFix(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory, WebSession webSession) {
        super(webGoatHomeDirectory, webSession);
    }",ProfileUploadFix(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",75,"
    protected byte[] getProfilePictureAsBase64() {
        var profilePictureDirectory = new File(this.webGoatHomeDirectory, ""/PathTraversal/"" + webSession.getUserName());
        var profileDirectoryFiles = profilePictureDirectory.listFiles();
","java.io.File.File()","공격자는 ProfileUploadBase.java의 75 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",A1CE96EAD145969665279C4C06C74769,823FE039-A7FE-4AAD-B976-9EC53FFE4A59,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",100,"            }
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                    .body(StringUtils.arrayToCommaDelimitedString(catPicture.getParentFile().listFiles()).getBytes());
        } catch (IOException | URISyntaxException e) {","java.net.URI.URI()","공격자는 ProfileUploadRetrieval.java의 100 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",4C7FA25C3E9DAB901524C9049A201EAA,8F3B2393-5D1E-4860-A96F-0F6E0274923F,,,,Fri May 31 16:52:25 KST 2024,
Critical,Critical,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRemoveUserInput.java","ProfileUploadRemoveUserInput.java",26,"    @PostMapping(value = ""/PathTraversal/profile-upload-remove-user-input"", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
    @ResponseBody
    public AttackResult uploadFileHandler(@RequestParam(""uploadedFileRemoveUserInput"") MultipartFile file) {
        return super.execute(file, file.getOriginalFilename());
    }",uploadFileHandler(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java","ProfileUploadBase.java",43,"        try {
            uploadDirectory.mkdirs();
            var uploadedFile = new File(uploadDirectory, fullName);
            uploadedFile.createNewFile();
            FileCopyUtils.copy(file.getBytes(), uploadedFile);","java.io.File.File()","공격자는 ProfileUploadBase.java의 43 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",41CFF3A025C0D6E58F750C96E65167CB,138700B9-C625-4262-9826-C8F3450D6838,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",46,"    private final File catPicturesDirectory;

    public ProfileUploadRetrieval(@Value(""${webgoat.server.directory}"") String webGoatHomeDirectory) {
        this.catPicturesDirectory = new File(webGoatHomeDirectory, ""/PathTraversal/"" + ""/cats"");
        this.catPicturesDirectory.mkdirs();",ProfileUploadRetrieval(0),"src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java","ProfileUploadRetrieval.java",96,"                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(MediaType.IMAGE_JPEG_VALUE))
                        .location(new URI(""/PathTraversal/random-picture?id="" + catPicture.getName()))
                        .body(Base64.getEncoder().encode(FileCopyUtils.copyToByteArray(catPicture)));
            }","java.net.URI.URI()","공격자는 ProfileUploadRetrieval.java의 96 줄에 있는 URI()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",4C7FA25C3E9DAB901524C9049A201EA9,8F3B2393-5D1E-4860-A96F-0F6E0274923F,,,,Fri May 31 16:52:25 KST 2024,
Low,Low,Input Validation and Representation,"01.03. 경로 조작 및 자원 삽입","src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",46,"    @PostMapping(""/SSRF/task2"")
    @ResponseBody
    public AttackResult completed(@RequestParam String url) {
        return furBall(url);
    }",completed(0),"src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java","SSRFTask2.java",53,"        if (url.matches(""http://ifconfig.pro"")) {
            String html;
            try (InputStream in = new URL(url).openStream()) {
                html = new String(in.readAllBytes(), StandardCharsets.UTF_8)
                        .replaceAll(""\n"",""<br>""); // Otherwise the \n gets escaped in the response","java.net.URL.URL()","공격자는 SSRFTask2.java의 53 줄에 있는 URL()의 리소스 ID 인수를 제어할 수 있습니다. 그렇지 않을 때 보호할 수 있는 시스템 리소스를 공격자가 접근하거나 수정할 수 있습니다.","공격자는 MavenWrapperDownloader.java의 50 줄에 있는 File()의 파일 시스템 경로 인수를 제어할 수 있습니다. 그렇지 않으면 보호할 수 있는 파일을 공격자가 접근하거나 수정할 수 있습니다.","Path manipulation 오류는 다음 두 가지 조건을 만족할 때 발생합니다.

1. 공격자가 파일 시스템상의 작업에 사용되는 경로를 지정할 수 있습니다.

2. 공격자가 리소스를 지정하여 다른 방법으로는 허용되지 않는 권한을 얻습니다.

예를 들어, 프로그램이 공격자에게 지정한 파일을 덮어쓰거나 공격자가 제어하는 구성으로 실행할 수 있는 권한을 주는 것입니다.


예제 1: 다음 코드는 HTTP 요청의 입력을 사용하여 파일 이름을 만듭니다. 프로그래머는 공격자가 ""../../tomcat/conf/server.xml"" 등의 파일 이름을 제공하여 응용 프로그램이 자신의 구성 파일을 삭제하게 만들 가능성을 고려하지 않았습니다.


String rName = request.getParameter(""reportName"");
File rFile = new File(""/usr/local/apfr/reports/"" + rName);
...
rFile.delete();


예제 2: 다음 코드는 구성 파일의 입력을 사용하여 열 파일을 결정하고 사용자에게 돌려 보냅니다. 프로그램이 일정한 권한으로 실행되고 악의적인 사용자가 구성 파일을 변경할 수 있는 경우, 이 프로그램을 사용하여 시스템에서 확장명이 .txt인 파일을 읽을 수 있습니다.


fis = new FileInputStream(cfg.getProperty(""sub"")+"".txt"");
amt = fis.read(arr);
out.println(arr);


모바일 환경에서는 Path manipulation과 같은 전형적인 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        String rName = this.getIntent().getExtras().getString(""reportName"");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
","Path Manipulation을 예방하는 최선의 방법은 사용자가 선택해야 하는 올바른 값 목록을 생성하는 간접 참조를 사용하는 것입니다. 이 접근 방식을 사용하면 사용자 제공 입력이 리소스 이름을 지정하는 데 직접 사용되지 않습니다.

경우에 따라 올바른 리소스 이름 집합이 너무 크거나 유지 관리가 어렵기 때문에 이 접근 방식은 실용적이지 못합니다. 이때 프로그래머는 주로 거부 목록을 구현합니다. 거부 목록은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리하는 데 사용됩니다. 하지만 안전하지 않은 문자의 목록은 불완전할 가능성이 크고 대부분 최신 상태를 유지하지 못합니다. 효율적인 접근 방식은 리소스 이름에 사용할 수 있는 문자의 목록을 만들어 목록에 있는 문자만으로 이루어진 입력만 받는 것입니다.","1. 프로그램에서 수행한 사용자 지정 입력값 검증에 만족하는 경우 Fortify Custom Rules Editor를 사용하여 검증 루틴에 대한 정리 규칙을 작성합니다.

2. 효과적인 거부 목록을 구현하는 작업은 매우 어렵습니다. 검증 논리에 거부 목록을 구현해야 할 때는 신중해야 합니다. 다른 운영 체제, 데이터베이스 또는 기타 리소스에서 해석될 때 특수한 의미를 가질 수 있는 다른 메타 문자 집합 및 다른 유형의 입력 인코딩을 고려해 보십시오. 이 요구 사항이 끊임없이 변한다면 과연 거부 목록을 쉽고 정확하고 완전하게 업데이트할 수 있을 것인지 판단해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",DBC5851984DD5F18E9B515DA136B5372,2DEE27D8-C41F-48FC-8B40-FA60B403AEAE,,,,Fri May 31 16:52:25 KST 2024,
