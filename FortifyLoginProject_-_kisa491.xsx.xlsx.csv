위험도,폴더,대분류,취약점,위험인자 진입 파일경로,위험인자 진입 파일명,위험인자 진입 라인넘버,위험인자 진입 소스조각,위험인자 진입 함수,취약점 탐지 파일경로,취약점 탐지 파일명,취약점 탐지 라인넘버,취약점 탐지 소스조각,취약점 탐지 함수,취약점 이슈 개요,취약점 개요,취약점 설명,취약점 조치 권고내용,취약점 조치 tip,취약점 이슈 고유키,취약점 rule 고유키,auditor 태그,auditor 아이디,auditor 의견,스캔시간,
Critical,Critical,Input Validation and Representation,<none>,"src/adrui/registerServlet.java","registerServlet.java",44,"		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");
		Connection conn = (Connection)(getServletContext().getAttribute(""conn""));","javax.servlet.ServletRequest.getParameter()","src/adrui/registerServlet.java","registerServlet.java",64,"				System.out.println(""f = true"");
				sql = ""insert into user values('"" + sno + ""', '"" + user + ""', '"" + pass + ""')"";
				state.executeUpdate(sql);		
				
			}","java.sql.Statement.executeUpdate()","registerServlet.java의 64 줄에서 doPost() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,7979A68DB1EB9D685F539D165EC5EE29,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 14:38:54 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/adrui/registerServlet.java","registerServlet.java",45,"		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");
		Connection conn = (Connection)(getServletContext().getAttribute(""conn""));
		try{","javax.servlet.ServletRequest.getParameter()","src/adrui/registerServlet.java","registerServlet.java",64,"				System.out.println(""f = true"");
				sql = ""insert into user values('"" + sno + ""', '"" + user + ""', '"" + pass + ""')"";
				state.executeUpdate(sql);		
				
			}","java.sql.Statement.executeUpdate()","registerServlet.java의 64 줄에서 doPost() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,08D07C1407753721CFABDE9FE7DFE2CF,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,API Abuse,<none>,"src/adrui/registerServlet.java","registerServlet.java",45,"		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");
		Connection conn = (Connection)(getServletContext().getAttribute(""conn""));
		try{","javax.servlet.ServletRequest.getParameter()","src/adrui/MyContextListener.java","MyContextListener.java",28,"		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute(""conn"", conn);
			System.out.println(""Connect Succeed!"");",getConnection(),"J2EE 표준은 직접적인 연결 관리를 금지합니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,E4385F2C90FC80BDADB7174333CB0B19,EDD8E0B5-D8F2-4F56-A20B-549E3880318B,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Environment,<none>,"src/adrui/registerServlet.java","registerServlet.java",45,"		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");
		Connection conn = (Connection)(getServletContext().getAttribute(""conn""));
		try{","javax.servlet.ServletRequest.getParameter()","WEB-INF/web.xml","web.xml",2,"<?xml version=""1.0"" encoding=""UTF-8""?>
<web-app xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://java.sun.com/xml/ns/javaee"" xsi:schemaLocation=""http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"" id=""WebApp_ID"" version=""3.0"">
  <display-name>LoginProject</display-name>
  <welcome-file-list>",getConnection(),"지나치게 긴 세션 시간 초과는 공격자에게 사용자 계정을 잠재적으로 손상시킬 수 있는 시간을 더 많이 제공합니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,C2F39B963AB1AFACD8D57325EEAF747F,B7ED276F-524D-444B-8930-7D77535BF0D0,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/adrui/registerServlet.java","registerServlet.java",45,"		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");
		Connection conn = (Connection)(getServletContext().getAttribute(""conn""));
		try{","javax.servlet.ServletRequest.getParameter()","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){",executeQuery(),"LoginModel.java의 9 줄에서 check() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,E05BD34011271AF74D20BA4CC2F53A2E,4B673A45-9AD5-4CBA-945B-11A3702CDF57,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,<none>,"src/adrui/registerServlet.java","registerServlet.java",45,"		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");
		Connection conn = (Connection)(getServletContext().getAttribute(""conn""));
		try{","javax.servlet.ServletRequest.getParameter()","src/adrui/registerServlet.java","registerServlet.java",62,"			if(f){
				res = ""true"";
				System.out.println(""f = true"");
				sql = ""insert into user values('"" + sno + ""', '"" + user + ""', '"" + pass + ""')"";
				state.executeUpdate(sql);		",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,3634AD4EBCD44C770289CB4C84EFC8FC,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Input Validation and Representation,<none>,"src/adrui/MyContextListener.java","MyContextListener.java",22,"		// TODO Auto-generated method stub
		ServletContext sc = event.getServletContext();
		String driver = sc.getInitParameter(""driver"");
		String url = sc.getInitParameter(""url"");
		String user = sc.getInitParameter(""user"");","javax.servlet.ServletContext.getInitParameter()","src/adrui/MyContextListener.java","MyContextListener.java",27,"		String pass = sc.getInitParameter(""pass"");
		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute(""conn"", conn);","java.lang.Class.forName()","공격자가 MyContextListener.java의 27 줄에서 forName() 리플렉션 메서드의 인수를 제어할 수 있습니다. 이로 인해 응용 프로그램을 통해 예기치 못한 제어 흐름 경로를 만들어 보안 검사를 무시할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,5BA1400984294C9BF4B7411857C65201,E1B32227-C0BD-4A57-9C34-6794D9089A21,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,<none>,"src/adrui/MyContextListener.java","MyContextListener.java",22,"		// TODO Auto-generated method stub
		ServletContext sc = event.getServletContext();
		String driver = sc.getInitParameter(""driver"");
		String url = sc.getInitParameter(""url"");
		String user = sc.getInitParameter(""user"");","javax.servlet.ServletContext.getInitParameter()","src/adrui/MyContextListener.java","MyContextListener.java",30,"			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute(""conn"", conn);
			System.out.println(""Connect Succeed!"");
		}
		catch(Exception e){",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,88008082069DDB8934BAC242EE9E27DD,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 14:38:54 KST 2024,
Critical,Critical,Input Validation and Representation,<none>,"src/adrui/registerServlet.java","registerServlet.java",43,"		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");","javax.servlet.ServletRequest.getParameter()","src/adrui/registerServlet.java","registerServlet.java",64,"				System.out.println(""f = true"");
				sql = ""insert into user values('"" + sno + ""', '"" + user + ""', '"" + pass + ""')"";
				state.executeUpdate(sql);		
				
			}","java.sql.Statement.executeUpdate()","registerServlet.java의 64 줄에서 doPost() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,9147C5CEBDA6DE4FE869C32D0183E3F5,E04D3E1F-2D8C-400A-BB55-7DA143F987E3,,,,Fri May 31 14:38:54 KST 2024,
High,High,Security Features,<none>,"src/adrui/registerServlet.java","registerServlet.java",43,"		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");","javax.servlet.ServletRequest.getParameter()","register.html","register.html",39,"    <span>??: <input onmouseout = ""SnoCheck()""  id=""Sno""  type=""text"" name=""Sno"" /><p id=""1""></p><br/><br/></span>
    <span>??: <input onmouseout = ""UserCheck()"" id=""User"" type=""text"" name=""LoginUser"" ></input><p id=""2""></p><br/><br/></span>
    <span>密?: <input onmouseout = ""PassCheck()"" id=""Pass"" type=""password"" name=""LoginPass"" ></input><br/><br/><p id=""3""></p></span>
    <span style=""margin-left: 218px;"">??密?: <input onmouseout = ""PassTwoCheck()"" id = ""PassTwo"" type=""password"" name=""PassTwo"" ></input><br/><br/><p id=""4""></p></span>
   <br/><br/><br/> ","java.sql.Statement.executeUpdate()","register.html의 형식은 39 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,CA9E64516D6FCAE0C54C2ED7EF6704A2,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 14:38:54 KST 2024,
High,High,Security Features,<none>,"src/adrui/registerServlet.java","registerServlet.java",43,"		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");","javax.servlet.ServletRequest.getParameter()","register.html","register.html",40,"    <span>??: <input onmouseout = ""UserCheck()"" id=""User"" type=""text"" name=""LoginUser"" ></input><p id=""2""></p><br/><br/></span>
    <span>密?: <input onmouseout = ""PassCheck()"" id=""Pass"" type=""password"" name=""LoginPass"" ></input><br/><br/><p id=""3""></p></span>
    <span style=""margin-left: 218px;"">??密?: <input onmouseout = ""PassTwoCheck()"" id = ""PassTwo"" type=""password"" name=""PassTwo"" ></input><br/><br/><p id=""4""></p></span>
   <br/><br/><br/> 
    <span><input id = ""submit"" disabled style=""width: 452px;color: #fff;background: #999;"" type=""submit"" value=""立?注?""/></span>","java.sql.Statement.executeUpdate()","register.html의 형식은 40 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,CA9E64516D6FCAE0C54C2ED7EF6704A3,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,<none>,"src/adrui/registerServlet.java","registerServlet.java",43,"		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");","javax.servlet.ServletRequest.getParameter()","src/adrui/LoginServlet.java","LoginServlet.java",40,"	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println(""Login Test"");
		String user = request.getParameter(""user"");
		String pass = request.getParameter(""pass"");",FunctionCall: println(),"전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,62793514B5C14E58E34A6C82F6EAA2FC,F972FE42-6C15-47D2-BD5C-448166A574C2,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Environment,<none>,"src/adrui/registerServlet.java","registerServlet.java",43,"		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");","javax.servlet.ServletRequest.getParameter()","WEB-INF/web.xml","web.xml",2,"<?xml version=""1.0"" encoding=""UTF-8""?>
<web-app xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://java.sun.com/xml/ns/javaee"" xsi:schemaLocation=""http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"" id=""WebApp_ID"" version=""3.0"">
  <display-name>LoginProject</display-name>
  <welcome-file-list>",/web-app(),"웹 응용 프로그램은 기본 오류 페이지를 정의하여 공격자가 응용 프로그램 컨테이너의 기본 제공 오류 응답의 정보를 빼내는 것을 방지해야 합니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,399A248E35AE0FBB04255DE45FA9754C,749BCC9F-FE61-4DC0-9EF2-5EF1872C7717,,,,Fri May 31 14:38:54 KST 2024,
High,High,Security Features,<none>,"src/adrui/registerServlet.java","registerServlet.java",43,"		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter(""Sno"");
		String user = request.getParameter(""LoginUser"");
		String pass = request.getParameter(""LoginPass"");","javax.servlet.ServletRequest.getParameter()","login.jsp","login.jsp",28,"    		<center>??¨æ?·????½?</center><br/><br/>
    		USER: <br/> <input type=""text"" name=""user""></input><br/><br/>
    		PASS: <br/><input type=""password"" name=""pass""></input>
    		<br/>
    		<br/>",/web-app(),"login.jsp의 형식은 28 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,62722A3F75BE81ECDF3ACB69E695990A,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,<none>,"src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/LoginServlet.java","LoginServlet.java",48,"		try{
			String res = obj.check(conn, user, pass);
			request.setAttribute(""res"", res);
		//	request.setAttribute(""Sno"", sno);
			RequestDispatcher view = request.getRequestDispatcher(""login.jsp"");","javax.servlet.ServletRequest.setAttribute()","LoginServlet.java의 doPost() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,EC5C8978193E476E43268D652AE9A30E,CBDB6290-DF73-42E1-8D9E-3B5C4B629761,,,,Fri May 31 14:38:54 KST 2024,
High,High,Security Features,<none>,"src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","login.html","login.html",19,"        <center>用?登?</center><br/><br/>
        USER: <br/> <input type=""text"" name=""user""></input><br/><br/>
        PASS: <br/><input type=""password"" name=""pass""></input>
        <br/>
        <br/>","javax.servlet.ServletRequest.setAttribute()","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.","자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.","폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 ""내 암호 저장"" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"" autocomplete=""off"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" />
  </form>


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  <form method=""post"">
        Address: <input name=""address"" />
        Password: <input name=""password"" type=""password"" autocomplete=""off""/>
  </form>


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.",,DA87A9C902D54BAADFCA48C96419F2F2,2FC7D1FF-11E4-468E-B7AB-F127828F4016,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/LoginServlet.java","LoginServlet.java",30,"	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append(""Served at: "").append(request.getContextPath());",Function: doGet(),"LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,0D85D8B3021CC15E7F4434F4B9EFED84,97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/LoginServlet.java","LoginServlet.java",38,"	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println(""Login Test"");",Function: doPost(),"LoginServlet Servlet은 doPost()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,D1CED827D763E2CF7E0809CC14ED711D,97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/registerServlet.java","registerServlet.java",72,"		}
		catch(Exception e){
			e.printStackTrace();
		}
	}",printStackTrace(),"registerServlet.java의 doPost() 함수는 72 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,53EE9CDA46A819785E847488896323C2,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/registerServlet.java","registerServlet.java",32,"	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append(""Served at: "").append(request.getContextPath());",Function: doGet(),"registerServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,4C80BB31FC4828FD5B90F74DBFB384F9,97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/LoginServlet.java","LoginServlet.java",54,"		}
		catch(Exception e){
			e.printStackTrace();
		}
	}",printStackTrace(),"LoginServlet.java의 doPost() 함수는 54 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,08BD92B58521B0F455A66A26EE6288E1,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/registerServlet.java","registerServlet.java",40,"	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		//doGet(request, response);",Function: doPost(),"registerServlet Servlet은 doPost()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,FCCFD957687589A021B1ADD593FB3FD6,97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"04.01. 오류메시지 통한 정보 노출","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","src/adrui/MyContextListener.java","MyContextListener.java",33,"		}
		catch(Exception e){
			e.printStackTrace();
		}
	}",printStackTrace(),"MyContextListener.java의 contextInitialized() 함수는 33 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.","LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.","Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println(""hello "" + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 ""name""이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter(""name"");
    ...
    out.println(""hello "" + name.trim());
}
","모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println(""hello "" + addr.getHostName());
      }catch (Throwable t) {
          logger.error(""caught throwable at top level"", t);
      }
  }
}
",,0DD8B02E4BFE39436C2920BB34F94924,FE4EADF2-7055-4C36-863E-5A01C4A0E1A4,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Security Features,"02.09. 취약한 비밀번호 허용","src/adrui/MyContextListener.java","MyContextListener.java",25,"		String url = sc.getInitParameter(""url"");
		String user = sc.getInitParameter(""user"");
		String pass = sc.getInitParameter(""pass"");
		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度","javax.servlet.ServletContext.getInitParameter()","src/adrui/MyContextListener.java","MyContextListener.java",28,"		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute(""conn"", conn);
			System.out.println(""Connect Succeed!"");","java.sql.DriverManager.getConnection()","MyContextListener.java의 contextInitialized() 메서드는 28 줄의 일반 텍스트 암호를 사용합니다. 암호를 일반 텍스트로 저장하면 시스템 침해가 발생할 수 있습니다.","MyContextListener.java의 contextInitialized() 메서드는 28 줄의 일반 텍스트 암호를 사용합니다. 암호를 일반 텍스트로 저장하면 시스템 침해가 발생할 수 있습니다.","Password management 이슈는 암호를 응용 프로그램의 속성 또는 구성 파일에 일반 텍스트로 저장할 때 발생합니다. 

예제 1: 다음 코드는 속성 파일에서 암호를 읽어 이 암호를 사용하여 데이터베이스에 연결합니다.


...
Properties prop = new Properties();
prop.load(new FileInputStream(""config.properties""));
String password = prop.getProperty(""password"");

DriverManager.getConnection(url, usr, password);
...


이 코드는 올바로 실행되지만 config.properties에 대한 액세스 권한이 있는 사용자면 누구나 password의 값을 읽을 수 있습니다. 비양심적인 직원이 이 정보에 대한 액세스 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 Android WebView 저장소에서 사용자 이름과 암호를 읽은 다음 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    handler.proceed(username, password);
  }
});
...


WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 따라서 사용자가 루팅된 장치나 에뮬레이터를 사용하는 경우 지정된 사이트에 저장된 암호를 읽을 수 있습니다.","암호를 일반 텍스트로 저장해서는 안 됩니다. 시스템이 시작될 때 관리자에게 암호를 입력하도록 요구해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다. 최소한 암호를 저장하기 전에 해시해야 합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 따라서 암호화된 데이터베이스에 자격 증명을 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath(""credentials.db"");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, ""credentials"", null);
  db.execSQL(""create table credentials(u, p)"");
  db.execSQL(""insert into credentials(u, p) values(?, ?)"", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.","1. Fortify Secure Coding Rulepacks는 암호를 인수로 사용하는 것으로 알려진 함수를 찾아 암호 관리 이슈를 식별합니다. 암호가 프로그램 외부에서 제공되며 식별된 난독 처리 해제 루틴을 통과하지 않고 사용되는 경우 Fortify Static Code Analyzer는 암호 관리 이슈 플래그를 지정합니다.

Password Management 이슈를 감사하려면 암호가 시스템에 입력되는 지점부터 암호를 사용하는 지점까지 프로그램을 추적합니다. 난독 처리 해제를 수행하는 코드를 찾습니다. 난독 처리 해제 코드가 없으면 이 이슈는 해결되지 않은 것입니다. 암호가 난독 처리 해제 함수를 통과하는 경우 암호를 보호하는 데 사용하는 알고리즘이 견고한지 확인합니다.

암호가 제대로 보호된다고 확신하면 암호가 난독 처리로 보호되고 있음을 나타내는 난독 처리 해제 루틴에 대한 사용자 지정 통과 규칙(pass-through rule)을 작성합니다. 이 규칙을 향후 응용 프로그램 분석에 포함시키면 식별된 난독 처리 해제 루틴을 통과한 암호는 더 이상 Password Management 취약점을 일으키지 않습니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Struts 2 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.",88F5DB5C1FEF4C0BCA0EDC265177D3F9,E05C0DB1-F798-4A77-9A6A-42ACEBA215E6,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/adrui/MyContextListener.java","MyContextListener.java",25,"		String url = sc.getInitParameter(""url"");
		String user = sc.getInitParameter(""user"");
		String pass = sc.getInitParameter(""pass"");
		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度","javax.servlet.ServletContext.getInitParameter()","login.jsp","login.jsp",25,"			window.onload=show;
		</script>
		<form style=""margin:auto;"" action=""login.do"" method=""POST"">
    		<center>??¨æ?·????½?</center><br/><br/>
    		USER: <br/> <input type=""text"" name=""user""></input><br/><br/>","java.sql.DriverManager.getConnection()","login.jsp 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","login.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같은 폼을 제출하여 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


<form method=""POST"" action=""/new_user"" >
  Name of new user: <input type=""text"" name=""username"">
  Password for new user: <input type=""password"" name=""user_passwd"">
    <input type=""submit"" name=""action"" value=""Create User"">
</form>


공격자는 다음과 같이 웹 사이트를 설정할 수도 있습니다.


<form method=""POST"" action=""http://www.example.com/new_user"">
  <input type=""hidden"" name=""username"" value=""hacker"">
  <input type=""hidden"" name=""user_passwd"" value=""hacked"">
</form>
<script>
  document.usr_form.submit();
</script>


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.
","1. Fortify Static Code Analyzer는 GET 또는 POST 작업을 수행할 가능성이 있는 모든 HTML 양식 및 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 양식이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",56FB5AE4E7E9BB62980D1AA7A3D90A86,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/adrui/MyContextListener.java","MyContextListener.java",25,"		String url = sc.getInitParameter(""url"");
		String user = sc.getInitParameter(""user"");
		String pass = sc.getInitParameter(""pass"");
		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度","javax.servlet.ServletContext.getInitParameter()","login.html","login.html",16,"    </div>    -->

    <form  style=""margin: auto;"" action=""login.do"" method=""POST"">
        <center>用?登?</center><br/><br/>
        USER: <br/> <input type=""text"" name=""user""></input><br/><br/>","java.sql.DriverManager.getConnection()","login.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","login.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같은 폼을 제출하여 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


<form method=""POST"" action=""/new_user"" >
  Name of new user: <input type=""text"" name=""username"">
  Password for new user: <input type=""password"" name=""user_passwd"">
    <input type=""submit"" name=""action"" value=""Create User"">
</form>


공격자는 다음과 같이 웹 사이트를 설정할 수도 있습니다.


<form method=""POST"" action=""http://www.example.com/new_user"">
  <input type=""hidden"" name=""username"" value=""hacker"">
  <input type=""hidden"" name=""user_passwd"" value=""hacked"">
</form>
<script>
  document.usr_form.submit();
</script>


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.
","1. Fortify Static Code Analyzer는 GET 또는 POST 작업을 수행할 가능성이 있는 모든 HTML 양식 및 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 양식이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",94FAB8D7062649FD7643BA144C209D75,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 14:38:54 KST 2024,
Low,Low,Encapsulation,"01.11. 크로스사이트 요청 위조","src/adrui/MyContextListener.java","MyContextListener.java",25,"		String url = sc.getInitParameter(""url"");
		String user = sc.getInitParameter(""user"");
		String pass = sc.getInitParameter(""pass"");
		try{
			Class.forName(driver);//加???程序?, 高版本jdbc可以省去, 相?可自行百度","javax.servlet.ServletContext.getInitParameter()","register.html","register.html",36,"        <center><h1>用?信息</h1></center><br/>
    <br/><br/>
    <form action=""register.do"" method=""POST"">
    <span>??: <input onmouseout = ""SnoCheck()""  id=""Sno""  type=""text"" name=""Sno"" /><p id=""1""></p><br/><br/></span>
    <span>??: <input onmouseout = ""UserCheck()"" id=""User"" type=""text"" name=""LoginUser"" ></input><p id=""2""></p><br/><br/></span>","java.sql.DriverManager.getConnection()","register.html 파일의 36 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","login.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.","CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같은 폼을 제출하여 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


<form method=""POST"" action=""/new_user"" >
  Name of new user: <input type=""text"" name=""username"">
  Password for new user: <input type=""password"" name=""user_passwd"">
    <input type=""submit"" name=""action"" value=""Create User"">
</form>


공격자는 다음과 같이 웹 사이트를 설정할 수도 있습니다.


<form method=""POST"" action=""http://www.example.com/new_user"">
  <input type=""hidden"" name=""username"" value=""hacker"">
  <input type=""hidden"" name=""user_passwd"" value=""hacked"">
</form>
<script>
  document.usr_form.submit();
</script>


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.","세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, ""/new_user"");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.
","1. Fortify Static Code Analyzer는 GET 또는 POST 작업을 수행할 가능성이 있는 모든 HTML 양식 및 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 양식이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.",F9BBA322F3EF4182501DBA402388E4E9,78E0700E-56FE-45A2-A11B-6A560F730576,,,,Fri May 31 14:38:54 KST 2024,
Critical,Critical,Input Validation and Representation,"01.04. 크로스사이트 스크립트","src/adrui/LoginModel.java","LoginModel.java",9,"	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){","java.sql.Statement.executeQuery()","login.jsp","login.jsp",19,"			
	%>
	<p>Hello, <%= ((String)request.getAttribute(""res"")).substring(1) %></p>
	<% }else{
		%>","javax.servlet.jsp.JspWriter.print()","login.jsp의 _jspService() 메서드가 19 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","login.jsp의 _jspService() 메서드가 19 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.","XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(""select * from emp where id=""+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString(""name"");
}
%>

Employee Name: <%= name %>



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 ""방명록""을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


<% String eid = request.getParameter(""eid""); %>
...
Employee ID: <%= eid %>



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString(""url"");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
","XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- ""<""는 태그가 시작되는 표시이기 때문에 특수합니다.

- ""&""는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "">""는 일부 브라우저에서 페이지 작성자가 여는 ""<""를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- ""&""는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- ""&""는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- ""%"" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, ""%""는 ""%68%65%6C%6C%6F""와 같은 입력이 웹 페이지에 나타날 때 ""hello""가 되는 경우 필터링해야 합니다.


<SCRIPT> </SCRIPT>의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표("")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 ""<""가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.","1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 Rulepacks는 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값을 통해 Fortify는 Cross-Site Scripting: Poor Validation 취약점을 확인하게 됩니다.",B096458EEBEC91D30EA97721FF2F280D,4D69E4E2-959C-4EF8-84F4-A6489B288ABF,,,,Fri May 31 14:38:54 KST 2024,
