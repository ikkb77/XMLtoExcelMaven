<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ReportDefinition type="xml">
    <TemplateName>Fortify Security Report</TemplateName>
    <TemplatePath></TemplatePath>
    <LogoPath>/OT_logo.png</LogoPath>
    <Footnote>Copyright 2023 Open Text.</Footnote>
    <UserName>gookb</UserName>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Executive Summary</Title>
        <SubSection enabled="true">
            <Title>Issues Overview</Title>
            <Description>This section provides an overview of the issues uncovered during analysis. The report covers a summary of vulnerability categories discovered by the tool. The auditor should augment this section with higher-level conclusions derived from human review of the application (including architecture reviews, black-box testing, compliance issues, etc.)</Description>
            <Text>On Feb 13, 2024, a source code review was performed over the LoginProject code base. 15 files, 126 LOC (Executable) were scanned and reviewed for defects that could lead to potential security vulnerabilities. A total of 33 reviewed findings were uncovered during the analysis.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issue Summary by Fortify Priority Order</Title>
            <Description>A table summarizing the number of issues found and the breakdown of issues in each Fortify Priority Level</Description>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Fortify Priority Order</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="24">
                        <groupTitle>Low</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>High</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Critical</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
        <SubSection enabled="true">
            <Title>Recommendations and Conclusions</Title>
            <Description>This section gives some high-level recommendations on remediating the issues discussed in the Issues Summary sub section. Recommendations will vary based on deployment scenarios, risk appetite, and existing mitigating strategies. The auditor should supplement the Fortify generic recommendations with specific information that takes into account the application specific variables.</Description>
            <Text>The Issues Category section provides Fortify recommendations for addressing issues at a generic level.  The recommendations for specific fixes can be extrapolated from those generic recommendations by the development group.</Text>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Project Summary</Title>
        <SubSection enabled="true">
            <Title>Code Base Summary</Title>
            <Description>Summary of the Codebase that was analyzed</Description>
            <Text>Code location: C:/Users/gookb/Fortify_SCA_Samples_23.2.0/advanced/javaWebApp/LoginProject&#13;
Number of Files: 15&#13;
Lines of Code: 126&#13;
Build Label: &lt;No Build Label&gt;</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Scan Information</Title>
            <Description>Details of the analysis</Description>
            <Text>Scan time: 01:06&#13;
SCA Engine version: 23.2.0.0125&#13;
Machine Name: kbkim-lggram-14z980&#13;
Username running scan: gookb</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Results Certification</Title>
            <Description>A full summary of the Results Certification for this project</Description>
            <Text>Results Certification Valid&#13;
&#13;
Details:&#13;
&#13;
Results Signature:

	SCA Analysis Results has Valid signature
	

Rules Signature:

	There were no custom rules used in this scan</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Attack Surface</Title>
            <Description>A full summary of the attack surface for this project</Description>
            <Text>Attack Surface:&#13;
Java Properties:
	javax.servlet.ServletContext.getInitParameter

System Information:
	null.null.null
	javax.servlet.ServletContext.getInitParameter

Web:
	null.null.null
</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Filter Set Summary</Title>
            <Description>A brief summary of the filterset used to create this report</Description>
            <Text>Current Enabled Filter Set:&#13;
Security Auditor View&#13;
&#13;
Filter Set Details:&#13;
&#13;
Folder Filters:
If [fortify priority order] contains critical Then set folder to Critical
If [fortify priority order] contains high Then set folder to High
If [fortify priority order] contains medium Then set folder to Medium
If [fortify priority order] contains low Then set folder to Low</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Audit Guide Summary</Title>
            <Description>Summary of the impact of the audit guide</Description>
            <Text>Audit guide not enabled</Text>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Results Outline</Title>
        <SubSection enabled="true">
            <Title>Overall number of results</Title>
            <Description>Results count</Description>
            <Text>The scan found 33 issues.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Vulnerability Examples by Category</Title>
            <Description>Results summary for critical and high priority issues.  Vulnerability examples are provided by category.</Description>
            <IssueListing listing="true" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="list">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="4">
                        <groupTitle>Privacy Violation: Autocomplete</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>자동 완성이 활성화된 경우, 일부 브라우저에 세션에 대한 사용자 입력이 유지되면 초기 사용자 이후에 컴퓨터를 사용하는 사람은 이전에 전송된 정보를 볼 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>폼 또는 민감한 입력에 대한 자동 완성을 명시적으로 비활성화하십시오. 자동 완성을 비활성화하면 입력 시 이전에 입력한 정보는 사용자에게 다시 나타나지 않습니다. 또한 대부분의 주요 브라우저의 "내 암호 저장" 기능이 비활성화됩니다.

예제 1: HTML 폼에서 form 태그의 autocomplete 속성 값을 off로 설정하여 모든 입력 필드의 자동 완성을 비활성화하십시오.


  &lt;form method="post" autocomplete="off"&gt;
        Address: &lt;input name="address" /&gt;
        Password: &lt;input name="password" type="password" /&gt;
  &lt;/form&gt;


예제 2: 또는 해당 태그의 autocomplete 속성 값을 off로 설정하여 특정 입력 필드의 자동 완성을 비활성화하십시오.


  &lt;form method="post"&gt;
        Address: &lt;input name="address" /&gt;
        Password: &lt;input name="password" type="password" autocomplete="off"/&gt;
  &lt;/form&gt;


autocomplete 속성의 기본값이 on인지 확인하십시오. 따라서 민감한 입력을 다룰 경우, 속성을 생략하지 마십시오.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CA9E64516D6FCAE0C54C2ED7EF6704A2" ruleID="2FC7D1FF-11E4-468E-B7AB-F127828F4016">
                            <Category>Privacy Violation: Autocomplete</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>register.html의 형식은 39 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>register.html</FileName>
<FilePath>register.html</FilePath>
<LineStart>39</LineStart>
<Snippet>    &lt;span&gt;耶��뤇: &lt;input onmouseout = "SnoCheck()"  id="Sno"  type="text" name="Sno" /&gt;&lt;p id="1"&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;兀��뤇: &lt;input onmouseout = "UserCheck()" id="User" type="text" name="LoginUser" &gt;&lt;/input&gt;&lt;p id="2"&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;野녺쟻: &lt;input onmouseout = "PassCheck()" id="Pass" type="password" name="LoginPass" &gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;&lt;p id="3"&gt;&lt;/p&gt;&lt;/span&gt;
    &lt;span style="margin-left: 218px;"&gt;簾�溫ㅵ칳�쟻: &lt;input onmouseout = "PassTwoCheck()" id = "PassTwo" type="password" name="PassTwo" &gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;&lt;p id="4"&gt;&lt;/p&gt;&lt;/span&gt;
   &lt;br/&gt;&lt;br/&gt;&lt;br/&gt; </Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="CA9E64516D6FCAE0C54C2ED7EF6704A3" ruleID="2FC7D1FF-11E4-468E-B7AB-F127828F4016">
                            <Category>Privacy Violation: Autocomplete</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>register.html의 형식은 40 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>register.html</FileName>
<FilePath>register.html</FilePath>
<LineStart>40</LineStart>
<Snippet>    &lt;span&gt;兀��뤇: &lt;input onmouseout = "UserCheck()" id="User" type="text" name="LoginUser" &gt;&lt;/input&gt;&lt;p id="2"&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;野녺쟻: &lt;input onmouseout = "PassCheck()" id="Pass" type="password" name="LoginPass" &gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;&lt;p id="3"&gt;&lt;/p&gt;&lt;/span&gt;
    &lt;span style="margin-left: 218px;"&gt;簾�溫ㅵ칳�쟻: &lt;input onmouseout = "PassTwoCheck()" id = "PassTwo" type="password" name="PassTwo" &gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;&lt;p id="4"&gt;&lt;/p&gt;&lt;/span&gt;
   &lt;br/&gt;&lt;br/&gt;&lt;br/&gt; 
    &lt;span&gt;&lt;input id = "submit" disabled style="width: 452px;color: #fff;background: #999;" type="submit" value="塋뗥뜵力ⓨ냼"/&gt;&lt;/span&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="DA87A9C902D54BAADFCA48C96419F2F2" ruleID="2FC7D1FF-11E4-468E-B7AB-F127828F4016">
                            <Category>Privacy Violation: Autocomplete</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>login.html의 형식은 19 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>login.html</FileName>
<FilePath>login.html</FilePath>
<LineStart>19</LineStart>
<Snippet>        &lt;center&gt;�뵪�댎�쇉壤�&lt;/center&gt;&lt;br/&gt;&lt;br/&gt;
        USER: &lt;br/&gt; &lt;input type="text" name="user"&gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;
        PASS: &lt;br/&gt;&lt;input type="password" name="pass"&gt;&lt;/input&gt;
        &lt;br/&gt;
        &lt;br/&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="62722A3F75BE81ECDF3ACB69E695990A" ruleID="2FC7D1FF-11E4-468E-B7AB-F127828F4016">
                            <Category>Privacy Violation: Autocomplete</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>login.jsp의 형식은 28 줄의 자동 완성을 사용하면 일부 브라우저의 기록에 민감한 정보를 보유할 수 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>login.jsp</FileName>
<FilePath>login.jsp</FilePath>
<LineStart>28</LineStart>
<Snippet>    		&lt;center&gt;ç¨æ·ç»å½&lt;/center&gt;&lt;br/&gt;&lt;br/&gt;
    		USER: &lt;br/&gt; &lt;input type="text" name="user"&gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;
    		PASS: &lt;br/&gt;&lt;input type="password" name="pass"&gt;&lt;/input&gt;
    		&lt;br/&gt;
    		&lt;br/&gt;</Snippet>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>SQL Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>LoginModel.java의 9 줄에서 check() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>SQL injection 오류는 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스에서 데이터가 프로그램에 입력됩니다.

이런 경우, Fortify Static Code Analyzer는 데이터 소스를 신뢰할 수 있는 것으로 판단하지 않습니다.

2. 데이터를 사용하여 SQL 쿼리를 동적으로 생성합니다.



예제 1: 다음 코드는 지정된 이름과 일치하는 항목을 검색하는 SQL 쿼리를 동적으로 생성하고 실행합니다. 쿼리는 표시되는 항목을 항목 소유자가 현재 인증된 사용자의 이름과 일치하는 항목으로 제한합니다.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '"
				+ userName + "' AND itemname = '"
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
...


쿼리는 다음 코드를 실행하려고 합니다.


	SELECT * FROM items
	WHERE owner = &lt;userName&gt;
	AND itemname = &lt;itemName&gt;;


하지만 상수인 기본 쿼리 문자열과 사용자 입력 문자열을 연결하여 쿼리를 동적으로 생성하기 때문에, 쿼리는 itemName에 작은따옴표가 들어 있지 않은 경우에만 정확하게 동작합니다. 사용자 이름이 wiley인 공격자가 itemName에 문자열 "name' OR 'a'='a"를 입력하면 쿼리는 다음과 같이 생성됩니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';


OR 'a'='a' 조건을 추가하면 where 절이 항상 true로 평가하기 때문에 쿼리는 훨씬 간단한 다음 쿼리와 논리적으로 동일하게 됩니다.


	SELECT * FROM items;


공격자는 이렇게 쿼리를 단순화하여 쿼리가 인증된 사용자가 소유한 항목만 반환해야 한다는 요구 사항을 무시할 수 있습니다. 이제 쿼리는 지정된 소유자와 관계없이 items 테이블에 저장된 모든 항목을 반환합니다.

예제 2: 이 예제는 Example 1에서 생성하여 수행한 쿼리에 또 다른 악성 값이 전달될 때의 결과를 검토합니다. 사용자 이름이 wiley인 공격자가 itemName에 문자열 "name'; DELETE FROM items; --"를 입력하면 쿼리는 다음과 같은 두 개의 쿼리가 됩니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'


Microsoft(R) SQL Server 2000을 포함한 많은 데이터베이스 서버에서 여러 SQL 문을 세미콜론으로 구분하여 한꺼번에 실행하는 것을 허용합니다. 이 공격 문자열은 세미콜론으로 구분한 문에 대한 일괄 실행을 허용하지 않는 Oracle 및 기타 데이터베이스 서버에서는 오류를 일으키지만 일괄 실행을 허용하는 데이터베이스에서는 공격자가 이런 종류의 공격으로 데이터베이스에 대해 임의의 명령을 실행할 수 있습니다.

마지막의 하이픈 쌍(--)을 보겠습니다. 이는 대부분의 데이터베이스 서버에서 해당 문에 대한 나머지 부분을 주석으로 처리하여 실행하지 말라는 의미로 해석됩니다[4]. 이 경우, 이 주석 문자는 수정된 쿼리에서 마지막의 작은따옴표 한쪽을 제거하는 역할을 합니다. 주석을 이런 식으로 사용할 수 없는 데이터베이스에서도 Example 1에서 사용된 것과 유사한 속임수를 사용하면 대부분의 공격이 효과를 거둘 수 있습니다. 공격자가 문자열 "name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a"를 입력하여 다음 세 가지 유효한 문을 만드는 경우입니다.


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';


모바일 환경에서는 SQL Injection과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Example 1을 Android 플랫폼에 맞게 조정합니다.


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString("itemName");
        String query = "SELECT * FROM items WHERE owner = '"
                                + userName + "' AND itemname = '"
                                + itemName + "'";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, null);
...


SQL Injection 공격을 방지하는 한 가지 기존의 접근 방식은 공격을 입력값 검증 문제로 처리하고 안전한 값 목록(허용 목록)의 문자만 받거나 악의적일 가능성이 있는 값 목록(거부 목록)을 식별하여 이스케이프 처리하는 것입니다. 허용 목록 검사는 엄격한 입력값 검증 규칙을 이행하는 매우 효율적인 수단이 되기도 하지만, 매개 변수가 있는 SQL 문은 유지 관리가 쉽고 보다 강력한 보안을 제공할 수 있습니다. 대부분의 경우 거부 목록 구현은 SQL Injection 공격 방지의 효과를 떨어뜨리는 허점이 아주 많습니다. 예를 들어, 공격자는 다음과 같이 할 수 있습니다.

- 따옴표로 묶지 않은 필드를 노립니다.
- 이스케이프 처리된 메타 문자를 사용할 필요가 없는 방법을 찾습니다.
- 저장 프로시저(Stored procedure)를 사용하여 삽입된 메타 문자를 숨깁니다.

SQL 쿼리에 입력할 때 수동으로 문자를 이스케이프 처리하는 방법도 있지만 이것으로 SQL injection 공격으로부터 응용 프로그램을 보호할 수는 없습니다.

SQL injection 공격을 다루는 데 주로 제시되는 다른 솔루션은 저장 프로시저(stored procedure)를 사용하는 것입니다. 저장 프로시저(Stored procedure)는 일부 유형의 SQL injection 공격은 막을 수 있지만 다른 많은 유형은 막지 못합니다. 저장 프로시저(Stored procedure)는 일반적으로 매개 변수에 전달되는 SQL 문의 유형을 제한하여 SQL injection 공격을 막습니다. 하지만 이 제약을 피할 수 있는 많은 방법이 있어 수많은 비정상적인 문을 저장 프로시저(Stored procedure)에 전달할 수 있습니다. 되풀이하지만, 저장 프로시저(Stored procedure)는 일부 익스플로이트는 막을 수 있지만 응용 프로그램을 SQL injection 공격에 대해 안전하게 보호할 수는 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>SQL injection 취약점의 원인은 공격자가 SQL 쿼리의 컨텍스트를 변경하여 프로그래머가 데이터로 해석되기를 바라는 값을 명령으로 해석되도록 만들 수 있다는 점입니다. SQL 쿼리를 생성할 때, 프로그래머는 무엇이 명령으로 해석되어야 하고 무엇이 데이터로 해석되어야 하는지 알고 있습니다. 매개 변수가 있는 SQL 문은 데이터 위주의 컨텍스트 변경을 허용하지 않고 거의 모든 SQL injection 공격을 방지하여 이를 이행합니다. 매개 변수가 있는 SQL 문은 일반 SQL 문자열을 사용하여 생성되지만, 사용자가 제공하는 데이터를 포함해야 하는 경우에 이후에 삽입되는 데이터의 자리 표시자인 바인딩 매개 변수를 생성합니다. 바인딩 매개 변수를 사용하면 프로그램이 명령으로 처리해야 할 것과 데이터로 처리해야 할 것을 데이터베이스에 명시적으로 지정할 수 있습니다. 프로그램이 문을 실행할 준비가 되면 각 바인딩 매개 변수에 사용할 런타임 값을 데이터베이스에 지정하여 데이터가 명령으로 해석될 위험을 피할 수 있습니다. 

사용자가 제공하는 문자열을 연결하는 대신 매개 변수가 있는 SQL 문을 사용하도록 다음과 같이 예제 1을 다시 작성할 수 있습니다.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query =
        	"SELECT * FROM items WHERE itemname=? AND owner=?";
	PreparedStatement stmt = conn.prepareStatement(query);
	stmt.setString(1, itemName);
	stmt.setString(2, userName);
	ResultSet results = stmt.execute();
...


Android에 해당하는 코드는 다음과 같습니다.


...
	PasswordAuthentication pa = authenticator.getPasswordAuthentication();
	String userName = pa.getUserName();
	String itemName = this.getIntent().getExtras().getString("itemName");
	String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
	SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
	Cursor c = db.rawQuery(query, new Object[]{itemName, userName});
...


흔히 보고서 생성 코드에서 볼 수 있는 복잡한 시나리오에서는 WHERE 절의 동적 제약 조건 추가와 같이, SQL 문의 명령 구조가 결정되는 사용자 입력이 필요합니다. 그렇다고 이 요구 사항이 사용자 입력을 연결하여 쿼리 문자열을 만드는 것을 정당화할 수는 없습니다. 사용자 입력을 SQL 문 명령 구조에 적용해야 하는 경우 간접 참조를 사용하여 SQL injection 공격을 예방합니다. 즉, SQL 문에 포함시킬 여러 요소에 해당하는 유효한 문자열 집합을 만듭니다. 문을 만들 때 사용자 입력을 사용하여 이 응용 프로그램 제어 값 집합에서 값을 선택합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 이 때, 흔히 저지르는 실수는 사용자가 제어하는 문자열을 연결하여 생성한, 매개 변수가 있는 SQL 문을 사용하는 것입니다. 물론 이렇게 하면 매개 변수가 있는 SQL 문을 사용하는 목적이 무산됩니다. SQL 문을 형성하는 문자열이 응용 프로그램에서 제어하는 상수인지 확신할 수 없는 경우, 문자열이 SQL 문자열로 직접 실행되지 않기 때문에 안전하다고 가정할 수 없습니다. SQL 문에서 사용자 제어 문자열의 모든 사용을 철저하게 조사하고 쿼리의 의미를 수정하는 데 사용되는 일이 없는지 확인해야 합니다.

2. 데이터가 클래스의 공용 비 final 문자열 필드에서 오는 경우 이 데이터는 신뢰할 수 없습니다. 이러한 유형의 필드는 알려지지 않은 소스에 의해 수정될 수 있습니다.

3. SQL Injection 문제는 데이터 흐름 수정 작업 후에도 계속해서 보고될 수 있습니다(우선 순위 값은 감소). Fortify Static Code Analyzer에서 사용자 제어 입력이 SQL 문 구성에 사용되고 있다는 분명한 데이터 흐름 증거가 발견되면 높음/심각 우선 순위의 데이터 흐름 문제가 보고됩니다. Fortify Static Code Analyzer에서 데이터 소스를 결정할 수 없고 소스가 동적으로 변경될 수 있는 경우 낮음/중간 우선 순위의 의미 체계 문제가 보고됩니다. 이 전략은 SQL Injection과 같이 악용의 잠재적 영향이 거짓 긍정 문제를 감사하는 불편함보다 큰 일부 취약성 범주에 채택되었습니다.

4. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9147C5CEBDA6DE4FE869C32D0183E3F5" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>registerServlet.java의 64 줄에서 doPost() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>64</LineStart>
<Snippet>				System.out.println("f = true");
				sql = "insert into user values('" + sno + "', '" + user + "', '" + pass + "')";
				state.executeUpdate(sql);		
				
			}</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>43</LineStart>
<Snippet>		// TODO Auto-generated method stub
		//doGet(request, response);
		String sno = request.getParameter("Sno");
		String user = request.getParameter("LoginUser");
		String pass = request.getParameter("LoginPass");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E05BD34011271AF74D20BA4CC2F53A2E" ruleID="4B673A45-9AD5-4CBA-945B-11A3702CDF57">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>LoginModel.java의 9 줄에서 check() 메서드는 잠재적으로 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LoginModel.java</FileName>
<FilePath>src/adrui/LoginModel.java</FilePath>
<LineStart>9</LineStart>
<Snippet>	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){</Snippet>
<TargetFunction>executeQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="08D07C1407753721CFABDE9FE7DFE2CF" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>registerServlet.java의 64 줄에서 doPost() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>64</LineStart>
<Snippet>				System.out.println("f = true");
				sql = "insert into user values('" + sno + "', '" + user + "', '" + pass + "')";
				state.executeUpdate(sql);		
				
			}</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>45</LineStart>
<Snippet>		String sno = request.getParameter("Sno");
		String user = request.getParameter("LoginUser");
		String pass = request.getParameter("LoginPass");
		Connection conn = (Connection)(getServletContext().getAttribute("conn"));
		try{</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7979A68DB1EB9D685F539D165EC5EE29" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>registerServlet.java의 64 줄에서 doPost() 메서드는 신뢰할 수 없는 소스에서 나온 입력을 사용하여 만들어진 SQL 쿼리를 호출합니다. 이 호출을 사용하여 공격자는 해당 문의 의미를 수정하거나 임의의 SQL 명령을 실행할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>64</LineStart>
<Snippet>				System.out.println("f = true");
				sql = "insert into user values('" + sno + "', '" + user + "', '" + pass + "')";
				state.executeUpdate(sql);		
				
			}</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>44</LineStart>
<Snippet>		//doGet(request, response);
		String sno = request.getParameter("Sno");
		String user = request.getParameter("LoginUser");
		String pass = request.getParameter("LoginPass");
		Connection conn = (Connection)(getServletContext().getAttribute("conn"));</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>System Information Leak: Incomplete Servlet Error Handling</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Servlet에 예외 사항이 발생하면 Servlet 컨테이너가 사용자에게 보내는 기본 오류 응답에는 보통 디버깅 정보가 포함됩니다. 디버깅 정보는 공격자에게 아주 쓸모가 있습니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

예제 1: 다음 메서드에서 DNS 조회 실패로 Servlet에 예외 사항이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println("hello " + addr.getHostName());
}


예제 2: 다음 메서드는 매개 변수 "name"이 요청한 부분이 아닌 경우 NullPointerException이 발생합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter("name");
    ...
    out.println("hello " + name.trim());
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>모든 최상위 수준 Servlet 메서드는 Throwable을 캐치(catch)하여 Servlet의 오류 응답 메커니즘이 호출될 기회를 최소화해야 합니다. 

예제 3: Example 1의 메서드는 다음과 같이 다시 작성해야 합니다.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println("hello " + addr.getHostName());
      }catch (Throwable t) {
          logger.error("caught throwable at top level", t);
      }
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="0D85D8B3021CC15E7F4434F4B9EFED84" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LoginServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LoginServlet.java</FileName>
<FilePath>src/adrui/LoginServlet.java</FilePath>
<LineStart>30</LineStart>
<Snippet>	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append("Served at: ").append(request.getContextPath());</Snippet>
<TargetFunction>Function: doGet()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4C80BB31FC4828FD5B90F74DBFB384F9" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>registerServlet Servlet은 doGet()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>32</LineStart>
<Snippet>	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append("Served at: ").append(request.getContextPath());</Snippet>
<TargetFunction>Function: doGet()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D1CED827D763E2CF7E0809CC14ED711D" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LoginServlet Servlet은 doPost()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LoginServlet.java</FileName>
<FilePath>src/adrui/LoginServlet.java</FilePath>
<LineStart>38</LineStart>
<Snippet>	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Login Test");</Snippet>
<TargetFunction>Function: doPost()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FCCFD957687589A021B1ADD593FB3FD6" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>registerServlet Servlet은 doPost()의 모든 예외 사항을 캐치하지 못합니다. Servlet이 모든 예외 사항을 캐치하지 못하면 공격자가 공격을 계획하는 데 도움이 되는 디버깅 정보를 노출할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>40</LineStart>
<Snippet>	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		//doGet(request, response);</Snippet>
<TargetFunction>Function: doPost()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>login.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>CSRF(cross-site request forgery) 취약점은 다음 경우에 발생합니다.
1. 웹 응용 프로그램이 세션 쿠키를 사용합니다.

2. 응용 프로그램이 해당 요청이 사용자의 동의 하에 이루어졌는지 확인하지 않고 HTTP 요청에 대해 작업합니다.



Nonce는 재전송 공격을 막기 위해 메시지와 함께 전송된 암호화 무작위 값입니다. 요청에 출처를 증명하는 정보가 포함되어 있지 않은 경우, 해당 요청을 처리하는 코드는 CSRF 공격에 취약합니다(응용 프로그램의 상태를 변경하지 않는 경우 제외). 이는 공격자가 사용자로 하여금 허위 요청을 제출하도록 속이지 못하게 하려면 세션 쿠키를 사용하는 웹 응용 프로그램이 특별한 예방 조치를 취해야 한다는 의미입니다. 관리자가 다음과 같은 폼을 제출하여 새로운 계정을 생성하도록 허용하는 웹 응용 프로그램을 상상해 보십시오.


&lt;form method="POST" action="/new_user" &gt;
  Name of new user: &lt;input type="text" name="username"&gt;
  Password for new user: &lt;input type="password" name="user_passwd"&gt;
    &lt;input type="submit" name="action" value="Create User"&gt;
&lt;/form&gt;


공격자는 다음과 같이 웹 사이트를 설정할 수도 있습니다.


&lt;form method="POST" action="http://www.example.com/new_user"&gt;
  &lt;input type="hidden" name="username" value="hacker"&gt;
  &lt;input type="hidden" name="user_passwd" value="hacked"&gt;
&lt;/form&gt;
&lt;script&gt;
  document.usr_form.submit();
&lt;/script&gt;


예를 들어 example.com의 관리자가 사이트에서 세션을 활성화한 상태에서 악성 페이지를 방문하는 경우 무의식적으로 공격자를 위한 계정을 만들게 됩니다. 이것이 CSRF 공격입니다. 이는 응용 프로그램이 해당 요청의 출처를 확인하는 방법을 가지고 있지 않기 때문입니다. 모든 요청은 사용자가 선택한 적법한 작업이거나 공격자가 설정한 허위 작업일 가능성이 있습니다. 공격자는 허위 요청이 생성하는 웹 페이지를 보지 못하므로 이 공격 기법은 응용 프로그램의 상태를 변경하는 요청의 경우에만 유용합니다.

하지만 세션 ID를 쿠키가 아닌 URL에서 전달하는 응용 프로그램은 공격자가 세션 ID에 접근하여 허위 요청의 일부로 포함시킬 방법이 없으므로 CSRF 문제가 발생하지 않습니다.

CSRF는 2007 OWASP Top 10 목록에서 제 5위입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>세션 쿠키를 사용하는 응용 프로그램은 백엔드 코드가 요청의 출처를 검증하는 데 사용하는 모든 폼 게시에 약간의 정보를 포함시켜야 합니다. 이렇게 하는 방법 중 하나는 다음과 같이 임의의 요청 ID 또는 Nonce를 포함시키는 것입니다.


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, "/new_user");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


이렇게 하면 나머지 폼 데이터를 처리하기 전에 백엔드 로직이 요청 ID를 검증할 수 있습니다. 가능한 경우 요청 ID는 특정 세션의 모든 요청에서 공유되는 것이 아니라 각 서버 요청에 대해 고유해야 합니다. 세션 ID를 사용하면 공격자가 요청 ID를 추측하기 어려워지며 CSRF 공격을 성공적으로 수행하기가 어려워집니다. 토큰은 쉽게 추측할 수 없어야 하며 세션 토큰을 보호하는 것과 동일한 방식(예: SSLv3 사용)으로 보호되어야 합니다.

추가적인 완화 기법에는 다음이 포함됩니다.

프레임워크 보호: 대부분의 최신 웹 응용 프로그램 프레임워크는 CSRF 보호를 포함하며 CSRF 토큰을 자동으로 포함하고 확인합니다.
챌린지-응답 제어 사용: 고객에게 서버에서 전송된 챌린지에 응답하도록 요구하는 것은 CSRF에 대한 강력한 대비책입니다. 이 용도로 사용할 수 있는 챌린지에는 CAPTCHA, 암호 재인증, 일회용 토큰 등이 있습니다.
HTTP Referer/Origin 헤더 검사: 공격자가 CSRF 공격을 실행하는 동안 이러한 헤더를 스푸핑할 수 없습니다. 따라서 이러한 헤더가 CSRF 공격을 방지하는 유용한 방법이 됩니다.
세션 쿠키 중복 전송: 실제 세션 ID 쿠키와 함께 숨겨진 폼 값으로 세션 ID 쿠키를 전송하면 CSRF 공격에 대해 적절한 보호를 제공할 수 있습니다. 서버에서는 폼 데이터의 다른 값을 처리하기 전에 두 값을 모두 검사하여 동일한지 확인합니다. 공격자가 사용자를 가장하여 폼을 전송하는 경우 동일 출처 정책에 따라 세션 ID 쿠키 값을 수정할 수 없습니다.
세션 수명 제한: CSRF 공격을 사용하여 보호된 리소스에 접근할 때 공격의 일부로 전송한 세션 ID가 서버에서 유효한 동안에만 공격이 유효하게 됩니다. 따라서 세션 수명을 제한하면 공격 성공 가능성이 줄어듭니다.

여기에서 설명하는 기법은 XSS 공격으로 무력화됩니다. 효과적인 CSRF 완화 기법에는 XSS 완화 기법이 포함됩니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer는 GET 또는 POST 작업을 수행할 가능성이 있는 모든 HTML 양식 및 XMLHttpRequest 개체에 플래그를 지정합니다. 감사자는 각 양식이 공격자에게 CSRF 대상으로서 가치가 있는지 여부와 해당하는 완화 기법을 사용하는지 여부를 확인해야 합니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="56FB5AE4E7E9BB62980D1AA7A3D90A86" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>login.jsp 파일의 25 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>login.jsp</FileName>
<FilePath>login.jsp</FilePath>
<LineStart>25</LineStart>
<Snippet>			window.onload=show;
		&lt;/script&gt;
		&lt;form style="margin:auto;" action="login.do" method="POST"&gt;
    		&lt;center&gt;ç¨æ·ç»å½&lt;/center&gt;&lt;br/&gt;&lt;br/&gt;
    		USER: &lt;br/&gt; &lt;input type="text" name="user"&gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="94FAB8D7062649FD7643BA144C209D75" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>login.html 파일의 16 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>login.html</FileName>
<FilePath>login.html</FilePath>
<LineStart>16</LineStart>
<Snippet>    &lt;/div&gt;    --&gt;

    &lt;form  style="margin: auto;" action="login.do" method="POST"&gt;
        &lt;center&gt;�뵪�댎�쇉壤�&lt;/center&gt;&lt;br/&gt;&lt;br/&gt;
        USER: &lt;br/&gt; &lt;input type="text" name="user"&gt;&lt;/input&gt;&lt;br/&gt;&lt;br/&gt;</Snippet>
                            </Primary>
                        </Issue>
                        <Issue iid="F9BBA322F3EF4182501DBA402388E4E9" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>register.html 파일의 36 줄에 있는 폼 게시에는 공격자의 무단 요청을 막기 위한 사용자 특정 기밀이 포함되어 있어야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>register.html</FileName>
<FilePath>register.html</FilePath>
<LineStart>36</LineStart>
<Snippet>        &lt;center&gt;&lt;h1&gt;�뵪�댎岳→겘&lt;/h1&gt;&lt;/center&gt;&lt;br/&gt;
    &lt;br/&gt;&lt;br/&gt;
    &lt;form action="register.do" method="POST"&gt;
    &lt;span&gt;耶��뤇: &lt;input onmouseout = "SnoCheck()"  id="Sno"  type="text" name="Sno" /&gt;&lt;p id="1"&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;兀��뤇: &lt;input onmouseout = "UserCheck()" id="User" type="text" name="LoginUser" &gt;&lt;/input&gt;&lt;p id="2"&gt;&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;</Snippet>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Missing Check against Null</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>login.jsp의 _jspService() 메서드는 getAttribute()의 반환 값을 확인하지 않아 16 줄의 null 포인터를 역참조할 수 있으므로 null을 반환할 수도 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>소프트웨어에 대한 대부분의 심각한 공격은 프로그래머의 가정 위반에서 비롯됩니다. 공격 후, 프로그래머의 가정은 취약하고 근거가 빈약해 보이지만 공격 전에는 많은 프로그래머가 열심히 자신의 가정을 옹호하게 마련입니다.

코드에서 흔히 발견되는 두 가지 의심스런 가정은 "이 함수 호출은 절대 실패하지 않는다" 및 "이 함수 호출이 실패해도 상관 없다"입니다. 프로그래머가 함수의 반환 값을 무시하는 경우 암시적으로 이 가정 중 하나에 따라 동작하는 것으로 볼 수 있습니다.



예제 1:  다음 코드는 멤버 함수 compareTo()를 호출하기 전에 getParameter()가 반환한 문자열이 null인지 검사하지 않기 때문에 null dereference가 발생할 수 있습니다.


String itemName = request.getParameter(ITEM_NAME);
	if (itemName.compareTo(IMPORTANT_ITEM)) {
		...
	}
	...


예제 2: 다음 코드는 null로 설정되면 해당 속성이 항상 정의된다는 잘못된 가정을 하는 프로그래머가 역참조하는 시스템 속성을 보여줍니다.


System.clearProperty("os.name");
...
String os = System.getProperty("os.name");
if (os.equalsIgnoreCase("Windows 95") )
	System.out.println("Not supported");


이 코딩 오류에 대한 전형적인 변명은 이렇습니다. 

“요청한 값이 항상 존재한다는 것을 알고 있습니다. 왜냐하면... 값이 존재하지 않는 경우, 프로그램이 필요한 동작을 수행할 수 없기 때문에 오류 처리 여부가 중요하지 않거나 프로그램이 null 값을 역참조하다가 중지해도 상관 없습니다.”

하지만 공격자는 프로그램에서 예기치 못한 경로를 찾아내는 데 능숙하며 예외와 관련이 있는 경우가 대표적인 예입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>함수가 오류 코드를 반환하거나 다른 성공 또는 실패의 증거를 반환하는 경우, 오류가 발생하는 확실한 방법이 없는 경우에도 항상 오류 조건을 검사하십시오. 보안 오류를 예방하는 것도 중요하지만 초기에 의심스러운 수많은 버그가 결국 unchecked return value와 함께 메소드 호출 실패로 이어집니다.

응용 프로그램에서 실패를 해결하기 위해 사용하기 쉬운 표준 방법을 만드십시오. 오류 처리가 단순명료하다면 프로그래머가 오류 처리를 생략하지 않을 것입니다. 오류 처리를 표준화하는 한 가지 접근 방식은 자주 사용하는 함수 주위에 추가 프로그래머 개입 없이 오류 조건을 검사하고 처리하는 래퍼를 작성하는 것입니다. 래퍼를 구현하여 적용하면 사용자 지정 규칙을 사용하여 래퍼 없는 함수를 사용하는 것을 금지하고 강제할 수 있습니다. 

예제 3: 다음 코드는 getParameter()의 반환 값이 null이 아닌지 검사하고 요청한 매개 변수가 정의되어 있지 않은 경우 기본값을 사용하는 래퍼를 getParameter() 속성 주위에 구현합니다.


String safeGetParameter (HttpRequest request, String name)
{
    String value = request.getParameter(name);
    if (value == null) {
        return getDefaultValue(name)
    }
    return value;
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. "그런 일은 절대 일어날 수 없습니다. 왜냐하면..."이라고 말하면서 이 이슈를 덮어두려는 프로그래머를 조심하십시오. 이들은 개발 워크스테이션을 사용하여 시스템 동작 방식에 대한 직관력을 키웠을 가능성이 큽니다. 소프트웨어를 다른 운영 체제, 다른 운영 체제 버전, 다른 하드웨어 구성 또는 다른 런타임 환경에서 실행하게 되면 이들의 직관력은 무용지물이 될 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3C32B62872F71A75A0DC74034AEFC341" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>login.jsp의 _jspService() 메서드는 getAttribute()의 반환 값을 확인하지 않아 16 줄의 null 포인터를 역참조할 수 있으므로 null을 반환할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>login.jsp</FileName>
<FilePath>login.jsp</FilePath>
<LineStart>15</LineStart>
<Snippet>&lt;body&gt;

	&lt;% String f = (String)request.getAttribute("res"); 
		if(f.substring(0, 1).equals("1")){
			</Snippet>
<TargetFunction>f = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4B46D0EFD19B8C2C48CC00079DB08926" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>register.jsp의 _jspService() 메서드는 getAttribute()의 반환 값을 확인하지 않아 12 줄의 null 포인터를 역참조할 수 있으므로 null을 반환할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>register.jsp</FileName>
<FilePath>register.jsp</FilePath>
<LineStart>11</LineStart>
<Snippet>&lt;/head&gt;
&lt;body &gt;
	&lt;% String f = (String)request.getAttribute("res");
		if(f.equals("true")){
	%&gt;</Snippet>
<TargetFunction>f = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2FE6DD40847D6E8E121FE9262C1ED052" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>login.jsp의 _jspService() 메서드는 getAttribute()의 반환 값을 확인하지 않아 19 줄의 null 포인터를 역참조할 수 있으므로 null을 반환할 수도 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>login.jsp</FileName>
<FilePath>login.jsp</FilePath>
<LineStart>19</LineStart>
<Snippet>			
	%&gt;
	&lt;p&gt;Hello, &lt;%= ((String)request.getAttribute("res")).substring(1) %&gt;&lt;/p&gt;
	&lt;% }else{
		%&gt;</Snippet>
<TargetFunction>getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>예제 1: 개발자가 배우는 과정에서 작성하는 첫 Java 프로그램은 다음과 같습니다.


public class MyClass
  ...
    System.out.println("hello world");
  ...
}


대부분의 프로그래머가 Java의 수많은 노하우와 세부 사항을 배우게 되지만 상당수의 프로그래머가 이 첫 수업에 집착한 나머지 System.out.println()을 사용하여 표준 출력에 메시지를 쓰는 것을 그만두지 않습니다.

문제는 표준 출력이나 표준 오류에 직접 쓰는 것이 구조화되지 않은 형식의 로깅으로 이용되는 일이 잦다는 점입니다. 구조화된 로깅 기능은 로깅 수준, 단일 서식, 로거 ID, 타임스탬프 및 무엇보다 중요한, 로그 메시지를 올바른 위치에 보내는 기능 등의 기능을 제공합니다. 시스템 출력 스트림 사용이 로거를 올바로 사용하는 코드와 혼합되면 잘 기록되긴 했지만 중요한 정보가 누락된 로그가 생성됩니다.

개발자는 구조화된 로깅의 필요성을 폭넓게 이해하지만 상당수가 "운용 전" 개발 단계에서 시스템 출력 스트림을 계속 사용합니다. 검토 중인 코드가 초기 개발 단계를 지난 경우, System.out 또는 System.err 사용이 발견되면 이는 구조화된 로깅 시스템으로 옮겨가는 도중 실수한 것일 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>System.out 또는 System.err 대신 Java 로깅 기능을 사용하십시오. 

예제 2: 예를 들어, Example 1의 “hello world” 프로그램은 log4j를 사용하여 다음과 같이 다시 작성할 수 있습니다.


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  ...
    BasicConfigurator.configure();
    logger.info("hello world");
  ...
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer에서는 예외적으로 System.out 또는 System.err을 main() 및 메서드(main() 의 호출 계층)에 사용할 수 있으며 이러한 사용을 Poor Logging Practice:  Use of a System Output Stream 이슈로 보고하지 않습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="88008082069DDB8934BAC242EE9E27DD" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>30</LineStart>
<Snippet>			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute("conn", conn);
			System.out.println("Connect Succeed!");
		}
		catch(Exception e){</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="62793514B5C14E58E34A6C82F6EAA2FC" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LoginServlet.java</FileName>
<FilePath>src/adrui/LoginServlet.java</FilePath>
<LineStart>40</LineStart>
<Snippet>	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Login Test");
		String user = request.getParameter("user");
		String pass = request.getParameter("pass");</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3634AD4EBCD44C770289CB4C84EFC8FC" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>전용 로깅 기능 대신 println()을 사용하면 프로그램 동작을 모니터링하기가 어렵습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>62</LineStart>
<Snippet>			if(f){
				res = "true";
				System.out.println("f = true");
				sql = "insert into user values('" + sno + "', '" + user + "', '" + pass + "')";
				state.executeUpdate(sql);		</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>System Information Leak</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>LoginServlet.java의 doPost() 함수는 54 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>정보 누출은 시스템 데이터 또는 디버그 정보가 출력 스트림이나 로깅 함수를 통해 프로그램을 벗어날 때 발생합니다.



예제 1: 다음 코드는 표준 오류 스트림에 예외 사항을 작성합니다.


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


시스템 구성에 따라 이 정보는 콘솔에 덤프되거나 로그 파일에 작성되거나 원격 사용자에게 노출될 수 있습니다. 예를 들어, 스크립팅 메커니즘을 사용하면 "표준 오류" 또는 "표준 출력"에서 파일이나 다른 프로그램으로 출력 정보를 간단하게 리디렉션할 수 있습니다. 또는 프로그램이 실행되는 시스템에는 로그를 원격 장치로 전송하는 "syslog" 서버와 같은 원격 로깅 메커니즘이 있을 수 있습니다. 개발 단계에서는 이 정보가 어디에 표시될지 알 방법이 없습니다.

경우에 따라 오류 메시지가 공격자에게 시스템이 취약한 정확한 공격 유형을 알려주기도 합니다. 예를 들어, 데이터베이스 오류 메시지가 응용 프로그램이 SQL injection 공격에 취약하다는 것을 드러낼 수 있습니다. 다른 오류 메시지도 비교적 모호하지만 시스템에 대한 단서를 제공합니다. Example 1에서는 누출된 정보가 운영 체제의 종류, 시스템에 설치된 응용 프로그램 및 관리자가 프로그램 구성에 들인 관심의 정도에 대한 정보를 암시할 수 있습니다.

모바일 환경과 관련된 시나리오를 하나 더 소개하겠습니다. 현재 대부분의 모바일 장치는 무선 통신을 사용하는 장치 간에 정보를 빠르게 교환할 수 있도록 NFC(근거리 통신) 프로토콜을 구현합니다. NFC 프로토콜은 장치를 근접하게 또는 서로 접촉하도록 배치하는 방식으로 작동합니다. NFC의 통신 범위는 불과 몇 센티미터 정도로 제한되지만 NFC만 사용해서는 보안 통신이 보장되지 않으므로 도청, 데이터 수정 및 기타 다양한 유형의 공격을 할 수 있습니다.

예제 2: Android 플랫폼에서는 NFC가 지원됩니다. 다음 코드는 범위 내의 다른 장치로 푸시되는 메시지를 생성합니다.

...
public static final String TAG = "NfcActivity";
private static final String DATA_SPLITTER = "__:DATA:__";
private static final String MIME_TYPE = "application/my.applications.mimetype";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NDEF(NFC 데이터 교환 형식) 메시지에는 형식화된 데이터, URI 또는 사용자 지정 응용 프로그램 페이로드가 포함됩니다. 메시지에 응용 프로그램 이름, MIME 유형 또는 장치 소프트웨어 버전 같은 응용 프로그램 관련 정보가 포함되어 있으면 도청자에게 해당 정보가 노출될 수 있습니다. Example 2에서 Fortify Static Code Analyzer는 return 문에서 system information leak 취약성을 보고합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>오류 메시지를 쓸 때는 항상 보안을 염두에 두어야 합니다. 운영 환경에서는 자세한 오류 정보 대신 간단한 메시지를 사용합니다. 관리자와 프로그래머가 문제를 진단하는 데 도움이 되는 상세한 출력의 생성 및 저장은 삼가는 것이 좋습니다. 디버깅 추적은 때에 따라 엉뚱한 곳에 나타날 수 있습니다(예: 오류 페이지의 HTML에서 주석에 포함됨).

스택 추적이나 데이터베이스 덤프를 나타내지 않는 간결한 오류 메시지도 공격자에게 도움을 줍니다. 예를 들어, "접근 거부" 메시지는 시스템에 파일이나 사용자가 존재한다는 것을 나타냅니다.

Android 장치에서 NFC를 통한 시스템 데이터 누출이 염려되면 다음의 세 가지 작업 중 하나를 수행하면 됩니다. 즉 범위 내에 있는 다른 장치로 푸시되는 메시지에 시스템 데이터를 포함하지 않거나, 메시지 페이로드를 암호화하거나, 상위 계층에 보안 통신 채널을 설정합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. System information leak을 예방하는 데 래퍼 스크립트, 회사 IT 정책 또는 빠른 판단력을 가진 시스템 관리자에만 의존하지 마십시오. 자체적으로 안전한 소프트웨어를 작성해야 합니다.

2. 이 카테고리의 취약점은 모든 유형의 프로그램에 적용되지 않습니다. 예를 들어, 응용 프로그램이 공격자가 이미 시스템 정보를 확보한 클라이언트 시스템에서 실행되거나 시스템 정보를 신뢰할 수 있는 로그 파일에만 인쇄하는 경우, Audit Guide를 사용하여 스캔 결과에서 이 카테고리의 취약점을 필터링할 수 있습니다.

3. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="08BD92B58521B0F455A66A26EE6288E1" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LoginServlet.java의 doPost() 함수는 54 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LoginServlet.java</FileName>
<FilePath>src/adrui/LoginServlet.java</FilePath>
<LineStart>54</LineStart>
<Snippet>		}
		catch(Exception e){
			e.printStackTrace();
		}
	}</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0DD8B02E4BFE39436C2920BB34F94924" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>MyContextListener.java의 contextInitialized() 함수는 33 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>33</LineStart>
<Snippet>		}
		catch(Exception e){
			e.printStackTrace();
		}
	}</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="53EE9CDA46A819785E847488896323C2" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>registerServlet.java의 doPost() 함수는 72 줄의 printStackTrace()을(를) 호출하여 시스템 데이터 또는 디버그 정보를 노출합니다. printStackTrace()에 의해 노출된 정보는 공격자가 공격을 계획하는 데 도움을 줄 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>registerServlet.java</FileName>
<FilePath>src/adrui/registerServlet.java</FilePath>
<LineStart>72</LineStart>
<Snippet>		}
		catch(Exception e){
			e.printStackTrace();
		}
	}</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>login.jsp의 _jspService() 메서드가 19 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XSS(Cross-site scripting) 취약점은 다음 경우에 발생합니다.

1. 신뢰할 수 없는 소스를 통해 데이터가 웹 응용 프로그램에 입력됩니다. Persistent(Stored 라고도 함) XSS의 경우 신뢰할 수 없는 소스는 일반적으로 데이터베이스 또는 다른 백엔드 데이터 저장소이지만, Reflected XSS의 경우에는 일반적으로 웹 요청입니다.


2. 데이터는 검증 없이 웹 사용자에게 전달된 동적 콘텐트에 포함됩니다.

웹 브라우저에 전달되는 악성 콘텐트는 흔히 JavaScript 세그먼트의 형태를 취하지만 HTML, Flash 또는 기타 브라우저가 실행하는 다른 모든 유형의 코드를 포함할 수도 있습니다. XSS 기반의 공격은 거의 무제한으로 다양하지만, 흔히 쿠키 또는 기타 세션 정보와 같은 개인 데이터를 공격자에게 전송하여 피해자를 공격자가 제어하는 웹 콘텐트에 리디렉션하거나 피해 사이트로 위장하고 사용자 컴퓨터에 기타 악의적인 작업을 수행하는 것이 공통적인 수법입니다.


예제 1: 다음 JSP 코드 세그먼트는 지정된 직원 ID의 직원에 대한 데이터베이스를 쿼리하여 해당 직원의 이름을 인쇄합니다.


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;%= name %&gt;



이 코드는 name의 값이 올바로 동작할 때는 정확하게 기능을 하지만 그렇지 않을 때는 익스플로이트를 방지하기 위한 아무 조치도 취하지 않습니다. 이 코드는 name의 값을 응용 프로그램이 콘텐트를 분명하게 관리하는 데이터베이스에서 읽기 때문에 위험하지 않은 것으로 보일 수 있습니다. 하지만 name의 값이 사용자가 제공하는 데이터에서 오는 경우 데이터베이스는 악성 콘텐트의 통로가 될 수 있습니다. 데이터베이스에 저장된 모든 데이터에 대한 적절한 입력값 검증 절차가 없으면 공격자는 사용자의 웹 브라우저에서 악의적인 명령을 실행할 수 있습니다. 이런 유형의 익스플로이트를 Persistent(또는 Stored) XSS라고 하는데 데이터 저장소가 사용하는 간접 참조 때문에 위협을 식별하기 어렵고 공격이 여러 사용자에게 가해질 가능성이 커지기 때문에 더욱 위험합니다. XSS는 방문자에게 "방명록"을 제공하는 웹 사이트에서 이런 형태로 시작되었습니다. 공격자가 방명록 항목에 JavaScript를 삽입하면 이후에 방명록 페이지를 방문하는 방문자는 모두 악성 코드를 실행하게 됩니다.


예제 2: 다음 JSP 코드 세그먼트는 HTTP 요청에서 직원 ID인 eid를 읽어 사용자에게 표시합니다.


&lt;% String eid = request.getParameter("eid"); %&gt;
...
Employee ID: &lt;%= eid %&gt;



Example 1에서처럼 이 코드는 eid에 표준 영숫자 텍스트만 있으면 올바로 동작합니다. eid가 메타 문자나 소스 코드가 포함된 값을 갖는 경우, 웹 브라우저가 HTTP 응답을 표시할 때 코드를 실행합니다.

처음에는 이것이 큰 취약점으로 보이지 않을 수도 있습니다. 결국 누군가 URL을 입력하여 자신의 컴퓨터에서 악성 코드가 실행되게 하는 이유는 무엇입니까? 정말 위험한 일은 공격자가 악성 URL을 만든 다음 전자 메일 또는 사회 공학 속임수를 사용하여 피해자가 URL의 링크를 방문하도록 만드는 것입니다. 피해자가 링크를 클릭하면 모르는 사이에 취약한 웹 응용 프로그램을 통해 해로운 내용을 본인의 컴퓨터로 전달하게 됩니다. 취약한 웹 응용 프로그램을 익스플로이트하는 메커니즘을 Reflected XSS 라고 합니다.

모바일 환경에서는 Cross-Site Scripting과 같은 전형적인 웹 응용 프로그램 취약성이 발생하지 않는다고 생각하는 사용자도 있습니다. 자기 자신을 공격하는 사용자는 없을 것이라 여기기 때문입니다. 그러나 모바일 플랫폼의 핵심 요소는 다양한 소스에서 다운로드되어 같은 장치에서 함께 실행되는 응용 프로그램이라는 점을 유념해야 합니다. 즉 금융 응용 프로그램과 맬웨어를 함께 실행할 가능성이 높으므로 프로세스 간 통신을 포함하도록 모바일 응용 프로그램의 공격 표면을 확장해야 합니다.

예제 3: 다음 코드는 Android의 WebView에서 JavaScript를 활성화(기본적으로 JavaScript는 비활성화됨)하고 Android 인텐트에서 받은 값을 기준으로 페이지를 로드합니다.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(url);
...


url 값이 javascript:로 시작하면 그 뒤에 오는 JavaScript 코드가 WebView 내에 있는 웹 페이지의 컨텍스트에서 실행됩니다.

예제에서처럼, XSS 취약점은 HTTP 응답에 확인되지 않은 데이터가 포함된 코드 때문에 발생합니다. XSS 공격이 피해자에게 가해지는 방식은 세 가지가 있습니다.

- Example 1에서처럼 응용 프로그램은 데이터베이스 또는 다른 신뢰할 수 있는 데이터 저장소에 데이터를 저장합니다. 그러면 위험한 데이터는 응용 프로그램이 다시 읽어 들여 동적 콘텐트에 포함시킵니다. Persistent XSS 익스플로이트는 공격자가 위험한 콘텐트를 데이터 저장소에 삽입하고 이 콘텐트를 나중에 읽어 들여 동적 콘텐트에 포함시킬 때 발생합니다. 공격자의 관점에서 악성 콘텐트를 삽입할 최적의 장소는 많은 사용자나 특히 관련 사용자에게 표시되는 장소입니다. 일반적으로 관련 사용자는 응용 프로그램에 권한을 높이거나 공격자가 원하는 민감한 데이터와 상호 작용합니다. 이런 사용자가 악성 콘텐트를 실행하면 공격자는 사용자 대신 권한 있는 작업을 실행하거나 사용자 소유의 민감한 데이터에 접근할 수 있습니다.

- Example 2에서처럼 데이터를 HTTP 요청에서 직접 읽어 들여 HTTP 응답에 다시 적용하는 것입니다. 적용된 XSS 익스플로이트는 공격자가 사용자로 하여금 위험한 콘텐트를 취약한 웹 응용 프로그램에 제공하도록 만드는 것입니다. 이 위험한 콘텐트는 다시 사용자에게 돌아가고 웹 브라우저가 이를 실행합니다. 악성 콘텐트를 제공하는 가장 일반적인 메커니즘은 콘텐트를 공용으로 게시하거나 피해자에게 직접 전자 메일로 보내지는 URL의 매개 변수로 포함하는 것입니다. 이런 식으로 생성된 URL은 많은 공격자가 피해자를 속여 피해 사이트를 참조하는 URL을 방문하게 하는 피싱 기법의 근간을 이룹니다. 사이트가 공격자의 콘텐트를 사용자에게 보내면, 콘텐트가 실행되고 세션 정보가 들어있는 쿠키 등의 개인 정보가 사용자의 컴퓨터에서 공격자에게 전송되거나 다른 악의적인 작업이 수행됩니다.

- Example 3과 같이 응용 프로그램 외부의 소스에서 데이터베이스 또는 기타 데이터 저장소에 위험한 데이터를 저장하고 위험한 데이터를 응용 프로그램이 신뢰할 수 있는 데이터로 읽어 들여 데이터가 동적 콘텐트에 포함됩니다.


많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>XSS 방지를 위한 해결 방법은 필요한 위치에서 유효성 검사가 수행되도록 하고 취약성을 방지하도록 관련 속성을 설정하는 것입니다.

XSS 취약점은 응용 프로그램이 출력에 악성 데이터를 포함할 때 발생하기 때문에 한 가지 논리적인 접근 방식은 데이터가 응용 프로그램을 벗어나기 직전에 데이터를 확인하는 것입니다. 하지만 웹 응용 프로그램에 동적 콘텐트 생성을 위한 복잡하고 까다로운 코드가 있기 때문에 이 방법은 생략(검증 누락) 오류가 발생할 가능성이 큽니다. 이런 위험을 완화하는 효과적인 방법 역시 XSS의 입력값 검증을 수행하는 것입니다.

웹 응용 프로그램은 SQL injection과 같은 다른 취약점을 방지하기 위해 모든 입력을 확인해야 합니다. 따라서 응용 프로그램의 기존 입력값 검증 메커니즘에 XSS 검사를 포함하도록 확대하는 것이 비교적 쉽습니다. XSS의 입력값 검증이 아무리 뛰어나더라도 엄격한 출력 검증을 대신할 수는 없습니다. 응용 프로그램은 공유 데이터 저장소 또는 기타 신뢰할 수 있는 소스를 통해 입력을 받는데 그 데이터 저장소가 적절한 입력값 검증을 수행하지 않는 소스에서 입력을 받을 수 있습니다. 따라서 응용 프로그램은 어떤 경우에도 이런 저런 데이터의 안전을 신뢰할 수 없습니다. 즉, XSS 취약점을 예방하는 최선의 방법은 응용 프로그램에 들어가고 응용 프로그램에서 사용자에게 전달되는 입력을 모두 확인하는 것입니다.

가장 안전한 XSS 검증 방법은 HTTP 컨텐츠에 사용할 수 있는 안전한 문자의 허용 목록을 만들어 이 승인된 집합의 문자만으로 이루어진 입력만 받는 것입니다. 예를 들어, 올바른 사용자 이름은 영숫자만 포함하거나 전화 번호는 숫자 0-9만 포함하도록 합니다. 하지만 이 방법은 문자를 인코딩한 후 브라우저에 특별한 의미가 있는 많은 문자를 올바른 입력으로 간주해야 하는 웹 응용 프로그램에서는 실효성이 떨어집니다. 그 예로 사용자로부터 HTML 코드를 입력받아야 하는 웹 디자인 게시판을 들 수 있습니다.

보다 유연하지만 안전성이 떨어지는 접근 방식은 거부 목록을 구현하는 것입니다. 거부 목록 방식은 입력을 사용하기 전에 위험한 문자를 선별적으로 거부하거나 이스케이프 처리합니다. 리스트를 만들려면 먼저 웹 브라우저에 특별한 의미가 있는 문자 집합을 이해해야 합니다. HTML 표준에 특별한 의미가 있는 문자가 정의되어 있는데도 많은 웹 브라우저가 HTML에서 흔히 발생하는 실수를 수정하려고 하고 다른 문자를 상황에 따라 특별한 의미로 처리할 수 있습니다. 그러므로 거부 목록을 사용하여 XSS를 방지하지 않는 것이 좋습니다. 카네기 멜론 대학 SEI(Software Engineering Institute)의 CERT(R) Coordination Center에서는 다음과 같이 여러 상황에서 특수 문자에 대한 세부 정보를 제공합니다[1].

Block-level element 항목(텍스트 단락 중간):

- "&lt;"는 태그가 시작되는 표시이기 때문에 특수합니다.

- "&amp;"는 문자 엔터티가 시작되는 표시이기 때문에 특수합니다.

- "&gt;"는 일부 브라우저에서 페이지 작성자가 여는 "&lt;"를 포함할 계획이었지만 실수로 누락했다는 가정하에 특수하게 처리되기 때문에 특수합니다.

다음 원칙은 속성 값에 적용됩니다.

- 큰따옴표로 묶은 속성 값에서 큰따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 작은따옴표로 묶은 속성 값에서 작은따옴표는 속성 값의 끝을 나타내기 때문에 특수합니다.

- 따옴표가 없는 속성 값에서 공백 및 탭과 같은 공백 문자는 특수 문자입니다.

- "&amp;"는 특정 속성과 함께 사용될 때 문자 엔터티가 시작되는 곳이기 때문에 특수합니다. 

예를 들어, URL에서 검색 엔진은 결과 페이지 내에 사용자가 클릭만 하면 검색을 다시 실행할 수 있는 링크를 제공합니다. 이는 URL 내에 검색 쿼리를 인코딩하여 구현할 수 있는데 특수 문자를 추가로 도입하게 됩니다.

- 공백, 탭 및 줄 바꿈은 URL 끝을 나타내기 때문에 특수합니다.

- "&amp;"는 문자 엔터티의 시작을 나타내거나 CGI 매개 변수를 구분하기 때문에 특수합니다.

- ASCII가 아닌 문자(즉, ISO-8859-1 인코딩에서 127보다 큰 모든 문자)는 URL에 사용할 수 없기 때문에 이 상황에서 특수 문자로 간주됩니다.

- "%" 기호는 HTTP 이스케이프 시퀀스로 인코딩된 매개 변수가 서버 쪽 코드로 디코딩되는 경우 입력에서 필터링해야 합니다. 예를 들어, "%"는 "%68%65%6C%6C%6F"와 같은 입력이 웹 페이지에 나타날 때 "hello"가 되는 경우 필터링해야 합니다.


&lt;SCRIPT&gt; &lt;/SCRIPT&gt;의 본문 내에서:

- 세미콜론, 괄호, 중괄호 및 줄 바꿈 문자는 텍스트를 이전부터 존재하는 스크립트 태그에 바로 삽입하는 경우 필터링해야 합니다.

서버 쪽 스크립트:

- 입력의 느낌표(!)를 출력의 큰따옴표(")로 변환하는 서버 쪽 스크립트에는 추가 필터링이 필요합니다. 

기타 가능성:

- 공격자가 UTF-7로 요청을 제출하는 경우 특수 문자 "&lt;"가 '+ADw-'로 나타나고 필터링이 무시될 수 있습니다. 출력에 인코딩 형식을 명시적으로 지정하지 않는 페이지가 포함된 경우 일부 브라우저는 콘텐트(이 경우, UTF-7)에 기초하여 합리적으로 인코딩을 식별하려고 시도합니다.

응용 프로그램에서 XSS 공격을 확인하는 정확한 지점과 확인 과정에서 고려해야 하는 특수 문자를 식별한 후 다음 과제는 확인 과정에서 특수 문자를 처리하는 방법을 알아내는 것입니다. 특수 문자를 응용 프로그램의 올바른 입력으로 간주하지 않는 경우, 특수 문자가 들어 있는 모든 입력을 잘못된 것으로 판단하고 거부할 수 있습니다. 두 번째 옵션은 필터링으로 특수 문자를 제거하는 것입니다. 하지만 필터링은 필터링된 콘텐트의 표현을 변경시키는 부작용이 있기 때문에 입력 내용을 그대로 보존하여 표시해야 하는 경우에는 허용할 수 없습니다.

특수 문자가 있는 입력을 받아들여 그대로 표시해야 하는 경우, 검증 작업에서 특수 문자를 인코딩하여 특수한 의미를 제거해야 합니다. ISO 8859-1 특수 문자의 인코딩된 값의 완전한 목록이 공식 HTML 규격의 일부로 제공됩니다[2].

많은 응용 프로그램 서버가 응용 프로그램이 Cross-Site Scripting 공격에 필수적인 문자가 있는지 확인하는 특정 HTTP 응답 콘텐트 설정을 담당하는 기능을 구현하여 Cross-Site Scripting 취약점에 노출되는 것을 막으려고 합니다. 응용 프로그램을 실행하는 서버에 응용 프로그램의 보안을 맡길 수 없습니다. 개발된 응용 프로그램이 응용 프로그램의 수명 동안 어떤 서버에서 실행될지 알 수 없기 때문입니다. 표준 및 알려진 익스플로이트의 진화 속도에 따라 응용 프로그램 서버가 계속 진화한다는 보장이 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 데이터베이스에 신뢰할 수 없는 데이터를 쓰면 Fortify Secure Coding Rulepacks에서 SQL Injection 관련 경고를 표시하며, 데이터베이스를 신뢰할 수 없는 데이터의 소스로 처리하므로 XSS 취약성이 발생할 수 있습니다. 데이터베이스가 사용자 환경에서 신뢰할 수 있는 리소스인 경우, 사용자 지정 필터를 사용하여 DATABASE 감염 플래그를 포함하고 데이터베이스 소스에서 발생하는 데이터 흐름 이슈를 필터링하십시오. 그러나 데이터베이스에서 읽는 모든 내용을 확인하는 것이 여전히 효과적인 경우가 많습니다.

2. 비록 신뢰할 수 없는 데이터에 대한 URL 인코딩이 많은 XSS 공격을 막아주긴 하지만, 일부 브라우저(특히 Internet Explorer 6 및 7 그 외 다른 브라우저들)는 JavaScript 인터프리터로 전송하기 전에 DOM(Document Object Model) 내의 특정 지점에서 자동으로 내용을 해독합니다. 이러한 위험을 반영하기 위해 룰팩은 더 이상 Cross-Site Scripting을 방지하는 데 충분한 URL 인코딩 루틴을 처리하지 않습니다. URL 암호화 이후 도출되는 데이터 값으로 Fortify는 Cross-Site Scripting, Poor Validation 취약점을 보고할 수 있습니다.

3. Fortify AppDefender adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B096458EEBEC91D30EA97721FF2F280D" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>login.jsp의 _jspService() 메서드가 19 줄의 확인되지 않은 데이터를 웹 브라우저에 보내면 브라우저에서 악성 코드를 실행하는 결과를 초래할 수 있습니다.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>login.jsp</FileName>
<FilePath>login.jsp</FilePath>
<LineStart>19</LineStart>
<Snippet>			
	%&gt;
	&lt;p&gt;Hello, &lt;%= ((String)request.getAttribute("res")).substring(1) %&gt;&lt;/p&gt;
	&lt;% }else{
		%&gt;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LoginModel.java</FileName>
<FilePath>src/adrui/LoginModel.java</FilePath>
<LineStart>9</LineStart>
<Snippet>	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Bad Practices: getConnection()</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>J2EE 표준은 직접적인 연결 관리를 금지합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>J2EE 표준에 따르면 응용 프로그램이 컨테이너의 리소스 관리 기능을 사용하여 리소스 연결을 확보해야 합니다. 

예를 들어, J2EE 응용 프로그램은 다음과 같이 데이터베이스에 연결해야 합니다.


ctx = new InitialContext();
datasource = (DataSource)ctx.lookup(DB_DATASRC_REF);
conn = datasource.getConnection();


또한 다음과 같은 방식으로 연결하는 것은 피해야 합니다.


conn = DriverManager.getConnection(CONNECT_STRING);


모든 주요 웹 응용 프로그램 컨테이너는 리소스 관리 프레임워크의 일부로 공용 데이터베이스 연결 관리 기능을 제공합니다. 응용 프로그램에 이 기능을 복제하는 것은 어려운 작업이고 오류가 발생하기 쉽기 때문에 J2EE 표준에서 금지합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>DriverManager.getConnection()의 직접 호출을 적절한 연결 팩토리의 JNDI 조회로 대체하여 연결 팩토리를 통해 연결합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 사용 중인 리소스 관리 스키마의 복잡성에 따라 독점 연결 관리 인프라에서 특정 오류를 식별하는 것이 어려울 수 있습니다. 버그를 찾으려 하는 대신 컨테이너에서 제공하는 연결 풀 관리자로 응용 프로그램을 마이그레이션하도록 합니다.

2. 야기될 가능성이 있는 더 많은 일반적인 성능 문제 외에도 독점 연결 관리는 비밀번호 관리 실수로 이어지는 경우가 많습니다. 자체 데이터베이스 연결을 관리하는 응용 프로그램에서는 즉시 사용할 수 있는 대안이 없기 때문에 일반 텍스트 구성 파일에 하드코드되거나 저장된 비밀번호를 찾는 것이 일반적입니다. 이러한 유형의 동작 예는 응용 프로그램 서버 관리 연결 풀로 이동하기 위한 인수에 정보를 추가하는 역할을 해야 합니다.

3. J2EE가 아닌 Java 응용 프로그램을 감사하는 경우 J2EE의 부적절한 사례 범주가 사용자 환경에 적용되지 않을 수 있습니다. 이런 경우 Audit Guide를 사용하여 이러한 문제를 억제할 수 있습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E4385F2C90FC80BDADB7174333CB0B19" ruleID="EDD8E0B5-D8F2-4F56-A20B-549E3880318B">
                            <Category>J2EE Bad Practices: getConnection()</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>J2EE 표준은 직접적인 연결 관리를 금지합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>28</LineStart>
<Snippet>		try{
			Class.forName(driver);//�뒥饔썽㈀�뒯葉뗥틣映�, 遙섊뎵�쑍jdbc�룾餓η쐛�렮, �쎑�뀽�룾�눎烏뚨쇍佯�
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute("conn", conn);
			System.out.println("Connect Succeed!");</Snippet>
<TargetFunction>getConnection()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Excessive Session Timeout</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>지나치게 긴 세션 시간 초과는 공격자에게 사용자 계정을 잠재적으로 손상시킬 수 있는 시간을 더 많이 제공합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>세션을 더 오래 열어둘수록, 공격자가 사용자 계정을 손상시킬 수 있는 기회는 더 커집니다. 세션이 활성화 상태라면 공격자는 사용자의 암호를 무차별 대입하거나 사용자의 무선 암호화 키를 불법으로 복제하거나 열려 있는 브라우저에서 세션을 제멋대로 쓸 수도 있습니다. 또한 세션 초과 시간이 더 길어지면 메모리가 해제되지 못하도록 하여 결국 충분히 많은 세션이 만들어지는 경우 Denial of Service가 발생됩니다.

예제 1: 세션 시간 초과가 0 또는 0 미만일 경우, 세션은 만료되지 않습니다. 다음 예는 -1로 설정된 세션 시간 초과를 보여주며 이로 인해 세션은 무기한으로 활성화 상태가 됩니다.

&lt;session-config&gt;
    &lt;session-timeout&gt;-1&lt;/session-timeout&gt;
&lt;/session-config&gt;


&lt;session-timeout&gt; 태그는 웹 응용 프로그램의 모든 세션에 대해 기본 세션 시간 초과 간격을 정의합니다. &lt;session-timeout&gt; 태그가 누락된 경우, 기본 시간 초과를 설정하도록 컨테이너에 맡겨집니다.&#13;
이 카테고리는 Cigital Java Rulepack에서 비롯되었습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>세션 시간 초과를 30분 이하로 설정하십시오. 그러면 사용자가 일정 기간 동안 응용 프로그램과 상호 작용할 수 있을 뿐 아니라 공격 기간에 대한 합리적인 경계가 제공됩니다.

예제 2: 다음 예제는 세션 시간 초과를 20분으로 설정합니다.

&lt;session-config&gt;
  &lt;session-timeout&gt;20&lt;/session-timeout&gt;
&lt;/session-config&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C2F39B963AB1AFACD8D57325EEAF747F" ruleID="B7ED276F-524D-444B-8930-7D77535BF0D0">
                            <Category>J2EE Misconfiguration: Excessive Session Timeout</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>지나치게 긴 세션 시간 초과는 공격자에게 사용자 계정을 잠재적으로 손상시킬 수 있는 시간을 더 많이 제공합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>WEB-INF/web.xml</FilePath>
<LineStart>2</LineStart>
<Snippet>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt;
  &lt;display-name&gt;LoginProject&lt;/display-name&gt;
  &lt;welcome-file-list&gt;</Snippet>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Missing Error Handling</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>웹 응용 프로그램은 기본 오류 페이지를 정의하여 공격자가 응용 프로그램 컨테이너의 기본 제공 오류 응답의 정보를 빼내는 것을 방지해야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>공격자가 웹 사이트에서 취약점을 찾기 위해 탐색할 때 사이트가 제공하는 정보의 양이 공격 시도의 성패를 결정짓는 핵심 요소입니다. 응용 프로그램이 공격자에게 스택 추적을 보여주면 공격자의 공격을 아주 쉽게 만드는 정보를 제공하는 셈이 됩니다. 예를 들어, 스택 추적은 공격자에게 잘못된 SQL 쿼리 문자열, 사용 중인 데이터베이스 유형 및 응용 프로그램 컨테이너 버전을 보여줄 수 있습니다. 공격자는 이 정보를 사용하여 이 구성 요소의 알려진 취약점을 공략합니다.

응용 프로그램 구성은 응용 프로그램이 오류 메시지를 공격자에게 누출하지 않는다는 것을 보장하기 위해 기본 오류 페이지를 지정해야 합니다. 표준 HTTP 오류 코드를 처리하는 것은 바람직한 보안 관행일 뿐만 아니라 유용하고 사용자 친화적입니다. 또한 응용 프로그램에서 발생할 수 있는 예외를 포착하는 마지막 오류 처리기도 정의해야 좋은 구성이라고 할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>웹 응용 프로그램은 기본 오류 페이지와 함께 구성해야 합니다. web.xml에 최소한 다음 항목이 포함되어야 합니다.


&lt;error-page&gt;
   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;404&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;500&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="399A248E35AE0FBB04255DE45FA9754C" ruleID="749BCC9F-FE61-4DC0-9EF2-5EF1872C7717">
                            <Category>J2EE Misconfiguration: Missing Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>웹 응용 프로그램은 기본 오류 페이지를 정의하여 공격자가 응용 프로그램 컨테이너의 기본 제공 오류 응답의 정보를 빼내는 것을 방지해야 합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>WEB-INF/web.xml</FilePath>
<LineStart>2</LineStart>
<Snippet>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt;
  &lt;display-name&gt;LoginProject&lt;/display-name&gt;
  &lt;welcome-file-list&gt;</Snippet>
<TargetFunction>/web-app()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Password Management</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MyContextListener.java의 contextInitialized() 메서드는 28 줄의 일반 텍스트 암호를 사용합니다. 암호를 일반 텍스트로 저장하면 시스템 침해가 발생할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Password management 이슈는 암호를 응용 프로그램의 속성 또는 구성 파일에 일반 텍스트로 저장할 때 발생합니다. 

예제 1: 다음 코드는 속성 파일에서 암호를 읽어 이 암호를 사용하여 데이터베이스에 연결합니다.


...
Properties prop = new Properties();
prop.load(new FileInputStream("config.properties"));
String password = prop.getProperty("password");

DriverManager.getConnection(url, usr, password);
...


이 코드는 올바로 실행되지만 config.properties에 대한 액세스 권한이 있는 사용자면 누구나 password의 값을 읽을 수 있습니다. 비양심적인 직원이 이 정보에 대한 액세스 권한을 갖게 되면 이를 사용하여 시스템에 침입할 수 있습니다.

모바일 환경에서는 장치 분실 위험이 높기 때문에 암호 관리가 특히 중요합니다.
예제 2: 다음 코드는 Android WebView 저장소에서 사용자 이름과 암호를 읽은 다음 보호된 페이지를 보기 위한 인증을 설정하는 데 사용합니다.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    handler.proceed(username, password);
  }
});
...


WebView 자격 증명은 기본적으로 일반 텍스트로 저장되고 해시되지 않습니다. 따라서 사용자가 루팅된 장치나 에뮬레이터를 사용하는 경우 지정된 사이트에 저장된 암호를 읽을 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>암호를 일반 텍스트로 저장해서는 안 됩니다. 시스템이 시작될 때 관리자에게 암호를 입력하도록 요구해야 합니다. 이 방법을 사용할 수 없을 때 안전성은 떨어지지만 비교적 타당한 솔루션은 암호를 난독 처리하고 시스템에 난독 처리 해제 요소를 분산시켜 공격자가 여러 시스템 리소스를 확보하여 정확하게 조합해야만 암호를 해독할 수 있게 만드는 것입니다. 최소한 암호를 저장하기 전에 해시해야 합니다.

일부 타사 제품은 암호를 안전하게 관리할 수 있다고 주장합니다. 예를 들면, WebSphere Application Server 4.x는 간단한 XOR 암호화 알고리즘을 사용하여 값을 난독 처리하지만 그 기능을 신뢰하기 어렵습니다. WebSphere 및 기타 응용 프로그램 서버는 보안에 민감한 환경에는 불충분한 오래되고 비교적 약한 암호화 메커니즘을 제공합니다. 현재 일반 보안 솔루션에 대한 최선의 방법은 직접 독점 메커니즘을 생성하는 것입니다.

Android의 경우 SQLite 데이터베이스를 사용하는 다른 플랫폼과 마찬가지로 SQLCipher를 대신 사용하는 것이 좋습니다. SQLCipher는 SQLite 데이터베이스에 대한 확장으로, 데이터베이스 파일의 투명한 256비트 AES 암호화를 제공합니다. 따라서 암호화된 데이터베이스에 자격 증명을 저장할 수 있습니다.

예제 3: 다음 코드는 필요한 바이너리를 다운로드한 후 SQLCipher를 Android 응용 프로그램에 통합하고 자격 증명을 데이터베이스 파일에 저장하는 방법을 보여줍니다.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


android.database.sqlite.SQLiteDatabase 관련 참조는 net.sqlcipher.database.SQLiteDatabase 관련 참조로 대체됩니다.

WebView 저장소에서 암호화를 활성화하려면 sqlcipher.so 라이브러리를 사용하여 WebKit를 다시 컴파일해야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Secure Coding Rulepacks는 암호를 인수로 사용하는 것으로 알려진 함수를 찾아 암호 관리 이슈를 식별합니다. 암호가 프로그램 외부에서 제공되며 식별된 난독 처리 해제 루틴을 통과하지 않고 사용되는 경우 Fortify Static Code Analyzer는 암호 관리 이슈 플래그를 지정합니다.

Password Management 이슈를 감사하려면 암호가 시스템에 입력되는 지점부터 암호를 사용하는 지점까지 프로그램을 추적합니다. 난독 처리 해제를 수행하는 코드를 찾습니다. 난독 처리 해제 코드가 없으면 이 이슈는 해결되지 않은 것입니다. 암호가 난독 처리 해제 함수를 통과하는 경우 암호를 보호하는 데 사용하는 알고리즘이 견고한지 확인합니다.

암호가 제대로 보호된다고 확신하면 암호가 난독 처리로 보호되고 있음을 나타내는 난독 처리 해제 루틴에 대한 사용자 지정 통과 규칙(pass-through rule)을 작성합니다. 이 규칙을 향후 응용 프로그램 분석에 포함시키면 식별된 난독 처리 해제 루틴을 통과한 암호는 더 이상 Password Management 취약점을 일으키지 않습니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Struts 2 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="88F5DB5C1FEF4C0BCA0EDC265177D3F9" ruleID="E05C0DB1-F798-4A77-9A6A-42ACEBA215E6">
                            <Category>Password Management</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>MyContextListener.java의 contextInitialized() 메서드는 28 줄의 일반 텍스트 암호를 사용합니다. 암호를 일반 텍스트로 저장하면 시스템 침해가 발생할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>28</LineStart>
<Snippet>		try{
			Class.forName(driver);//�뒥饔썽㈀�뒯葉뗥틣映�, 遙섊뎵�쑍jdbc�룾餓η쐛�렮, �쎑�뀽�룾�눎烏뚨쇍佯�
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute("conn", conn);
			System.out.println("Connect Succeed!");</Snippet>
<TargetFunction>java.sql.DriverManager.getConnection()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>25</LineStart>
<Snippet>		String url = sc.getInitParameter("url");
		String user = sc.getInitParameter("user");
		String pass = sc.getInitParameter("pass");
		try{
			Class.forName(driver);//�뒥饔썽㈀�뒯葉뗥틣映�, 遙섊뎵�쑍jdbc�룾餓η쐛�렮, �쎑�뀽�룾�눎烏뚨쇍佯�</Snippet>
<TargetFunction>javax.servlet.ServletContext.getInitParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MyContextListener.java 줄 32의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>여러 catch 블록은 반복적이지만 Exception 같은 높은 수준의 클래스를 catch하여 catch 블록을 "압축"하면 특수 처리가 필요하거나 프로그램의 이 시점에서 catch되지 않아야 하는 예외 사항을 숨길 수 있습니다. 지나치게 광범위한 예외 사항을 catch하면 Java의 형식화된 예외 사항을 사용하는 의미가 사라지고 특히 프로그램이 커져서 새로운 형식의 예외 사항이 발생하기 시작하면 위험해질 수 있습니다. 새 예외 형식에는 주의를 기울이지 않기 때문입니다.

예제: 다음 발췌된 코드는 세 가지 형식의 예외 사항을 동일한 방식으로 처리합니다.


  try {
    doExchange();
  }
  catch (IOException e) {
    logger.error("doExchange failed", e);
  }
  catch (InvocationTargetException e) {
    logger.error("doExchange failed", e);
  }
  catch (SQLException e) {
    logger.error("doExchange failed", e);
  }


언뜻 보기에 다음과 같이 예외 사항을 하나의 catch 블록으로 처리하는 것이 바람직한 것처럼 보입니다.


  try {
    doExchange();
  }
  catch (Exception e) {
    logger.error("doExchange failed", e);
  }


하지만 doExchange()가 수정되어 다른 방식으로 처리해야 하는 새로운 형식의 예외 사항이 발생하면 광범위한 catch 블록 때문에 컴파일러가 문제를 지적할 수 없습니다. 뿐만 아니라, 새 catch 블록은 ClassCastException 및 NullPointerException과 같이 RuntimeException에서 파생된 예외 사항도 처리하는데 이는 프로그래머의 의도와 반대되는 것입니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>아주 높은 수준의 프로그램이나 스레드를 제외하고는 Exception, Throwable, Error 또는 RuntimeException 같은 광범위한 예외 클래스를 catch하지 마십시오.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Secure Coding Rulepacks는 해당 catch 블록이 즉시 새 예외 사항을 발생시키면 overly broad catch 블록에 플래그를 지정하지 않습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C6BA8172A73EC89C2162EBDC5635A3D0" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MyContextListener.java 줄 32의 Catch 블록은 광범위한 예외 사항을 처리하기 때문에 프로그램의 이 시점에서 다루어서는 안 되는 상이한 사안이나 문제를 포착할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>32</LineStart>
<Snippet>			System.out.println("Connect Succeed!");
		}
		catch(Exception e){
			e.printStackTrace();
		}</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>LoginServlet.java의 doPost() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>신뢰의 경계는 프로그램으로 그어 놓은 선으로 생각할 수 있습니다. 선의 이쪽에서는 데이터를 신뢰하지 않습니다. 선의 반대편에서는 데이터를 신뢰할 수 있다고 간주합니다. 검증 로직을 사용하는 목적은 데이터가 신뢰의 경계를 안전하게 건너는 것 즉, 신뢰할 수 없는 데이터에서 신뢰할 수 있는 데이터로 이동하는 것을 허용하기 위해서입니다.

Trust boundary violation은 신뢰할 수 있는 것과 신뢰할 수 없는 것 사이의 경계를 프로그램이 흐릴 때 발생합니다. 이런 실수를 범하는 가장 흔한 방식은 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 같은 데이터 구조체에 혼합하는 것입니다. 



예제: 다음 Java 코드는 HTTP 요청을 받아 사용자가 인증되었는지 확인하기 전에 usrname 매개 변수를 HTTP 세션 개체에 저장합니다.


usrname = request.getParameter("usrname");
if (session.getAttribute(ATTR_USR) != null) {
    session.setAttribute(ATTR_USR, usrname);
}


잘 설계되고 유지 관리되는 신뢰 경계가 없으면 프로그래머는 어떤 데이터가 확인 작업을 거치고 거치지 않았는지에 대한 추적을 놓칠 수밖에 없습니다. 이런 혼란은 결국 일부 데이터를 확인하지 않고 사용하는 실수로 이어집니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>응용 프로그램에 분명한 신뢰 경계를 정의하십시오. 같은 데이터 구조체를 사용하여 신뢰할 수 있는 데이터를 한 컨텍스트에, 신뢰할 수 없는 데이터를 다른 컨텍스트에 보관해서는 안 됩니다. 데이터가 신뢰의 경계를 이동할 수 있는 방법의 수를 최소화합니다.

Trust boundary violation은 처리하기 전에 일련의 사용자 상호 작용을 거쳐 입력을 생성해야 하는 경우에 발생합니다. 모든 데이터가 도착할 때까지는 입력값 검증을 완료할 수 없습니다. 이런 경우, 신뢰 경계를 유지하는 것이 중요합니다. 신뢰할 수 없는 단일 데이터 구조체에 신뢰할 수 없는 데이터를 보관하여 확인한 다음 신뢰할 수 있는 위치로 이동해야 합니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 확인되지 않은 데이터를 신뢰할 수 있는 것으로 가정하는 "증거가 명백한" 상황을 찾을 필요가 없습니다. 신뢰 경계를 분명하게 긋고 지키지 않으면 검증 오류를 피할 수 없습니다. 익스플로이트 시나리오를 검색하는 데 시간을 허비하기보다 프로그래머에게 명확한 신뢰 경계를 작성하도록 가르치는 데 집중해야 합니다.

2. 대부분의 프로그램에는 응용 프로그램의 의미로 정의되는 신뢰 경계가 있습니다. 사용자 입력이 신뢰 경계를 넘는 다른 경우를 검사하기 위해 사용자 지정 규칙을 작성하는 것도 고려해야 합니다.

3. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="EC5C8978193E476E43268D652AE9A30E" ruleID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>LoginServlet.java의 doPost() 메서드는 같은 데이터 구조체에 신뢰할 수 있는 데이터와 신뢰할 수 없는 데이터를 혼합합니다. 프로그래머가 실수로 확인되지 않은 데이터를 신뢰하는 일이 발생합니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LoginServlet.java</FileName>
<FilePath>src/adrui/LoginServlet.java</FilePath>
<LineStart>48</LineStart>
<Snippet>		try{
			String res = obj.check(conn, user, pass);
			request.setAttribute("res", res);
		//	request.setAttribute("Sno", sno);
			RequestDispatcher view = request.getRequestDispatcher("login.jsp");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LoginModel.java</FileName>
<FilePath>src/adrui/LoginModel.java</FilePath>
<LineStart>9</LineStart>
<Snippet>	public String check(Connection conn, String user, String pass) throws SQLException{
		state = conn.createStatement();
		rs = state.executeQuery(sql);
		while(rs.next()){
			if(rs.getString(2).equals(user)){</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unreleased Resource: Database</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>MyContextListener.java의 contextInitialized() 함수는 28 줄의 getConnection()에 의해 할당된 데이터베이스 리소스를 해제하지 못할 수도 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>리소스 누출은 최소한 두 가지 공통 원인이 있습니다.

- 오류 조건 및 기타 예외 상황.

- 프로그램의 어떤 부분이 리소스 해제를 담당하고 있는지에 대한 혼란

대부분의 공개되지 않은 리소스 문제는 일반적인 소프트웨어 안정성 문제를 일으킵니다. 하지만 공격자가 의도적으로 리소스 누출을 일으킬 수 있는 경우 공격자가 리소스 풀을 고갈시켜 DoS(Denial of Service) 공격을 실행할 수도 있습니다.

예제: 일반적인 조건에서 다음 코드는 데이터베이스 쿼리를 실행하고 데이터베이스가 반환한 결과를 처리한 다음 할당된 statement 개체를 닫습니다. 하지만 SQL을 실행하거나 결과를 처리하는 동안 예외 사항이 발생하면 statement 개체는 닫히지 않습니다. 이런 일이 자주 발생하면 데이터베이스에 사용 가능한 커서가 부족하게 되어 SQL 쿼리를 더 이상 실행할 수 없습니다.

  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();
&#13;
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>1. 리소스를 다시 확보하는 데 finalize()를 사용하지 마십시오. 개체의 finalize() 메서드를 호출하려면 가비지 수집기(garbage collector)는 개체가 가비지 수집 대상인지 판단해야 합니다. 가비지 수집기(garbage collector)는 JVM이 메모리가 부족한 경우를 제외하고는 실행할 필요가 없기 때문에 finalize() 메서드가 필요할 때 원하는 대로 호출된다는 보장이 없습니다. 또한 결국 가비지 수집기(garbage collector)가 실행되더라도 짧은 시간에 방대한 리소스를 다시 확보하기 때문에 성능이 "고르지 못하고" 전반적인 시스템 처리량이 낮아질 수 있습니다. 이런 효과는 시스템의 부하가 증가할수록 더욱 두드러집니다.

마지막으로 리소스 확보 작업이 응답하지 않도록 할 수 있으면(예: 네트워크로 데이터베이스와 통신해야 하는 경우), finalize() 메서드를 실행하고 있는 스레드도 응답하지 않습니다.

2. finally 블록의 리소스를 해제하십시오. 예제 코드는 다음과 같이 다시 작성해야 합니다.


  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}


이 해결책은 도우미 함수를 사용하여 statement를 닫으려 할 때 발생할 수 있는 예외를 기록합니다. 도우미 함수는 statement를 닫을 때마다 재사용될 것입니다.

또한 execCxnSql 메서드는 stmt 개체를 null로 초기화하지 않습니다. 대신 safeClose()를 호출하기 전에 stmt가 null이 아닌지 검사합니다. null 검사를 하지 않으면 Java 컴파일러는 stmt가 초기화되지 않았다고 보고합니다. 이 방법은 uninitialized variable을 발견하는 Java 기능을 이용한 것입니다. stmt를 더 복잡한 방법을 사용하여 null로 초기화하면 초기화하지 않고 stmt를 사용하는 경우를 컴파일러가 발견할 수 없습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 데이터베이스 연결을 닫으면 연결 개체와 연관된 다른 리소스가 자동으로 해제될 수도 있고 그렇지 않을 수도 있습니다. 응용 프로그램이 연결 풀링을 사용하는 경우에는 연결을 닫은 후에 다른 리소스를 명시적으로 닫는 것이 좋습니다. 응용 프로그램이 연결 풀링을 사용하지 않을 경우에는 데이터베이스 연결을 닫으면 다른 리소스도 자동으로 닫힙니다. 이러한 경우, 이 취약점은 유효하지 않습니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="92023524C89EC71DA935E356D0E8C099" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>MyContextListener.java의 contextInitialized() 함수는 28 줄의 getConnection()에 의해 할당된 데이터베이스 리소스를 해제하지 못할 수도 있습니다.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>28</LineStart>
<Snippet>		try{
			Class.forName(driver);//�뒥饔썽㈀�뒯葉뗥틣映�, 遙섊뎵�쑍jdbc�룾餓η쐛�렮, �쎑�뀽�룾�눎烏뚨쇍佯�
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute("conn", conn);
			System.out.println("Connect Succeed!");</Snippet>
<TargetFunction>conn = getConnection(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unsafe Reflection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>공격자가 MyContextListener.java의 27 줄에서 forName() 리플렉션 메서드의 인수를 제어할 수 있습니다. 이로 인해 응용 프로그램을 통해 예기치 못한 제어 흐름 경로를 만들어 보안 검사를 무시할 수 있습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>공격자가 응용 프로그램이 인스턴스화할 클래스 또는 호출할 메서드를 결정하는 데 사용할 값을 제공하게 되면 응용 프로그램을 통해 응용 프로그램 개발자가 의도하지 않은 제어 흐름 경로를 만들 가능성이 있습니다. 이 공격은 공격자가 authentication 또는 access control 검사를 무시하거나 응용 프로그램이 오작동을 일으키도록 합니다. 임의의 메서드나 생성자에게 전달되는 인수를 제어하는 기능도 교활한 공격자에게 공격을 성공시키는 데 필요한 유리한 조건을 제공할 수 있습니다. 

이런 상황은 공격자가 응용 프로그램의 classpath에 있는 위치에 파일을 업로드하거나 응용 프로그램의 classpath에 새 항목을 추가하게 되면 최악의 시나리오가 됩니다. 어느 쪽이든 공격자는 리플렉션을 사용하여 응용 프로그램에 새로운 악의적인 동작을 주입할 수 있습니다.

예제: 프로그래머가 리플렉션 API를 사용하는 공통된 이유는 자신만의 명령 디스패처를 구현하기 위해서입니다. 다음 예제는 리플렉션을 사용하지 않는 명령 디스패처를 보여줍니다.


String ctl = request.getParameter("ctl");
Worker ao = null;
if (ctl.equals("Add")) {
  ao = new AddCommand();
} else if (ctl.equals("Modify")) {
  ao = new ModifyCommand();
} else {
  throw new UnknownActionError();
}
ao.doAction(request);


프로그래머가 이 코드를 다음과 같이 리플렉션을 사용하도록 리팩터링할 수 있습니다.


    String ctl = request.getParameter("ctl");
    Class cmdClass = Class.forName(ctl + "Command");
    Worker ao = (Worker) cmdClass.newInstance();
    ao.doAction(request);


리팩터링은 처음에는 많은 장점이 있는 것처럼 보입니다. 코드 줄이 줄고 if/else 블록 전체가 사라질 뿐 아니라 이제는 명령 디스패처를 수정하지 않고 새 명령 유형을 추가하는 것도 가능합니다.

하지만 리팩터링은 공격자가 Worker 인터페이스를 구현하는 개체를 인스턴스화할 수 있습니다. 명령 디스패처가 access control을 계속 담당하는 경우, 프로그래머는 Worker 인터페이스를 구현하는 새 클래스를 만들 때마다 디스패처의 access control 코드를 수정해야 합니다. access control 코드를 수정하지 않으면 일부 Worker 클래스는 access control을 갖지 못합니다.

액세스 제어 문제를 해결하는 한 가지 방법은 Worker 개체가 액세스 제어 검사 수행을 담당하게 만드는 것입니다. 리팩터링된 코드의 예제는 다음과 같습니다.


String ctl = request.getParameter("ctl");
Class cmdClass = Class.forName(ctl + "Command");
Worker ao = (Worker) cmdClass.newInstance();
ao.checkAccessControl(request);
ao.doAction(request);


이 코드는 보다 개선되긴 했지만 분산된 방식으로 access control을 다루기 때문에 프로그래머가 access control 실수를 저지르기가 더 쉽습니다.

또한 이 코드는 리플렉션을 사용하여 명령 디스패처를 작성하는 데서 또 다른 보안 문제를 야기합니다. 공격자가 모든 종류의 개체에 대해 기본 생성자를 호출할 수 있습니다. 실제로 공격자는 Worker 인터페이스를 구현하는 개체에만 국한되어 있는 것은 아닙니다. 시스템의 모든 개체의 기본 생성자를 호출할 수 있습니다. 개체가 Worker 인터페이스를 구현하지 않는 경우 ClassCastException이 ao에 할당되기 전에 발생하지만 생성자가 공격자에게 유리한 작업을 수행하는 경우 이미 피해를 입은 것입니다. 이 시나리오는 간단한 응용 프로그램에서는 비교적 피해 정도가 약하지만 아주 복잡한 큰 응용 프로그램에서는 공격자가 얼마든지 생성자를 찾아 공격 도구로 이용할 수 있습니다.

즉각적인 호출자의 클래스 로더 검사 사용 작업을 수행하는 특정 Java API가 리플렉션 호출로 인해 반환된 신뢰할 수 없는 개체에서 호출되는 경우 접근 검사가 코드 실행 체인을 더욱 손상시킬수도 있습니다. 이러한 Java API는 실행 체인의 모든 호출자가 필요한 보안 권한을 갖도록 보장하는 SecurityManager 검사를 무시합니다. 리플렉션에 의해 반환된 신뢰할 수 없는 개체에서 API가 호출되지 않도록 주의해야 합니다. 이러한 API는 보안 접근 검사를 무시하고 시스템이 원격 공격에 취약해지도록 할 수 있기 때문입니다. 이러한 Java API에 대한 자세한 내용은 Secure Coding Guidelines for the Java Programming Language의 Guideline 9를 참조하십시오.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Unsafe reflection을 예방하는 최선의 방법은 다음 간접 참조를 사용하는 것입니다. 즉, 사용자가 지정할 수 있는 올바른 이름 목록을 만들어 사용자가 목록에서 선택하는 것만 허용하는 것입니다. 이 접근 방식에서는 사용자가 제공하는 입력을 리플렉션 API에 전달되는 이름을 지정하는 데 직접 사용하지 않습니다.

리플렉션은 사용자 지정 데이터 기반 아키텍처를 만드는 데 사용할 수도 있습니다. 이 아키텍처는 구성 파일이 응용 프로그램이 사용하는 개체의 형식과 조합을 결정하는 수단이 됩니다. 이런 프로그래밍 방식은 다음과 같은 보안 문제를 안고 있습니다.

- 프로그램을 제어하는 구성 파일은 프로그램 소스 코드의 필수적인 부분이므로 보호하고 검토해야 합니다.

- 구성 파일이 응용 프로그램마다 고유하기 때문에 디자인의 보안성을 평가하려면 고유한 작업을 수행해야 합니다.

- 응용 프로그램의 의미를 사용자 지정 형식의 구성 파일이 정의하기 때문에 최적의 정적 분석 결과를 얻으려면 사용자 지정 규칙이 있어야 합니다.

이런 이유로 팀에서 보안 평가에 엄청난 노력을 투입할 수 있는 상황이 아니면 이런 형식의 디자인은 피하는 것이 좋습니다.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. 리플렉션 메서드 호출의 일부로 사용자 입력을 사용하기 전에 반드시 확인해야 합니다. 응용 프로그램이 운영 체제, file system 또는 기타 시스템 구성 요소보다 빠른 속도로 발전하기 때문에 사용자 입력값 검증에 필요한 작업은 사용자 데이터를 다른 시스템 구성 요소에 보내는 데 필요한 입력 확인보다 훨씬 빠르게 발전해야 합니다. 현재는 검증이 올바로 동작하더라도 앞으로는 정확하지 않을 수 있습니다.

2. 많은 최신 웹 프레임워크는 사용자 입력의 검증을 수행하기 위한 메커니즘을 제공합니다(Struts 및 Spring MVC 포함). 확인되지 않은 입력의 소스를 강조하기 위해, Fortify 보안 코딩 규칙 팩은 악용 가능성을 낮추고 프레임워크 검증 메커니즘이 사용 중일 때마다 지원하는 증거에 포인터를 제공하여 Fortify Static Code Analyzer에서 보고한 문제의 우선 순위를 동적으로 재지정합니다. 이 기능을 Context-Sensitive Ranking(컨텍스트 감지 순위)이라고 부릅니다. Fortify 사용자의 감사 프로세스를 지원하기 위해, Fortify Software Security Research Group은 입력 소스에 적용된 검증 메커니즘에 따라 문제를 폴더로 그룹화하는 데이터 유효성 프로젝트 템플릿을 사용 가능하게 만듭니다.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5BA1400984294C9BF4B7411857C65201" ruleID="E1B32227-C0BD-4A57-9C34-6794D9089A21">
                            <Category>Unsafe Reflection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>공격자가 MyContextListener.java의 27 줄에서 forName() 리플렉션 메서드의 인수를 제어할 수 있습니다. 이로 인해 응용 프로그램을 통해 예기치 못한 제어 흐름 경로를 만들어 보안 검사를 무시할 수 있습니다.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>27</LineStart>
<Snippet>		String pass = sc.getInitParameter("pass");
		try{
			Class.forName(driver);//�뒥饔썽㈀�뒯葉뗥틣映�, 遙섊뎵�쑍jdbc�룾餓η쐛�렮, �쎑�뀽�룾�눎烏뚨쇍佯�
			Connection conn = DriverManager.getConnection(url, user, pass);
			sc.setAttribute("conn", conn);</Snippet>
<TargetFunction>java.lang.Class.forName()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MyContextListener.java</FileName>
<FilePath>src/adrui/MyContextListener.java</FilePath>
<LineStart>22</LineStart>
<Snippet>		// TODO Auto-generated method stub
		ServletContext sc = event.getServletContext();
		String driver = sc.getInitParameter("driver");
		String url = sc.getInitParameter("url");
		String user = sc.getInitParameter("user");</Snippet>
<TargetFunction>javax.servlet.ServletContext.getInitParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Issue Count by Category</Title>
        <SubSection enabled="true">
            <Title>Issues By Category</Title>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="4">
                        <groupTitle>Privacy Violation: Autocomplete</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>SQL Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>System Information Leak: Incomplete Servlet Error Handling</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Missing Check against Null</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>System Information Leak</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Bad Practices: getConnection()</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Excessive Session Timeout</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Missing Error Handling</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Password Management</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unreleased Resource: Database</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unsafe Reflection</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Issue Breakdown by Analysis</Title>
        <SubSection enabled="true">
            <Title>Issue by Analysis</Title>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="pie">
                    <Axis>Analysis</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="33">
                        <groupTitle>&lt;none&gt;</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
</ReportDefinition>
